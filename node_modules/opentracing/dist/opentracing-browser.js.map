{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f161fe60194da056272a","webpack:///./src/index.js","webpack:///./src/global_tracer.js","webpack:///./src/tracer.js","webpack:///./src/span.js","webpack:///./src/noop.js","webpack:///./src/span_context.js","webpack:///./src/constants.js","webpack:///./src/functions.js","webpack:///./src/reference.js","webpack:///./src/ext/tags.js","webpack:///./src/binary_carrier.js"],"names":[],"mappings":"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","file":"opentracing-browser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"opentracing\"] = factory();\n\telse\n\t\troot[\"opentracing\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f161fe60194da056272a\n **/","import * as GlobalTracer from './global_tracer';\nimport * as Constants from './constants';\nimport * as Functions from './functions';\nimport * as Noop from './noop';\nimport * as Tags from './ext/tags';\nimport BinaryCarrier from './binary_carrier';\nimport Reference from './reference';\nimport SpanContext from './span_context';\nimport Span from './span';\nimport Tracer from './tracer';\n\n// Object.assign() is not available on Node v0.12, so implement a similar\n// function here (subset of a proper polyfill).\nfunction _extend(target) {\n    for (let index = 1; index < arguments.length; index++) {\n        const source = arguments[index];\n        for (let key in source) { // eslint-disable-line no-restricted-syntax\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\n\n// Use `module.exports` rather than `export` to avoid the need to use `.default`\n// when requiring the package in ES5 code.\nmodule.exports = _extend(\n    {\n        BinaryCarrier : BinaryCarrier,\n        Reference     : Reference,\n        SpanContext   : SpanContext,\n        Span          : Span,\n        Tracer        : Tracer,\n        Tags          : Tags,\n    },\n    Constants,\n    Functions,\n    GlobalTracer\n);\n\n// Initialize the noops last to avoid a dependecy cycle between the classes.\nNoop.initialize();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import Tracer from './tracer';\n\nconst noopTracer = new Tracer();\nlet _globalTracer = null;\n\n// Allows direct importing/requiring of the global tracer:\n//\n// let globalTracer = require('opentracing/global');\n//      OR\n// import globalTracer from 'opentracing/global';\n//\n// Acts a bridge to the global tracer that can be safely called before the\n// global tracer is initialized. The purpose of the delegation is to avoid the\n// sometimes nearly intractible initialization order problems that can arise in\n// applications with a complex set of dependencies, while also avoiding the\n// case where\nclass GlobalTracerDelegate extends Tracer {\n\n    startSpan(...args) {\n        const tracer = _globalTracer || noopTracer;\n        return tracer.startSpan(...args);\n    }\n\n    inject(...args) {\n        const tracer = _globalTracer || noopTracer;\n        return tracer.inject(...args);\n    }\n\n    extract(...args) {\n        const tracer = _globalTracer || noopTracer;\n        return tracer.extract(...args);\n    }\n}\n\nconst globalTracerDelegate = new GlobalTracerDelegate();\n\n/**\n * Set the global Tracer.\n *\n * The behavior is undefined if this function is called more than once.\n *\n * @param {Tracer} tracer - the Tracer implementation\n */\nexport function initGlobalTracer(tracer) {\n    _globalTracer = tracer;\n}\n\n/**\n * Returns the global tracer.\n */\nexport function globalTracer() {\n    // Return the delegate.  Since the global tracer is largely a convenience\n    // (the user can always create their own tracers), the delegate is used to\n    // give the added convenience of not needing to worry about initialization\n    // order.\n    return globalTracerDelegate;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/global_tracer.js\n **/","import Span from './span';\nimport SpanContext from './span_context';\nimport * as Constants from './constants';\nimport * as Functions from './functions';\nimport * as Noop from './noop';\n\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\nexport default class Tracer {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('Subroutine', {\n     *         childOf: parent.context(),\n     *     });\n     *\n     * @param {string} name - the name of the operation.\n     * @param {object} [fields] - the fields to set on the newly created span.\n     * @param {string} [fields.operationName] - the name to use for the newly\n     *        created span. Required if called with a single argument.\n     * @param {SpanContext} [fields.childOf] - a parent SpanContext (or Span,\n     *        for convenience) that the newly-started span will be the child of\n     *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n     *        be unspecified.\n     * @param {array} [fields.references] - an array of Reference instances,\n     *        each pointing to a causal parent SpanContext. If specified,\n     *        `fields.childOf` must be unspecified.\n     * @param {object} [fields.tags] - set of key-value pairs which will be set\n     *        as tags on the newly created Span. Ownership of the object is\n     *        passed to the created span for efficiency reasons (the caller\n     *        should not modify this object after calling startSpan).\n     * @param {number} [fields.startTime] - a manually specified start time for\n     *        the created Span object. The time should be specified in\n     *        milliseconds as Unix timestamp. Decimal value are supported\n     *        to represent time values with sub-millisecond accuracy.\n     * @return {Span} - a new Span object.\n     */\n    startSpan(name, fields) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof name !== 'string') {\n                throw new Error('argument expected to be a string');\n            }\n            if (name.length === 0) {\n                throw new Error('operation name cannot be length zero');\n            }\n            if (fields && fields.childOf && fields.references) {\n                throw new Error('At most one of `childOf` and ' +\n                        '`references` may be specified');\n            }\n            if (fields && fields.childOf && !(\n                        fields.childOf instanceof Span ||\n                        fields.childOf instanceof SpanContext)) {\n                throw new Error('childOf must be a Span or SpanContext instance');\n            }\n        }\n\n        // Convert fields.childOf to fields.references as needed.\n        fields = fields || {};\n        if (fields.childOf) {\n            // Convert from a Span or a SpanContext into a Reference.\n            let childOf = Functions.childOf(fields.childOf);\n            if (fields.references) {\n                fields.references.push(childOf);\n            } else {\n                fields.references = [childOf];\n            }\n            delete(fields.childOf);\n        }\n        return this._startSpan(name, fields);\n    }\n\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    inject(spanContext, format, carrier) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 3) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (!(spanContext instanceof SpanContext || spanContext instanceof Span)) {\n                throw new Error('first argument must be a SpanContext or Span instance');\n            }\n            if (typeof format !== 'string') {\n                throw new Error(`format expected to be a string. Found: ${typeof format}`);\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_BINARY');\n            }\n        }\n\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof Span) {\n            spanContext = spanContext.context();\n        }\n        return this._inject(spanContext, format, carrier);\n    }\n\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    extract(format, carrier) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof format !== 'string' || !format.length) {\n                throw new Error('format is expected to be a string of non-zero length');\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY) {\n                if (carrier.buffer !== undefined && typeof carrier.buffer !== 'object') {\n                    throw new Error('Unexpected carrier object for FORMAT_BINARY');\n                }\n            }\n        }\n        return this._extract(format, carrier);\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n\n    // NOTE: the input to this method is *always* an associative array. The\n    // public-facing startSpan() method normalizes the arguments so that\n    // all N implementations do not need to worry about variations in the call\n    // signature.\n    //\n    // The default behavior returns a no-op span.\n    _startSpan(name, fields) {\n        return Noop.span;\n    }\n\n    // The default behavior is a no-op.\n    _inject(spanContext, format, carrier) {\n    }\n\n    // The default behavior is to return null.\n    _extract(format, carrier) {\n        return Noop.spanContext;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tracer.js\n **/","import * as noop from './noop';\n\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nexport default class Span {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    context() {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._context();\n    }\n\n\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    tracer() {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._tracer();\n    }\n\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    setOperationName(name) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof name !== 'string' || name.length === 0) {\n                throw new Error('Name must be a string of length > 0');\n            }\n        }\n\n        this._setOperationName(name);\n        return this;\n    }\n\n    /**\n     * Sets a key:value pair on this Span that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    setBaggageItem(key, value) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        this._setBaggageItem(key, value);\n        return this;\n    }\n\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    getBaggageItem(key) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._getBaggageItem(key);\n    }\n\n    /**\n     * Adds a single tag to the span.  See `addTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    setTag(key, value) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof key !== 'string') {\n                throw new Error('Tag key must be a string');\n            }\n        }\n\n        // NOTE: the call is normalized to a call to _addTags()\n        this._addTags({ [key] : value });\n        return this;\n    }\n\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    addTags(keyValueMap) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof keyValueMap !== 'object') {\n                throw new Error('Invalid argument type');\n            }\n        }\n\n        this._addTags(keyValueMap);\n        return this;\n    }\n\n    /**\n     * Add a log record to this Span, optionally at a user-provided timestamp.\n     *\n     * For example:\n     *\n     *     span.log({\n     *         size: rpc.size(),  // numeric value\n     *         URI: rpc.URI(),  // string value\n     *         payload: rpc.payload(),  // Object value\n     *         \"keys can be arbitrary strings\": rpc.foo(),\n     *     });\n     *\n     *     span.log({\n     *         \"error.description\": someError.description(),\n     *     }, someError.timestampMillis());\n     *\n     * @param {object} keyValuePairs\n     *        An object mapping string keys to arbitrary value types. All\n     *        Tracer implementations should support bool, string, and numeric\n     *        value types, and some may also support Object values.\n     * @param {number} timestamp\n     *        An optional parameter specifying the timestamp in milliseconds\n     *        since the Unix epoch. Fractional values are allowed so that\n     *        timestamps with sub-millisecond accuracy can be represented. If\n     *        not specified, the implementation is expected to use its notion\n     *        of the current time of the call.\n     */\n    log(keyValuePairs, timestamp) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2 || arguments.length === 0) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (arguments.length === 2) {\n                if (typeof timestamp !== 'number') {\n                    throw new Error('Expected timestamp to be a number');\n                }\n            }\n            if (typeof keyValuePairs !== 'object') {\n                throw new Error('Expected keyValuePairs to be an object');\n            }\n        }\n\n        this._log(keyValuePairs, timestamp);\n        return this;\n    }\n\n    /**\n     * DEPRECATED\n     */\n    logEvent(eventName, payload) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2 || arguments.length < 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof eventName !== 'string') {\n                throw new Error('Expected eventName to be a string');\n            }\n            if (payload !== undefined && typeof payload !== 'object') {\n                throw new Error('Expected payload to be an object');\n            }\n        }\n\n        return this._log({\n            event   : eventName,\n            payload : payload,\n        });\n    }\n\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    finish(finishTime) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 1) {\n                throw new Error('Invalid arguments');\n            }\n            if (arguments.length === 1 && typeof finishTime !== 'number') {\n                throw new Error('Unexpected argument type');\n            }\n        }\n\n        this._finish(finishTime);\n\n        // Do not return `this`. The Span generally should not be used after it\n        // is finished so chaining is not desired in this context.\n    }\n\n\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n\n    // By default returns a no-op SpanContext.\n    _context() {\n        return noop.spanContext;\n    }\n\n    // By default returns a no-op tracer.\n    //\n    // The base class could store the tracer that created it, but it does not\n    // in order to ensure the no-op span implementation has zero members,\n    // which allows V8 to aggressively optimize calls to such objects.\n    _tracer() {\n        return noop.tracer;\n    }\n\n    // By default does nothing\n    _setOperationName(name) {\n    }\n\n    // By default does nothing\n    _setBaggageItem(key, value) {\n    }\n\n    // By default does nothing\n    _getBaggageItem(key) {\n    }\n\n    // By default does nothing\n    //\n    // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n    // will always be an associative array.\n    _addTags(keyValuePairs) {\n    }\n\n    // By default does nothing\n    _log(keyValuePairs, timestamp) {\n    }\n\n    // By default does nothing\n    //\n    // finishTime is expected to be either a number or undefined.\n    _finish(finishTime) {\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/span.js\n **/","import Tracer from './tracer';\nimport SpanContext from './span_context';\nimport Span from './span';\n\n/* eslint-disable import/no-mutable-exports */\nexport let tracer = null;\nexport let spanContext = null;\nexport let span = null;\n/* eslint-enable import/no-mutable-exports */\n\n// Deferred initialization to avoid a dependency cycle where Tracer depends on\n// Span which depends on the noop tracer.\nexport function initialize() {\n    tracer = new Tracer();\n    span = new Span();\n    spanContext = new SpanContext();\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/noop.js\n **/","/**\n * SpanContext represents Span state that must propagate to descendant Spans\n * and across process boundaries.\n *\n * SpanContext is logically divided into two pieces: the user-level \"Baggage\"\n * (see setBaggageItem and getBaggageItem) that propagates across Span\n * boundaries and any Tracer-implementation-specific fields that are needed to\n * identify or otherwise contextualize the associated Span instance (e.g., a\n * <trace_id, span_id, sampled> tuple).\n */\nexport default class SpanContext {\n    // The SpanContext is entirely implementation dependent\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/span_context.js\n **/","/**\n * The FORMAT_BINARY format represents SpanContexts in an opaque binary\n * carrier.\n *\n * Tracer.inject() will set the buffer field to an Array-like (Array,\n * ArrayBuffer, or TypedBuffer) object containing the injected binary data.\n * Any valid Object can be used as long as the buffer field of the object\n * can be set.\n *\n * Tracer.extract() will look for `carrier.buffer`, and that field is\n * expected to be an Array-like object (Array, ArrayBuffer, or\n * TypedBuffer).\n */\nexport const FORMAT_BINARY = 'binary';\n\n/**\n * The FORMAT_TEXT_MAP format represents SpanContexts using a\n * string->string map (backed by a Javascript Object) as a carrier.\n *\n * NOTE: Unlike FORMAT_HTTP_HEADERS, FORMAT_TEXT_MAP places no restrictions\n * on the characters used in either the keys or the values of the map\n * entries.\n *\n * The FORMAT_TEXT_MAP carrier map may contain unrelated data (e.g.,\n * arbitrary gRPC metadata); as such, the Tracer implementation should use\n * a prefix or other convention to distinguish Tracer-specific key:value\n * pairs.\n */\nexport const FORMAT_TEXT_MAP = 'text_map';\n\n/**\n * The FORMAT_HTTP_HEADERS format represents SpanContexts using a\n * character-restricted string->string map (backed by a Javascript Object)\n * as a carrier.\n *\n * Keys and values in the FORMAT_HTTP_HEADERS carrier must be suitable for\n * use as HTTP headers (without modification or further escaping). That is,\n * the keys have a greatly restricted character set, casing for the keys\n * may not be preserved by various intermediaries, and the values should be\n * URL-escaped.\n *\n * The FORMAT_HTTP_HEADERS carrier map may contain unrelated data (e.g.,\n * arbitrary HTTP headers); as such, the Tracer implementation should use a\n * prefix or other convention to distinguish Tracer-specific key:value\n * pairs.\n */\nexport const FORMAT_HTTP_HEADERS = 'http_headers';\n\n/**\n * A Span may be the \"child of\" a parent Span. In a “child of” reference,\n * the parent Span depends on the child Span in some capacity.\n *\n * See more about reference types at http://opentracing.io/spec/\n */\nexport const REFERENCE_CHILD_OF = 'child_of';\n\n/**\n * Some parent Spans do not depend in any way on the result of their child\n * Spans. In these cases, we say merely that the child Span “follows from”\n * the parent Span in a causal sense.\n *\n * See more about reference types at http://opentracing.io/spec/\n */\nexport const REFERENCE_FOLLOWS_FROM = 'follows_from';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants.js\n **/","import * as Constants from './constants';\nimport Span from './span';\nimport Reference from './reference';\n\n/**\n * Return a new REFERENCE_CHILD_OF reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`\n */\nexport function childOf(spanContext) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof Span) {\n        spanContext = spanContext.context();\n    }\n    return new Reference(Constants.REFERENCE_CHILD_OF, spanContext);\n}\n\n/**\n * Return a new REFERENCE_FOLLOWS_FROM reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`\n */\nexport function followsFrom(spanContext) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof Span) {\n        spanContext = spanContext.context();\n    }\n    return new Reference(Constants.REFERENCE_FOLLOWS_FROM, spanContext);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/functions.js\n **/","import Span from './span';\nimport SpanContext from './span_context';\n\n/**\n * Reference pairs a reference type constant (e.g., REFERENCE_CHILD_OF or\n * REFERENCE_FOLLOWS_FROM) with the SpanContext it points to.\n *\n * See the exported childOf() and followsFrom() functions at the package level.\n */\nexport default class Reference {\n\n    /**\n     * @return {string} The Reference type (e.g., REFERENCE_CHILD_OF or\n     *         REFERENCE_FOLLOWS_FROM).\n     */\n    type() {\n        return this._type;\n    }\n\n    /**\n     * @return {SpanContext} The SpanContext being referred to (e.g., the\n     *         parent in a REFERENCE_CHILD_OF Reference).\n     */\n    referencedContext() {\n        return this._referencedContext;\n    }\n\n    /**\n     * Initialize a new Reference instance.\n     *\n     * @param {string} type - the Reference type constant (e.g.,\n     *        REFERENCE_CHILD_OF or REFERENCE_FOLLOWS_FROM).\n     * @param {SpanContext} referencedContext - the SpanContext being referred\n     *        to. As a convenience, a Span instance may be passed in instead\n     *        (in which case its .context() is used here).\n     */\n    constructor(type, referencedContext) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (!(referencedContext instanceof SpanContext || referencedContext instanceof Span)) {\n                throw new Error('referencedContext must be a Span or SpanContext instance');\n            }\n        }\n        this._type = type;\n        this._referencedContext = (\n                referencedContext instanceof Span ?\n                referencedContext.context() :\n                referencedContext);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/reference.js\n **/","module.exports = {\n\n    /** ------------------------------------------------------------------------\n    * SPAN_KIND hints at relationship between spans, e.g. client/server\n    * --------------------------------------------------------------------------*/\n    SPAN_KIND : 'span.kind',\n\n    // Marks a span representing the client-side of an RPC or other remote call\n    SPAN_KIND_RPC_CLIENT : 'client',\n\n    // Marks a span representing the server-side of an RPC or other remote call\n    SPAN_KIND_RPC_SERVER : 'server',\n\n    /** ------------------------------------------------------------------------\n    * ERROR (boolean) indicates whether a Span ended in an error state.\n    * --------------------------------------------------------------------------*/\n    ERROR : 'error',\n\n    /** ------------------------------------------------------------------------\n    * COMPONENT (string) ia s low-cardinality identifier of the module, library,\n    * or package that is generating a span.\n    * --------------------------------------------------------------------------*/\n    COMPONENT : 'component',\n\n    /** ------------------------------------------------------------------------\n    * SAMPLING_PRIORITY (number) determines the priority of sampling this Span.\n    * --------------------------------------------------------------------------*/\n    SAMPLING_PRIORITY : 'sampling.priority',\n\n    /** ------------------------------------------------------------------------\n    * PEER_* tags can be emitted by either client-side of server-side to describe\n    * the other side/service in a peer-to-peer communications, like an RPC call.\n    * ---------------------------------------------------------------------------*/\n\n    // PEER_SERVICE (string) records the service name of the peer\n    PEER_SERVICE : 'peer.service',\n\n    // PEER_HOSTNAME records the host name of the peer\n    PEER_HOSTNAME : 'peer.hostname',\n\n    // PEER_HOST_IPV4 (number) records IP v4 host address of the peer\n    PEER_HOST_IPV4 : 'peer.ipv4',\n\n    // PEER_HOST_IPV6 (string) records IP v6 host address of the peer\n    PEER_HOST_IPV6 : 'peer.ipv6',\n\n    // PEER_PORT (number) records port number of the peer\n    PEER_PORT : 'peer.port',\n\n    /** ------------------------------------------------------------------------\n    * HTTP tags\n    * ---------------------------------------------------------------------------*/\n\n    // HTTP_URL (string) should be the URL of the request being handled in this\n    // segment of the trace, in standard URI format. The protocol is optional.\n    HTTP_URL : 'http.url',\n\n    // HTTP_METHOD (string) is the HTTP method of the request.\n    // Both upper/lower case values are allowed.\n    HTTP_METHOD : 'http.method',\n\n    // HTTP_STATUS_CODE (number) is the numeric HTTP status code (200, 404, etc)\n    // of the HTTP response.\n    HTTP_STATUS_CODE : 'http.status_code',\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ext/tags.js\n **/","/**\n * Convenience class to use as a binary carrier.\n *\n * Any valid Object with a field named `buffer` may be used as a binary carrier;\n * this class is only one such type of object that can be used.\n */\nexport default class BinaryCarrier {\n    constructor(binaryData) {\n        this._buffer = binaryData;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary_carrier.js\n **/"],"sourceRoot":""}