{"version":3,"sources":["webpack:///webpack/bootstrap 4f185909e0fce9161de8","webpack:///./src/index.js","webpack:///./src/default_tracer.js","webpack:///./src/singleton.js","webpack:///./src/tracer.js","webpack:///./src/span.js","webpack:///./src/span_context.js","webpack:///./src/constants.js","webpack:///./src/reference.js","webpack:///./src/binary_carrier.js"],"names":[],"mappings":"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","file":"opentracing-node-debug.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4f185909e0fce9161de8\n **/","module.exports = require('./default_tracer');\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","'use strict';\n\nimport Singleton from './singleton';\n\nmodule.exports = new Singleton();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/default_tracer.js\n **/","'use strict';\n\nimport Tracer from './tracer';\nimport * as Constants from './constants';\nimport BinaryCarrier from './binary_carrier';\nimport Reference from './reference';\n\n/**\n * The Singleton object is the default export of the package and extends the\n * standard Tracer object so that the default\n * exported object of the package can be conveniently be used both as the\n * default tracer and an interface to the library.\n */\nexport default class Singleton extends Tracer {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Set the global Tracer's underlying implementation.\n     *\n     * The behavior is undefined if this function is called more than once.\n     *\n     * @param {TracerImp} tracerImp - the Tracer implementation object\n     */\n    initGlobalTracer(tracerImp) {\n        this._imp = tracerImp;\n\n        // Provide the implementation with a handle to the interface. This can\n        // also be used a post-initialization signal.\n        if (tracerImp) {\n            tracerImp.setInterface(this);\n        }\n    }\n\n    /**\n     * Create a new Tracer object with the given underlying implementation.\n     *\n     * @return {Tracer} a new Tracer object\n     */\n    initNewTracer(tracerImp) {\n        let tracer = new Tracer(tracerImp);\n        if (tracerImp) {\n            tracerImp.setInterface(this);\n        }\n        return tracer;\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Private and non-standard methods\n    // ---------------------------------------------------------------------- //\n\n    /* For internal use only:\n     *\n     * Creates the Singleton with no underlying implementation (i.e. defaults\n     * to no-op behavior for all functions).\n     *\n     * The OpenTracing package-level object acts both at the singleton and the\n     * package interface itself, so this Singleton is both a the Tracer and\n     * also includes all the global library symbols.\n     *\n     * Note: this should never be called directly by consumers of the library.\n     */\n    constructor() {\n        super();\n\n        // Merge the constants into the singleton object so they are accessible at the\n        // package level.\n        for (let key in Constants) {        // eslint-disable-line no-restricted-syntax\n            this[key] = Constants[key];\n        }\n        this.Reference = Reference;\n\n        // Carrier objects to be exposed at the package level\n        this.BinaryCarrier = BinaryCarrier;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/singleton.js\n **/","'use strict';\n\nimport Span from './span';\nimport SpanContext from './span_context';\nimport Constants from './constants';\nimport Reference from './reference';\n\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n */\nexport default class Tracer {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('Subroutine', {\n     *         reference: Tracer.childOf(parent.context()),\n     *     });\n     *\n     * @param {string|object} nameOrFields - if the given argument is a\n     *        string, it is the name of the operation and the second `fields`\n     *        argument is optional. If it is an object, it is treated as the\n     *        fields argument and a second argument should not be provided.\n     * @param {object} [fields] - the fields to set on the newly created span.\n     * @param {string} [fields.operationName] - the name to use for the newly\n     *        created span. Required if called with a single argument.\n     * @param {SpanContext} [fields.childOf] - a parent SpanContext (or Span,\n     *        for convenience) that the newly-started span will be the child of\n     *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n     *        be unspecified.\n     * @param {array} [fields.references] - an array of Reference instances,\n     *        each pointing to a causal parent SpanContext. If specified,\n     *        `fields.childOf` must be unspecified.\n     * @param {object} [fields.tags] - set of key-value pairs which will be set\n     *        as tags on the newly created Span. Ownership of the object is\n     *        passed to the created span for efficiency reasons (the caller\n     *        should not modify this object after calling startSpan).\n     * @param {number} [fields.startTime] - a manually specified start time for\n     *        the created Span object. The time should be specified in\n     *        milliseconds as Unix timestamp. Decimal value are supported\n     *        to represent time values with sub-millisecond accuracy.\n     * @return {Span} - a new Span object.\n     */\n    startSpan(nameOrFields, fields) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length > 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof nameOrFields !== 'string' && typeof nameOrFields !== 'object') {\n                throw new Error('argument expected to be a string or object');\n            }\n            if (typeof nameOrFields === 'string' && nameOrFields.length === 0) {\n                throw new Error('operation name cannot be length zero');\n            }\n            if (typeof nameOrFields === 'object') {\n                if (arguments.length !== 1) {\n                    throw new Error('Unexpected number of arguments');\n                }\n                if (nameOrFields === null) {\n                    throw new Error('fields should not be null');\n                }\n                if (!nameOrFields.operationName) {\n                    throw new Error('operationName is a required parameter');\n                }\n            }\n        }\n\n        let spanImp = null;\n        if (this._imp) {\n            // Normalize the argument so the implementation is always provided\n            // an associative array of fields.\n            if (arguments.length === 1) {\n                if (typeof nameOrFields === 'string') {\n                    fields = {\n                        operationName : nameOrFields,\n                    };\n                } else {\n                    fields = nameOrFields;\n                }\n            } else {\n                fields.operationName = nameOrFields;\n            }\n            if (API_CONFORMANCE_CHECKS) {\n                if (fields.childOf && fields.references) {\n                    throw new Error('At most one of `childOf` and ' +\n                            '`references` may be specified');\n                }\n                if (fields.childOf && !(\n                            fields.childOf instanceof Span ||\n                            fields.childOf instanceof SpanContext)) {\n                    throw new Error('childOf must be a Span or SpanContext instance');\n                }\n            }\n            // Convert fields.childOf to fields.references as needed.\n            if (fields.childOf) {\n                // Convert from a Span or a SpanContext into a Reference.\n                let childOf = this.childOf(fields.childOf);\n                if (fields.references) {\n                    fields.references.push(childOf);\n                } else {\n                    fields.references = [childOf];\n                }\n                delete(fields.childOf);\n            }\n            spanImp = this._imp.startSpan(fields);\n        }\n        return new Span(spanImp);\n    }\n\n    /**\n     * Return a new REFERENCE_CHILD_OF reference.\n     *\n     * @param {SpanContext} spanContext - the parent SpanContext instance to\n     *        reference.\n     * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`\n     */\n    childOf(spanContext) {\n        return new Reference(Constants.REFERENCE_CHILD_OF, spanContext);\n    }\n\n    /**\n     * Return a new REFERENCE_FOLLOWS_FROM reference.\n     *\n     * @param {SpanContext} spanContext - the parent SpanContext instance to\n     *        reference.\n     * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`\n     */\n    followsFrom(spanContext) {\n        return new Reference(Constants.REFERENCE_FOLLOWS_FROM, spanContext);\n    }\n\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    inject(spanContext, format, carrier) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 3) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (!(spanContext instanceof SpanContext || spanContext instanceof Span)) {\n                throw new Error('first argument must be a SpanContext or Span instance');\n            }\n            if (typeof format !== 'string') {\n                throw new Error(`format expected to be a string. Found: ${typeof format}`);\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_BINARY');\n            }\n        }\n\n        if (this._imp) {\n            // Allow the user to pass a Span instead of a SpanContext\n            if (spanContext instanceof Span) {\n                spanContext = spanContext.context();\n            }\n            this._imp.inject(spanContext._imp, format, carrier);\n        }\n    }\n\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    extract(format, carrier) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof format !== 'string' || !format.length) {\n                throw new Error('format is expected to be a string of non-zero length');\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY) {\n                if (carrier.buffer !== undefined && typeof carrier.buffer !== 'object') {\n                    throw new Error('Unexpected carrier object for FORMAT_BINARY');\n                }\n            }\n        }\n        let spanContextImp = null;\n        if (this._imp) {\n            spanContextImp = this._imp.extract(format, carrier);\n        }\n        if (spanContextImp !== null) {\n            return new SpanContext(spanContextImp);\n        }\n        return null;\n    }\n\n    /**\n     * Request that any buffered or in-memory data is flushed out of the process.\n     *\n     * @param {function(err: objectg)} done - optional callback function with\n     *        the signature `function(err)` that will be called as soon as the\n     *        flush completes. `err` should be null or undefined if the flush\n     *        was successful.\n     */\n    flush(done) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length > 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (done !== undefined && typeof done !== 'function') {\n                throw new Error('callback expected to be a function');\n            }\n        }\n        if (!this._imp) {\n            done(null);\n            return;\n        }\n        this._imp.flush(done);\n    }\n\n\n    // ---------------------------------------------------------------------- //\n    // Private and non-standard methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Note: this constructor should not be called directly by consumers of this\n     * code. The singleton's initNewTracer() method should be invoked instead.\n     */\n    constructor(imp) {\n        this._imp = imp || null;\n    }\n\n    /**\n     * Handle to implementation object.\n     *\n     * Use of this method is discouraged as it greatly reduces the portability of\n     * the calling code. Use only when implementation-specific functionality must\n     * be used and cannot accessed otherwise.\n     *\n     * @return {object}\n     *         An implementation-dependent object.\n     */\n    imp() {\n        return this._imp;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tracer.js\n **/","'use strict';\n\nimport Tracer from './tracer';\nimport SpanContext from './span_context';\nlet defaultTracer = require('./default_tracer');\n\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nexport default class Span {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    context() {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        let spanContextImp = null;\n        if (this._imp) {\n            spanContextImp = this._imp.context();\n        }\n        return new SpanContext(spanContextImp);\n    }\n\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    tracer() {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            return new Tracer(this._imp.tracer());\n        }\n        return defaultTracer;\n    }\n\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    setOperationName(name) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof name !== 'string' || name.length === 0) {\n                throw new Error('Name must be a string of length > 0');\n            }\n        }\n        if (this._imp) {\n            this._imp.setOperationName(name);\n        }\n        return this;\n    }\n\n    /**\n     * Adds a single tag to the span.  See `AddTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    setTag(key, value) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof key !== 'string') {\n                throw new Error('Tag key must be a string');\n            }\n        }\n        this.addTags({ [key] : value });\n        return this;\n    }\n\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    addTags(keyValuePairs) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof keyValuePairs !== 'object') {\n                throw new Error('Invalid argument type');\n            }\n        }\n\n        if (!this._imp) {\n            return;\n        }\n        this._imp.addTags(keyValuePairs);\n        return this;\n    }\n\n    /**\n     * Explicitly create a log record associated with the span.\n     *\n     * @param {object} fields - object containing the log record properties\n     * @param {number} [fields.timestamp] - optional field specifying the\n     *        timestamp in milliseconds as a Unix timestamp. Fractional values\n     *        are allowed so that timestamps with sub-millisecond accuracy\n     *        can be represented. If not specified, the implementation is\n     *        expected to use it's notion of the current time of the call.\n     * @param {string} [fields.event] - the event name\n     * @param {object} [fields.payload] - an arbitrary structured payload. It is\n     *        implementation-dependent how this will be processed.\n     */\n    log(fields) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof fields !== 'object') {\n                throw new Error('Expected fields to be an object');\n            }\n        }\n        if (!this._imp) {\n            return;\n        }\n        this._imp.log(fields);\n        return this;\n    }\n\n    /**\n     * Logs a event with an optional payload.\n     *\n     * @param  {string} eventName - string associated with the log record\n     * @param  {object} [payload] - arbitrary payload object associated with the\n     *         log record.\n     */\n    logEvent(eventName, payload) {\n        return this.log({\n            event   : eventName,\n            payload : payload,\n        });\n    }\n\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {Number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    finish(finishTime) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length > 1) {\n                throw new Error('Invalid arguments');\n            }\n            if (arguments.length === 1 && typeof finishTime !== 'number') {\n                throw new Error('Unexpected argument type');\n            }\n        }\n\n        if (!this._imp) {\n            return;\n        }\n        this._imp.finish(finishTime);\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Private and non-standard methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Constructs a new Span object, this method should not be called directly;\n     * Tracer.startSpan() or Tracer.join() should be used instead.\n     */\n    constructor(imp) {\n        this._imp = imp;\n    }\n\n    /**\n     * Returns the Span implementation object. The returned object is by its\n     * nature entirely implementation-dependent.\n     */\n    imp() {\n        return this._imp;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/span.js\n **/","'use strict';\n\n/**\n * SpanContext represents Span state that must propagate to descendant Spans\n * and across process boundaries.\n *\n * SpanContext is logically divided into two pieces: the user-level \"Baggage\"\n * (see setBaggageItem and getBaggageItem) that propagates across Span\n * boundaries and any Tracer-implementation-specific fields that are needed to\n * identify or otherwise contextualize the associated Span instance (e.g., a\n * <trace_id, span_id, sampled> tuple).\n */\nexport default class SpanContext {\n\n    /**\n     * Sets a key:value pair on this SpanContext that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    setBaggageItem(key, value) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            this._imp.setBaggageItem(key, value);\n        }\n    }\n\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    getBaggageItem(key) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            return this._imp.getBaggageItem(key);\n        }\n        return undefined;\n    }\n\n    /**\n     * Constructs a new SpanContext object.\n     *\n     * This method should not be called directly; Span.context() should be used\n     * instead.\n     */\n    constructor(imp) {\n        this._imp = imp;\n    }\n\n    /**\n     * Returns the SpanContext implementation object. The returned object is by\n     * its nature entirely implementation-dependent.\n     */\n    imp() {\n        return this._imp;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/span_context.js\n **/","'use strict';\n\nmodule.exports = {\n    /**\n     * The FORMAT_BINARY format represents SpanContexts in an opaque binary\n     * carrier.\n     *\n     * Tracer.inject() will set the buffer field to an Array-like (Array,\n     * ArrayBuffer, or TypedBuffer) object containing the injected binary data.\n     * Any valid Object can be used as long as the buffer field of the object\n     * can be set.\n     *\n     * Tracer.extract() will look for `carrier.buffer`, and that field is\n     * expected to be an Array-like object (Array, ArrayBuffer, or\n     * TypedBuffer).\n     */\n    FORMAT_BINARY : 'binary',\n\n    /**\n     * The FORMAT_TEXT_MAP format represents SpanContexts using a\n     * string->string map (backed by a Javascript Object) as a carrier.\n     *\n     * NOTE: Unlike FORMAT_HTTP_HEADERS, FORMAT_TEXT_MAP places no restrictions\n     * on the characters used in either the keys or the values of the map\n     * entries.\n     *\n     * The FORMAT_TEXT_MAP carrier map may contain unrelated data (e.g.,\n     * arbitrary gRPC metadata); as such, the Tracer implementation should use\n     * a prefix or other convention to distinguish Tracer-specific key:value\n     * pairs.\n     */\n    FORMAT_TEXT_MAP : 'text_map',\n\n    /**\n     * The FORMAT_HTTP_HEADERS format represents SpanContexts using a\n     * character-restricted string->string map (backed by a Javascript Object)\n     * as a carrier.\n     *\n     * Keys and values in the FORMAT_HTTP_HEADERS carrier must be suitable for\n     * use as HTTP headers (without modification or further escaping). That is,\n     * the keys have a greatly restricted character set, casing for the keys\n     * may not be preserved by various intermediaries, and the values should be\n     * URL-escaped.\n     *\n     * The FORMAT_HTTP_HEADERS carrier map may contain unrelated data (e.g.,\n     * arbitrary HTTP headers); as such, the Tracer implementation should use a\n     * prefix or other convention to distinguish Tracer-specific key:value\n     * pairs.\n     */\n    FORMAT_HTTP_HEADERS : 'http_headers',\n\n    /**\n     * A Span may be the \"child of\" a parent Span. In a “child of” reference,\n     * the parent Span depends on the child Span in some capacity.\n     *\n     * See more about reference types at http://opentracing.io/spec/\n     */\n    REFERENCE_CHILD_OF : 'child_of',\n\n    /**\n     * Some parent Spans do not depend in any way on the result of their child\n     * Spans. In these cases, we say merely that the child Span “follows from”\n     * the parent Span in a causal sense.\n     *\n     * See more about reference types at http://opentracing.io/spec/\n     */\n    REFERENCE_FOLLOWS_FROM : 'follows_from',\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants.js\n **/","'use strict';\n\nimport Span from './span';\nimport SpanContext from './span_context';\n\n/**\n * Reference pairs a reference type constant (e.g., REFERENCE_CHILD_OF or\n * REFERENCE_FOLLOWS_FROM) with the SpanContext it points to.\n *\n * See the exported childOf() and followsFrom() functions at the package level.\n */\nexport default class Reference {\n\n    /**\n     * @return {string} The Reference type (e.g., REFERENCE_CHILD_OF or\n     *         REFERENCE_FOLLOWS_FROM).\n     */\n    type() {\n        return this._type;\n    }\n\n    /**\n     * @return {SpanContext} The SpanContext being referred to (e.g., the\n     *         parent in a REFERENCE_CHILD_OF Reference).\n     */\n    referencedContext() {\n        return this._referencedContext;\n    }\n\n    /**\n     * Initialize a new Reference instance.\n     *\n     * @param {string} type - the Reference type constant (e.g.,\n     *        REFERENCE_CHILD_OF or REFERENCE_FOLLOWS_FROM).\n     * @param {SpanContext} referencedContext - the SpanContext being referred\n     *        to. As a convenience, a Span instance may be passed in instead\n     *        (in which case its .context() is used here).\n     */\n    constructor(type, referencedContext) {\n        if (API_CONFORMANCE_CHECKS) {\n            if (!(referencedContext instanceof SpanContext || referencedContext instanceof Span)) {\n                throw new Error('referencedContext must be a Span or SpanContext instance');\n            }\n        }\n        this._type = type;\n        this._referencedContext = (\n                referencedContext instanceof Span ?\n                referencedContext.context() :\n                referencedContext);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/reference.js\n **/","'use strict';\n\n/**\n * Convenience class to use as a binary carrier.\n *\n * Any valid Object with a field named `buffer` may be used as a binary carrier;\n * this class is only one such type of object that can be used.\n */\nexport default class BinaryCarrier {\n    constructor(binaryData) {\n        this.buffer = binaryData;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary_carrier.js\n **/"],"sourceRoot":""}