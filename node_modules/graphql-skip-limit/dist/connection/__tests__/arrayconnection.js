"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _arrayconnection = require("../arrayconnection");

describe(`connectionFromArray()`, () => {
  const letters = [`A`, `B`, `C`, `D`, `E`];
  describe(`basic slicing`, () => {
    it(`returns all elements without filters`, () => {
      const c = (0, _arrayconnection.connectionFromArray)(letters, {});
      return expect(c).toEqual({
        edges: [{
          next: `B`,
          node: `A`,
          previous: undefined
        }, {
          next: `C`,
          node: `B`,
          previous: `A`
        }, {
          next: `D`,
          node: `C`,
          previous: `B`
        }, {
          next: `E`,
          node: `D`,
          previous: `C`
        }, {
          next: undefined,
          node: `E`,
          previous: `D`
        }],
        pageInfo: {
          hasNextPage: false
        }
      });
    });
    it(`respects a smaller first`, () => {
      const c = (0, _arrayconnection.connectionFromArray)(letters, {
        limit: 2
      });
      return expect(c).toEqual({
        edges: [{
          node: `A`,
          next: `B`,
          previous: undefined
        }, {
          node: `B`,
          next: `C`,
          previous: `A`
        }],
        pageInfo: {
          hasNextPage: true
        }
      });
    });
    it(`respects an overly large first`, () => {
      const c = (0, _arrayconnection.connectionFromArray)(letters, {
        limit: 10
      });
      return expect(c).toEqual({
        edges: [{
          next: `B`,
          node: `A`,
          previous: undefined
        }, {
          next: `C`,
          node: `B`,
          previous: `A`
        }, {
          next: `D`,
          node: `C`,
          previous: `B`
        }, {
          next: `E`,
          node: `D`,
          previous: `C`
        }, {
          next: undefined,
          node: `E`,
          previous: `D`
        }],
        pageInfo: {
          hasNextPage: false
        }
      });
    });
  });
  describe(`pagination`, () => {
    it(`respects limit and skip`, () => {
      const c = (0, _arrayconnection.connectionFromArray)(letters, {
        limit: 2,
        skip: 2
      });
      return expect(c).toEqual({
        edges: [{
          next: `D`,
          node: `C`,
          previous: `B`
        }, {
          next: `E`,
          node: `D`,
          previous: `C`
        }],
        pageInfo: {
          hasNextPage: true
        }
      });
    });
    it(`respects limit and skip with large skip`, () => {
      const c = (0, _arrayconnection.connectionFromArray)(letters, {
        limit: 10,
        skip: 2
      });
      return expect(c).toEqual({
        edges: [{
          next: `D`,
          node: `C`,
          previous: `B`
        }, {
          next: `E`,
          node: `D`,
          previous: `C`
        }, {
          next: undefined,
          node: `E`,
          previous: `D`
        }],
        pageInfo: {
          hasNextPage: false
        }
      });
    });
  });
});
describe(`connectionFromPromisedArray()`, () => {
  const letters = Promise.resolve([`A`, `B`, `C`, `D`, `E`]);
  it(`returns all elements without filters`,
  /*#__PURE__*/
  (0, _asyncToGenerator2.default)(function* () {
    const c = yield (0, _arrayconnection.connectionFromPromisedArray)(letters, {});
    return expect(c).toEqual({
      edges: [{
        next: `B`,
        node: `A`,
        previous: undefined
      }, {
        next: `C`,
        node: `B`,
        previous: `A`
      }, {
        next: `D`,
        node: `C`,
        previous: `B`
      }, {
        next: `E`,
        node: `D`,
        previous: `C`
      }, {
        next: undefined,
        node: `E`,
        previous: `D`
      }],
      pageInfo: {
        hasNextPage: false
      }
    });
  }));
  it(`respects a smaller first`,
  /*#__PURE__*/
  (0, _asyncToGenerator2.default)(function* () {
    const c = yield (0, _arrayconnection.connectionFromPromisedArray)(letters, {
      limit: 2
    });
    return expect(c).toEqual({
      edges: [{
        next: `B`,
        node: `A`,
        previous: undefined
      }, {
        next: `C`,
        node: `B`,
        previous: `A`
      }],
      pageInfo: {
        hasNextPage: true
      }
    });
  }));
});