"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const _ = require(`lodash`);

const _require = require(`graphql-skip-limit`),
      connectionArgs = _require.connectionArgs,
      connectionDefinitions = _require.connectionDefinitions;

const _require2 = require(`graphql`),
      GraphQLInputObjectType = _require2.GraphQLInputObjectType;

const _require3 = require(`./infer-graphql-input-fields`),
      inferInputObjectStructureFromNodes = _require3.inferInputObjectStructureFromNodes;

const _require4 = require(`./infer-graphql-input-fields-from-fields`),
      inferInputObjectStructureFromFields = _require4.inferInputObjectStructureFromFields;

const buildSortArg = require(`./create-sort-field`);

const buildConnectionFields = require(`./build-connection-fields`);

const createPageDependency = require(`../redux/actions/add-page-dependency`);

const _require5 = require(`graphql-skip-limit`),
      connectionFromArray = _require5.connectionFromArray;

const _require6 = require(`../db/nodes`),
      runQuery = _require6.runQuery;

function handleQueryResult({
  results,
  queryArgs,
  path
}) {
  if (results && results.length) {
    const connection = connectionFromArray(results, queryArgs);
    connection.totalCount = results.length;

    if (results[0].internal) {
      const connectionType = connection.edges[0].node.internal.type;
      createPageDependency({
        path,
        connection: connectionType
      });
    }

    return connection;
  } else {
    return null;
  }
}

function buildResolver(gqlType) {
  return (
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(function* (object, queryArgs, b, {
        rootValue
      }) {
        let path;

        if (typeof rootValue !== `undefined`) {
          path = rootValue.path;
        }

        const results = yield runQuery({
          queryArgs,
          firstOnly: false,
          gqlType
        });
        return handleQueryResult({
          results,
          queryArgs,
          path
        });
      });

      return function (_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function buildFilterArg(typeName, filterFields) {
  return {
    type: new GraphQLInputObjectType({
      name: _.camelCase(`filter ${typeName}`),
      description: `Filter connection on its fields`,
      fields: () => filterFields
    })
  };
}

function buildFieldConfig(processedType) {
  const nodes = processedType.nodes,
        nodeObjectType = processedType.nodeObjectType;
  const typeName = `${processedType.name}Connection`;

  const _connectionDefinition = connectionDefinitions({
    nodeType: nodeObjectType,
    connectionFields: () => buildConnectionFields(processedType)
  }),
        outputType = _connectionDefinition.connectionType;

  const inferredInputFieldsFromNodes = inferInputObjectStructureFromNodes({
    nodes,
    typeName
  });
  const inferredInputFieldsFromPlugins = inferInputObjectStructureFromFields({
    fields: processedType.fieldsFromPlugins,
    typeName
  });

  const filterFields = _.merge({}, inferredInputFieldsFromNodes.inferredFields, inferredInputFieldsFromPlugins.inferredFields);

  const sortNames = inferredInputFieldsFromNodes.sort.concat(inferredInputFieldsFromPlugins.sort);
  const argsMap = Object.assign({}, connectionArgs, {
    sort: buildSortArg(typeName, sortNames),
    filter: buildFilterArg(processedType.name, filterFields)
  });
  return {
    type: outputType,
    description: `Connection to all ${processedType.name} nodes`,
    args: argsMap,
    resolve: buildResolver(nodeObjectType)
  };
}

function buildFieldConfigMap(processedType) {
  const fieldName = _.camelCase(`all ${processedType.name}`);

  const fieldConfig = buildFieldConfig(processedType);
  return {
    [fieldName]: fieldConfig
  };
}

function fieldConfigReducer(fieldConfigMap, type) {
  return Object.assign(fieldConfigMap, buildFieldConfigMap(type));
}

function buildAll(processedTypes) {
  return processedTypes.filter(type => type.name !== `Site`).reduce(fieldConfigReducer, {});
}

module.exports = {
  buildFieldConfig,
  buildFieldConfigMap,
  buildAll
};
//# sourceMappingURL=build-node-connections.js.map