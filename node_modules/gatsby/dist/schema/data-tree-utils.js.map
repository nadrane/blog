{"version":3,"sources":["../../src/schema/data-tree-utils.js"],"names":["_","require","flatten","typeOf","invariant","createKey","typeConflictReporter","DateType","is32BitInteger","INVALID_VALUE","Symbol","isDefined","v","isEmptyObjectOrArray","obj","isDate","isObject","isEmpty","every","value","key","isScalar","val","Date","extractTypes","Array","isArray","uniqueTypes","uniq","filter","map","item","type","sort","join","arrayTypes","isMixOfDateObjectsAndDateStrings","values","length","includes","allValuesAreDates","shouldInfer","conflictIsValidSpecialCase","entries","entriesOfUniqueType","isConsistentlyScalarOrArray","entry","getExampleScalarFromArray","reduce","nextValue","isNumber","extractFromEntries","selector","uniqBy","addConflict","exampleValue","concatanedItems","extractFromArrays","isPlainObject","extractFieldExamples","filteredItems","flattenEntries","parent","arrayItemExample","nodes","ignoreFields","allKeys","flatMap","keys","example","nextSelector","nodeWithValues","node","buildFieldEnumValues","options","enumValues","getExampleValues","maxDepth","safe","delimiter","Object","forEach","field","typeExampleValues","Map","clearTypeExampleValues","clear","clearConflicts","typeName","cachedValue","get","set","extractFieldNames","module","exports"],"mappings":"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","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst flatten = require(`flat`)\nconst typeOf = require(`type-of`)\nconst invariant = require(`invariant`)\n\nconst createKey = require(`./create-key`)\nconst { typeConflictReporter } = require(`./type-conflict-reporter`)\nconst DateType = require(`./types/type-date`)\nconst is32BitInteger = require(`../utils/is-32-bit-integer`)\n\nimport type { TypeEntry } from \"./type-conflict-reporter\"\n\ntype ExampleValue = Object\n\nconst INVALID_VALUE = Symbol(`INVALID_VALUE`)\nconst isDefined = v => v != null\n\nconst isEmptyObjectOrArray = (obj: any): boolean => {\n  if (obj === INVALID_VALUE) {\n    return true\n  } else if (_.isDate(obj)) {\n    return false\n    // Simple \"is object empty\" check.\n  } else if (_.isObject(obj) && _.isEmpty(obj)) {\n    return true\n  } else if (_.isObject(obj)) {\n    return _.every(obj, (value, key) => {\n      if (!isDefined(value)) {\n        return true\n      } else if (_.isObject(value)) {\n        return isEmptyObjectOrArray(value)\n      } else {\n        return false\n      }\n    })\n  }\n  return false\n}\n\nconst isScalar = val => !_.isObject(val) || val instanceof Date\n\nconst extractTypes = value => {\n  if (Array.isArray(value)) {\n    const uniqueTypes = _.uniq(\n      value.filter(isDefined).map(item => extractTypes(item).type)\n    ).sort()\n    return {\n      type: `array<${uniqueTypes.join(`|`)}>`,\n      arrayTypes: uniqueTypes,\n    }\n  } else {\n    const type = typeOf(value)\n    return {\n      type,\n      arrayTypes: [],\n    }\n  }\n}\n\nconst isMixOfDateObjectsAndDateStrings = (\n  values: any[],\n  uniqueTypes: string[]\n): boolean => {\n  if (\n    uniqueTypes.length === 2 &&\n    uniqueTypes.includes(`string`) &&\n    uniqueTypes.includes(`date`)\n  ) {\n    const allValuesAreDates = values.every(value => {\n      if (typeOf(value) === `date`) return true\n\n      // use infer checker to determine if string is a date\n      return DateType.shouldInfer(value)\n    })\n\n    return allValuesAreDates\n  }\n\n  return false\n}\n\nconst conflictIsValidSpecialCase = (\n  entries: TypeEntry[],\n  entriesOfUniqueType: TypeEntry[]\n): boolean => {\n  const isConsistentlyScalarOrArray = entriesOfUniqueType.every(\n    entry =>\n      entry.arrayTypes.length > 0 ===\n      entriesOfUniqueType[0].arrayTypes.length > 0\n  )\n  if (isConsistentlyScalarOrArray) {\n    // Get values and run them through special cases, to see if there actually\n    // is a conflict. This is done so late in process, because those checks\n    // would be expensive to do earlier during extraction, so we do them\n    // only when we have potential conflict.\n\n    let uniqueTypes: string[]\n    let values: any[]\n    const isArray = entriesOfUniqueType[0].arrayTypes.length > 0\n\n    if (isArray) {\n      values = _.flatten(entries.map(entry => entry.value))\n      uniqueTypes = _.uniq(\n        _.flatten(entriesOfUniqueType.map(entry => entry.arrayTypes))\n      )\n    } else {\n      values = entries.map(entry => entry.value)\n      uniqueTypes = entriesOfUniqueType.map(entry => entry.type)\n    }\n\n    return isMixOfDateObjectsAndDateStrings(values, uniqueTypes)\n  }\n  return false\n}\n\nconst getExampleScalarFromArray = values =>\n  _.reduce(\n    values,\n    (value, nextValue) => {\n      // Prefer floats over ints as they're more specific.\n      if (nextValue && _.isNumber(nextValue) && !is32BitInteger(nextValue)) {\n        return nextValue\n      } else if (value === null) {\n        return nextValue\n      } else {\n        return value\n      }\n    },\n    null\n  )\n\nconst extractFromEntries = (\n  entries: TypeEntry[],\n  selector: string,\n  key: string\n): ?mixed => {\n  const entriesOfUniqueType = _.uniqBy(entries, entry => entry.type)\n\n  if (entriesOfUniqueType.length == 0) {\n    // skip if no defined types\n    return null\n  } else if (\n    entriesOfUniqueType.length > 1 ||\n    entriesOfUniqueType[0].arrayTypes.length > 1\n  ) {\n    // there is multiple types or array of multiple types\n    // that aren't handled by any special case\n    if (!conflictIsValidSpecialCase(entries, entriesOfUniqueType)) {\n      if (selector) {\n        typeConflictReporter.addConflict(selector, entriesOfUniqueType)\n      }\n      return INVALID_VALUE\n    }\n  }\n\n  // Now we have entries of single type, we can merge them\n  const values = entries.map(entry => entry.value)\n\n  const exampleValue = entriesOfUniqueType[0].value\n\n  if (isScalar(exampleValue)) {\n    return getExampleScalarFromArray(values)\n  } else if (_.isObject(exampleValue)) {\n    if (Array.isArray(exampleValue)) {\n      const concatanedItems = _.flatten(values)\n      // Linked node arrays don't get reduced further as we\n      // want to preserve all the linked node types.\n      if (key.includes(`___NODE`)) {\n        return concatanedItems\n      }\n\n      return extractFromArrays(concatanedItems, entries, selector)\n    } else if (_.isPlainObject(exampleValue)) {\n      return extractFieldExamples(values, selector)\n    }\n  }\n  // unsuported object\n  return INVALID_VALUE\n}\n\nconst extractFromArrays = (values, entries: TypeEntry[], selector: string) => {\n  const filteredItems = values.filter(isDefined)\n  if (filteredItems.length === 0) {\n    return null\n  }\n  if (isScalar(filteredItems[0])) {\n    return [getExampleScalarFromArray(filteredItems)]\n  }\n\n  const flattenEntries: TypeEntry[] = _.flatten(\n    entries.map(entry => {\n      invariant(\n        Array.isArray(entry.value),\n        `this is validated in the previous call`\n      )\n\n      return entry.value.map(value => {\n        return {\n          value,\n          parent: entry.parent,\n          ...extractTypes(value),\n        }\n      })\n    })\n  )\n\n  const arrayItemExample = extractFromEntries(\n    flattenEntries,\n    `${selector}[]`,\n    ``\n  )\n  if (!isDefined(arrayItemExample) || arrayItemExample === INVALID_VALUE) {\n    return INVALID_VALUE\n  }\n\n  return [arrayItemExample]\n}\n\n/**\n * Takes an array of source nodes and returns a pristine\n * example that can be used to infer types.\n *\n * Arrays are flattened to either: `null` for empty or sparse arrays or a\n * an array of a sigle merged example. e.g:\n *\n *  - ['red'], ['blue', 'yellow'] -> ['red']\n *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]\n *\n * @param {*Nodes} args\n */\nconst extractFieldExamples = (\n  nodes: any[],\n  selector: string,\n  ignoreFields?: string[] = []\n): ExampleValue => {\n  // get list of keys in all nodes\n  const allKeys = _(nodes)\n    .flatMap(_.keys)\n    .uniq()\n\n  const example = {}\n  for (let key of allKeys) {\n    if (ignoreFields.includes(key)) continue\n    const nextSelector = selector ? `${selector}.${key}` : key\n\n    const nodeWithValues = nodes.filter(node => {\n      if (!node) return false\n\n      const value = node[key]\n      if (_.isObject(value)) {\n        return !isEmptyObjectOrArray(value)\n      } else {\n        return isDefined(value)\n      }\n    })\n\n    // we want to keep track of nodes as we need it to get origin of data\n    const entries = nodeWithValues.map(node => {\n      const value = node[key]\n      return {\n        value,\n        parent: node,\n        ...extractTypes(value),\n      }\n    })\n\n    const value = extractFromEntries(entries, nextSelector, key)\n    if (!isDefined(value)) continue\n\n    example[key] = value\n  }\n\n  return example\n}\n\nconst buildFieldEnumValues = (options: ExampleValueOptions) => {\n  const enumValues = {}\n  const values = flatten(getExampleValues(options), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n  Object.keys(values).forEach(field => {\n    if (values[field] == null) return\n    enumValues[createKey(field)] = { field }\n  })\n\n  return enumValues\n}\n\nlet typeExampleValues: Map<string, Object> = new Map()\n\nconst clearTypeExampleValues = () => {\n  typeExampleValues.clear()\n  typeConflictReporter.clearConflicts()\n}\n\ntype ExampleValueOptions = {\n  nodes: Object[],\n  typeName?: string,\n  ignoreFields?: string[],\n}\n\nconst getExampleValues = ({\n  nodes,\n  typeName,\n  ignoreFields,\n}: ExampleValueOptions): ExampleValue => {\n  const cachedValue = typeName && typeExampleValues.get(typeName)\n\n  // if type is defined and is in example value cache return it\n  if (cachedValue) return cachedValue\n\n  // if nodes were passed extract field example from it\n  if (nodes && nodes.length > 0) {\n    const exampleValue = extractFieldExamples(\n      nodes,\n      typeName || ``,\n      ignoreFields\n    )\n    // if type is set - cache results\n    if (typeName) typeExampleValues.set(typeName, exampleValue)\n    return exampleValue\n  }\n\n  return {}\n}\n\n// extract a list of field names\n// nested objects get flattened to \"outer___inner\" which will be converted back to\n// \"outer.inner\" by run-sift\nconst extractFieldNames = (nodes: Object[]) => {\n  const values = flatten(\n    getExampleValues({\n      nodes,\n      typeName: _.get(nodes[0], `internal.type`),\n    }),\n    {\n      maxDepth: 3,\n      safe: true, // don't flatten arrays.\n      delimiter: `___`,\n    }\n  )\n\n  return Object.keys(values)\n}\n\nmodule.exports = {\n  INVALID_VALUE,\n  buildFieldEnumValues,\n  extractFieldNames,\n  isEmptyObjectOrArray,\n  clearTypeExampleValues,\n  getExampleValues,\n}\n"],"file":"data-tree-utils.js"}