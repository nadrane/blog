"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const _ = require(`lodash`);

const _require = require(`graphql`),
      GraphQLObjectType = _require.GraphQLObjectType,
      GraphQLNonNull = _require.GraphQLNonNull,
      GraphQLID = _require.GraphQLID,
      GraphQLList = _require.GraphQLList;

const tracer = require(`opentracing`).globalTracer();

const apiRunner = require(`../utils/api-runner-node`);

const _require2 = require(`./infer-graphql-type`),
      inferObjectStructureFromNodes = _require2.inferObjectStructureFromNodes;

const _require3 = require(`./infer-graphql-input-fields-from-fields`),
      inferInputObjectStructureFromFields = _require3.inferInputObjectStructureFromFields;

const _require4 = require(`./infer-graphql-input-fields`),
      inferInputObjectStructureFromNodes = _require4.inferInputObjectStructureFromNodes;

const _require5 = require(`./node-interface`),
      nodeInterface = _require5.nodeInterface;

const _require6 = require(`../db/nodes`),
      getNodes = _require6.getNodes,
      getNode = _require6.getNode;

const pageDependencyResolver = require(`./page-dependency-resolver`);

const _require7 = require(`./types/type-file`),
      setFileNodeRootType = _require7.setFileNodeRootType;

const _require8 = require(`./data-tree-utils`),
      clearTypeExampleValues = _require8.clearTypeExampleValues;

const _require9 = require(`../db/nodes`),
      runQuery = _require9.runQuery;

const defaultNodeFields = {
  id: {
    type: new GraphQLNonNull(GraphQLID),
    description: `The id of this node.`
  },
  parent: {
    type: nodeInterface,
    description: `The parent of this node.`,
    resolve: pageDependencyResolver(node => getNode(node.parent))
  },
  children: {
    type: new GraphQLList(nodeInterface),
    description: `The children of this node.`,
    resolve: pageDependencyResolver(node => node.children.map(getNode))
  }
};

function groupChildNodesByType(nodes) {
  return _(nodes).flatMap(node => node.children.map(getNode)).groupBy(node => node.internal ? _.camelCase(node.internal.type) : undefined).value();
}

function nodeIsOfType(typeName) {
  return node => _.camelCase(node.internal.type) === typeName;
}

function makeChildrenResolver(typeName) {
  return node => node.children.map(getNode).filter(nodeIsOfType(typeName));
}

function buildChildrenFieldConfigMap(typeName, nodeObjectType) {
  const fieldName = _.camelCase(`children ${typeName}`);

  const fieldConfig = {
    type: new GraphQLList(nodeObjectType),
    description: `The children of this node of type ${typeName}`,
    resolve: pageDependencyResolver(makeChildrenResolver(typeName))
  };
  return {
    [fieldName]: fieldConfig
  };
}

function makeChildResolver(typeName) {
  return node => node.children.map(getNode).find(nodeIsOfType(typeName));
}

function buildChildFieldConfigMap(typeName, nodeObjectType) {
  const fieldName = _.camelCase(`child ${typeName}`);

  const fieldConfig = {
    type: nodeObjectType,
    description: `The child of this node of type ${typeName}`,
    resolve: pageDependencyResolver(makeChildResolver(typeName))
  };
  return {
    [fieldName]: fieldConfig
  };
}

function inferChildFieldConfigMap(type, typeName, processedTypes) {
  const nodeObjectType = processedTypes[typeName].nodeObjectType; // Does this child type have one child per parent or multiple?

  const maxChildCount = _.maxBy(_.values(_.groupBy(type, c => c.parent)), g => g.length).length;

  if (maxChildCount > 1) {
    return buildChildrenFieldConfigMap(typeName, nodeObjectType);
  } else {
    return buildChildFieldConfigMap(typeName, nodeObjectType);
  }
}

function inferChildFields(nodes, processedTypes) {
  // Create children fields for each type of children e.g.
  // "childrenMarkdownRemark".
  const childNodesByType = groupChildNodesByType(nodes);

  const configMaps = _.map(childNodesByType, (type, typeName) => inferChildFieldConfigMap(type, typeName, processedTypes));

  return _.assign.apply(null, [{}, ...configMaps]);
}

function inferFields({
  nodes,
  pluginFields,
  processedTypes
}) {
  // Create children fields for each type of children e.g.
  // "childrenMarkdownRemark".
  const childFields = inferChildFields(nodes, processedTypes);
  const inferredFields = inferObjectStructureFromNodes({
    nodes,
    types: _.values(processedTypes),
    ignoreFields: Object.keys(pluginFields)
  });
  return Object.assign({}, defaultNodeFields, childFields, inferredFields, pluginFields);
}

function buildResolver(gqlType) {
  return (
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(function* (a, queryArgs) {
        if (!_.isObject(queryArgs)) {
          queryArgs = {};
        }

        const results = yield runQuery({
          queryArgs: {
            filter: Object.assign({}, queryArgs)
          },
          firstOnly: true,
          gqlType
        });

        if (results.length > 0) {
          return results[0];
        } else {
          return null;
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function buildNodeObjectType({
  typeName,
  nodes,
  pluginFields,
  processedTypes
}) {
  return new GraphQLObjectType({
    name: typeName,
    description: `Node of type ${typeName}`,
    interfaces: [nodeInterface],
    fields: () => inferFields({
      nodes,
      pluginFields,
      processedTypes
    }),
    isTypeOf: value => value.internal.type === typeName
  });
}

function buildProcessedType(_x3, _x4, _x5, _x6) {
  return _buildProcessedType.apply(this, arguments);
}

function _buildProcessedType() {
  _buildProcessedType = (0, _asyncToGenerator2.default)(function* (nodes, typeName, processedTypes, span) {
    const intermediateType = {};
    intermediateType.name = typeName;
    intermediateType.nodes = nodes;
    const pluginFields = yield apiRunner(`setFieldsOnGraphQLNodeType`, {
      type: intermediateType,
      traceId: `initial-setFieldsOnGraphQLNodeType`,
      parentSpan: span
    });

    const mergedFieldsFromPlugins = _.merge(...pluginFields);

    const pluginInputFields = inferInputObjectStructureFromFields({
      fields: mergedFieldsFromPlugins
    });
    const gqlType = buildNodeObjectType({
      typeName,
      nodes,
      pluginFields: mergedFieldsFromPlugins,
      processedTypes
    });
    const nodeInputFields = inferInputObjectStructureFromNodes({
      nodes,
      typeName
    });

    const filterFields = _.merge({}, nodeInputFields.inferredFields, pluginInputFields.inferredFields);

    return Object.assign({}, intermediateType, {
      fieldsFromPlugins: mergedFieldsFromPlugins,
      nodeObjectType: gqlType,
      node: {
        name: typeName,
        type: gqlType,
        args: filterFields,
        resolve: pageDependencyResolver(buildResolver(gqlType))
      }
    });
  });
  return _buildProcessedType.apply(this, arguments);
}

function groupNodesByType(nodes) {
  return _.groupBy(nodes.filter(node => node.internal && !node.internal.ignoreType), node => node.internal.type);
}

module.exports =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* ({
    parentSpan
  }) {
    const spanArgs = parentSpan ? {
      childOf: parentSpan
    } : {};
    const span = tracer.startSpan(`build schema`, spanArgs);
    const types = groupNodesByType(getNodes());
    const processedTypes = {};
    clearTypeExampleValues(); // Reset stored File type to not point to outdated type definition

    setFileNodeRootType(null); // Create node types and node fields for nodes that have a resolve function.

    yield Promise.all(_.map(types,
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _asyncToGenerator2.default)(function* (nodes, typeName) {
        const fieldName = _.camelCase(typeName);

        const processedType = yield buildProcessedType(nodes, typeName, processedTypes, span);
        processedTypes[fieldName] = processedType; // Special case to construct linked file type used by type inferring

        if (typeName === `File`) {
          setFileNodeRootType(processedType.nodeObjectType);
        }

        return;
      });

      return function (_x8, _x9) {
        return _ref3.apply(this, arguments);
      };
    }()));
    span.finish();
    return processedTypes;
  });

  return function (_x7) {
    return _ref2.apply(this, arguments);
  };
}();
//# sourceMappingURL=build-node-types.js.map