{"version":3,"sources":["../../src/utils/api-node-docs.js"],"names":["exports","resolvableExtensions","createPages","createPagesStatefully","sourceNodes","onCreateNode","onCreatePage","setFieldsOnGraphQLNodeType","preprocessSource","generateSideEffects","onCreateBabelConfig","onCreateWebpackConfig","onPreInit","onPreBootstrap","onPostBootstrap","onPreBuild","onPostBuild","onPreExtractQueries","onCreateDevServer"],"mappings":";;AAAA;;;;;AAKAA,OAAO,CAACC,oBAAR,GAA+B,IAA/B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDAD,OAAO,CAACE,WAAR,GAAsB,IAAtB;AAEA;;;;;;;;;;;;;;;AAcAF,OAAO,CAACG,qBAAR,GAAgC,IAAhC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCAH,OAAO,CAACI,WAAR,GAAsB,IAAtB;AAEA;;;;;;;;;;;;;;AAaAJ,OAAO,CAACK,YAAR,GAAuB,IAAvB;AAEA;;;;;;;;;AAQAL,OAAO,CAACM,YAAR,GAAuB,IAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDAN,OAAO,CAACO,0BAAR,GAAqC,IAArC;AAEA;;;;;AAIAP,OAAO,CAACQ,gBAAR,GAA2B,IAA3B;AAEA;;;;;;AAKAR,OAAO,CAACS,mBAAR,GAA8B,IAA9B;AAEA;;;;;;AAKAT,OAAO,CAACU,mBAAR,GAA8B,IAA9B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BAV,OAAO,CAACW,qBAAR,GAAgC,IAAhC;AAEA;;;;AAGAX,OAAO,CAACY,SAAR,GAAoB,IAApB;AAEA;;;;AAGAZ,OAAO,CAACa,cAAR,GAAyB,IAAzB;AAEA;;;;AAGAb,OAAO,CAACc,eAAR,GAA0B,IAA1B;AAEA;;;;AAGAd,OAAO,CAACe,UAAR,GAAqB,IAArB;AAEA;;;;;AAIAf,OAAO,CAACgB,WAAR,GAAsB,IAAtB;AAEA;;;;;;;AAMAhB,OAAO,CAACiB,mBAAR,GAA8B,IAA9B;AAEA;;;;;;;;;;;;;AAYAjB,OAAO,CAACkB,iBAAR,GAA4B,IAA5B","sourcesContent":["/**\n * Lets plugins implementing support for other compile-to-js add to the list\n * of \"resolvable\" file extensions. Gatsby supports `.js` and `.jsx` by default.\n * @returns {Array} array of extensions\n */\nexports.resolvableExtensions = true\n\n/**\n * Tell plugins to add pages. This extension point is called only after the initial\n * sourcing and transformation of nodes plus creation of the GraphQL schema are\n * complete so you can query your data in order to create pages.\n *\n * See also [the documentation for the action `createPage`](/docs/actions/#createPage).\n * @example\n * exports.createPages = ({ graphql, actions }) => {\n *   const { createPage } = actions\n *   return new Promise((resolve, reject) => {\n *     const blogPostTemplate = path.resolve(`src/templates/blog-post.js`)\n *     // Query for markdown nodes to use in creating pages.\n *     resolve(\n *       graphql(\n *         `\n *       {\n *         allMarkdownRemark(limit: 1000) {\n *           edges {\n *             node {\n *               fields {\n *                 slug\n *               }\n *             }\n *           }\n *         }\n *       }\n *     `\n *       ).then(result => {\n *         if (result.errors) {\n *           reject(result.errors)\n *         }\n *\n *         // Create blog post pages.\n *         result.data.allMarkdownRemark.edges.forEach(edge => {\n *             createPage({\n *               path: `${edge.node.fields.slug}`, // required\n *               component: blogPostTemplate,\n *               context: {\n *                 // Add optional context data. Data can be used as\n *                 // arguments to the page GraphQL query.\n *                 //\n *                 // The page \"path\" is always available as a GraphQL\n *                 // argument.\n *               },\n *             })\n *         })\n *\n *         return\n *       })\n *     )\n *   })\n * }\n */\n\nexports.createPages = true\n\n/**\n * Like `createPages` but for plugins who want to manage creating and removing\n * pages themselves in response to changes in data *not* managed by Gatsby.\n * Plugins implementing `createPages` will get called regularly to recompute\n * page information as Gatsby's data changes but those implementing\n * `createPagesStatefully` will not.\n *\n * An example of a plugin that uses this extension point is the plugin\n * [gatsby-plugin-page-creator](https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-plugin-page-creator)\n * which monitors the `src/pages` directory for the adding and removal of JS\n * pages. As its source of truth, files in the pages directory, is not known by\n * Gatsby, it needs to keep its own state about its world to know when to\n * add and remove pages.\n */\nexports.createPagesStatefully = true\n\n/**\n * Extension point to tell plugins to source nodes.\n *\n * See also the documentation for [`createNode`](/docs/actions/#createNode).\n * @example\n * exports.sourceNodes = ({ actions, createNodeId, createContentDigest }) => {\n *   const { createNode } = actions\n *\n *   // Data can come from anywhere, but for now create it manually\n *   const myData = {\n *     key: 123,\n *     foo: `The foo field of my node`,\n *     bar: `Baz`\n *   }\n *\n *   const nodeContent = JSON.stringify(myData)\n *\n *   const nodeMeta = {\n *     id: createNodeId(`my-data-${myData.key}`),\n *     parent: null,\n *     children: [],\n *     internal: {\n *       type: `MyNodeType`,\n *       mediaType: `text/html`,\n *       content: nodeContent,\n *       contentDigest: createContentDigest(myData)\n *     }\n *   }\n *\n *   const node = Object.assign({}, myData, nodeMeta)\n *   createNode(node)\n * }\n */\nexports.sourceNodes = true\n\n/**\n * Called when a new node is created. Plugins wishing to extend or\n * transform nodes created by other plugins should implement this API.\n *\n * See also the documentation for [`createNode`](/docs/actions/#createNode)\n * and [`createNodeField`](/docs/actions/#createNodeField)\n * @example\n * exports.onCreateNode = ({ node, actions }) => {\n *   const { createNode, createNodeField } = actions\n *   // Transform the new node here and create a new node or\n *   // create a new node field.\n * }\n */\nexports.onCreateNode = true\n\n/**\n * Called when a new page is created. This extension API is useful\n * for programmatically manipulating pages created by other plugins e.g.\n * if you want paths without trailing slashes.\n *\n * See the guide [Creating and Modifying Pages](/docs/creating-and-modifying-pages/)\n * for more on this API.\n */\nexports.onCreatePage = true\n\n/**\n * Called during the creation of the GraphQL schema. Allows plugins\n * to add new fields to the types created from data nodes. It will be called\n * separately for each type.\n *\n * This function should return an object in the shape of\n * [GraphQLFieldConfigMap](https://graphql.org/graphql-js/type/#graphqlobjecttype)\n * which will be appended to fields inferred by Gatsby from data nodes.\n *\n * *Note:* Import GraphQL types from `gatsby/graphql` and don't add the `graphql`\n * package to your project/plugin dependencies to avoid `Schema must\n * contain unique named types but contains multiple types named` errors.\n * `gatsby/graphql` exports all builtin GraphQL types as well as the `graphQLJSON`\n * type.\n *\n * Many transformer plugins use this to add fields that take arguments.\n *\n * * [`gatsby-transformer-remark`](/packages/gatsby-transformer-remark/)\n * adds an \"excerpt\" field where the user when writing their query can specify\n * how many characters to prune the markdown source to.\n * * [`gatsby-transformer-sharp`](/packages/gatsby-transformer-sharp/) exposes\n * many image transformation options as GraphQL fields.\n *\n * @param {object} $0\n * @param {object} $0.type Object containing `name` and `nodes`\n * @example\n * import { GraphQLString } from \"gatsby/graphql\"\n *\n * exports.setFieldsOnGraphQLNodeType = ({ type }) => {\n *   if (type.name === `File`) {\n *     return {\n *       newField: {\n *         type: GraphQLString,\n *         args: {\n *           myArgument: {\n *             type: GraphQLString,\n *          }\n *         }\n *         resolve: (source, fieldArgs) => {\n *           return `Id of this node is ${source.id}.\n *                   Field was called with argument: ${fieldArgs.myArgument}`\n *         }\n *       }\n *     }\n *   }\n *\n *   // by default return empty object\n *   return {}\n * }\n */\nexports.setFieldsOnGraphQLNodeType = true\n\n/**\n * Ask compile-to-js plugins to process source to JavaScript so the query\n * runner can extract out GraphQL queries for running.\n */\nexports.preprocessSource = true\n\n/**\n * Tell plugins with expensive \"side effects\" from queries to start running\n * those now. This is a soon-to-be-replaced API only currently in use by\n * `gatsby-plugin-sharp`.\n */\nexports.generateSideEffects = true\n\n/**\n * Let plugins extend/mutate the site's Babel configuration.\n * This API will change before 2.0 as it needs still to be converted to use\n * Redux actions.\n */\nexports.onCreateBabelConfig = true\n\n/**\n * Let plugins extend/mutate the site's webpack configuration.\n *\n * See also the documentation for [`setWebpackConfig`](/docs/actions/#setWebpackConfig).\n *\n * @param {object} $0\n * @param {string} $0.stage The current build stage. One of 'develop', 'develop-html',\n * 'build-javascript', or 'build-html'\n * @param {function} $0.getConfig Returns the current webpack config\n * @param {object} $0.rules A set of preconfigured webpack config rules\n * @param {object} $0.loaders A set of preconfigured webpack config loaders\n * @param {object} $0.plugins A set of preconfigured webpack config plugins\n * @param {object} $0.actions\n * @example\n * exports.onCreateWebpackConfig = ({\n *  stage, getConfig, rules, loaders, actions\n * }) => {\n *   actions.setWebpackConfig({\n *     module: {\n *       rules: [\n *         {\n *           test: 'my-css',\n *           use: [loaders.style(), loaders.css()]\n *         },\n *       ],\n *     },\n *   });\n * }\n */\nexports.onCreateWebpackConfig = true\n\n/**\n * The first API called during Gatsby execution, runs as soon as plugins are loaded, before cache initialization and bootstrap preparation.\n */\nexports.onPreInit = true\n\n/**\n * Called once Gatsby has initialized itself and is ready to bootstrap your site.\n */\nexports.onPreBootstrap = true\n\n/**\n * Called at the end of the bootstrap process after all other extension APIs have been called.\n */\nexports.onPostBootstrap = true\n\n/**\n * The first extension point called during the build process. Called after the bootstrap has completed but before the build steps start.\n */\nexports.onPreBuild = true\n\n/**\n * The last extension point called after all other parts of the build process\n * are complete.\n */\nexports.onPostBuild = true\n\n/**\n * Run before GraphQL queries/fragments are extracted from JavaScript files. Useful for plugins\n * to add more JavaScript files with queries/fragments e.g. from node_modules.\n *\n * See gatsby-transformer-remark and gatsby-source-contentful for examples.\n */\nexports.onPreExtractQueries = true\n\n/**\n * Run when gatsby develop server is started, its useful to add proxy and middleware\n * to the dev server app\n * @param {object} $0\n * @param {Express} $0.app The [Express app](https://expressjs.com/en/4x/api.html#app) used to run the dev server\n * @example\n * exports.onCreateDevServer = ({ app }) => {\n *   app.get('/hello', function (req, res) {\n *     res.send('hello world')\n *   })\n * }\n */\nexports.onCreateDevServer = true\n"],"file":"api-node-docs.js"}