{"version":3,"sources":["../../src/utils/api-browser-docs.js"],"names":["exports","onClientEntry","onInitialClientRender","onPreRouteUpdate","onRouteUpdateDelayed","onRouteUpdate","shouldUpdateScroll","registerServiceWorker","replaceComponentRenderer","wrapPageElement","wrapRootElement","onPrefetchPathname","onPostPrefetchPathname","disableCorePrefetching","replaceHydrateFunction","onServiceWorkerInstalled","onServiceWorkerUpdateFound","onServiceWorkerActive","onServiceWorkerRedundant"],"mappings":";;AAAA;;;;;;;;AAQAA,OAAO,CAACC,aAAR,GAAwB,IAAxB;AAEA;;;;;;;;AAOAD,OAAO,CAACE,qBAAR,GAAgC,IAAhC;AAEA;;;;;;;;;;;AAUAF,OAAO,CAACG,gBAAR,GAA2B,IAA3B;AAEA;;;;;;;;;;;AAUAH,OAAO,CAACI,oBAAR,GAA+B,IAA/B;AAEA;;;;;;;;;;;;;;;;;;;AAkBAJ,OAAO,CAACK,aAAR,GAAwB,IAAxB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BAL,OAAO,CAACM,kBAAR,GAA6B,IAA7B;AAEA;;;;;;AAKAN,OAAO,CAACO,qBAAR,GAAgC,IAAhC;AAEA;;;;;;;;AAOAP,OAAO,CAACQ,wBAAR,GAAmC,IAAnC;AAEA;;;;;;;;;;;;;;;;;;;;;AAoBAR,OAAO,CAACS,eAAR,GAA0B,IAA1B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAwBAT,OAAO,CAACU,eAAR,GAA0B,IAA1B;AAEA;;;;;;;;AAOAV,OAAO,CAACW,kBAAR,GAA6B,IAA7B;AAEA;;;;;;;;AAOAX,OAAO,CAACY,sBAAR,GAAiC,IAAjC;AAEA;;;;;;;AAMAZ,OAAO,CAACa,sBAAR,GAAiC,IAAjC;AAEA;;;;;;;;;;;;;AAYAb,OAAO,CAACc,sBAAR,GAAiC,IAAjC;AAEA;;;;;;AAKAd,OAAO,CAACe,wBAAR,GAAmC,IAAnC;AAEA;;;;;;AAKAf,OAAO,CAACgB,0BAAR,GAAqC,IAArC;AAEA;;;;;;AAKAhB,OAAO,CAACiB,qBAAR,GAAgC,IAAhC;AAEA;;;;;;AAKAjB,OAAO,CAACkB,wBAAR,GAAmC,IAAnC","sourcesContent":["/**\n * Called when the Gatsby browser runtime first starts.\n * @example\n * exports.onClientEntry = () => {\n *   console.log(\"We've started!\")\n *   callAnalyticsAPI()\n * }\n */\nexports.onClientEntry = true\n\n/**\n * Called when the initial (but not subsequent) render of Gatsby App is done on the client.\n * @example\n * exports.onInitialClientRender = () => {\n *   console.log(\"ReactDOM.render has executed\")\n * }\n */\nexports.onInitialClientRender = true\n\n/**\n * Called when changing location is started.\n * @param {object} $0\n * @param {object} $0.location A location object\n * @param {object} $0.action The \"action\" that caused the route change\n * @example\n * exports.onPreRouteUpdate = ({ location }) => {\n *   console.log(\"Gatsby started to change location\", location.pathname)\n * }\n */\nexports.onPreRouteUpdate = true\n\n/**\n * Called when changing location is longer than 1 second.\n * @param {object} $0\n * @param {object} $0.location A location object\n * @param {object} $0.action The \"action\" that caused the route change\n * @example\n * exports.onRouteUpdateDelayed = () => {\n *   console.log(\"We can show loading indicator now\")\n * }\n */\nexports.onRouteUpdateDelayed = true\n\n/**\n * Called when the user changes routes\n * @param {object} $0\n * @param {object} $0.location A location object\n * @param {object} $0.action The \"action\" that caused the route change\n * @example\n * exports.onRouteUpdate = ({ location }) => {\n *   console.log('new pathname', location.pathname)\n *\n *   // Track pageview with google analytics\n *   window.ga(\n *     `set`,\n *     `page`,\n *     location.pathname + location.search + location.hash,\n *   )\n *   window.ga(`send`, `pageview`)\n * }\n */\nexports.onRouteUpdate = true\n\n/**\n * Allow a plugin to decide if the scroll position should update or\n * not on a route change.\n * @param {object} $0\n * @param {object} $0.prevRouterProps The previous state of the router before the route change.\n * @param {object} $0.routerProps The current state of the router.\n * @param {string} $0.pathname The new pathname (for backwards compatibility with v1).\n * @param {function} $0.getSavedScrollPosition Takes a location and returns the\n * coordinates of the last scroll position for that location, or `null`. Gatsby\n * saves scroll positions for each route in `SessionStorage`, so they are\n * available after page reload.\n * @returns {(boolean|string|Array)} Should return either an [x, y] Array of\n * coordinates to scroll to, a string of the `id` or `name` of an element to\n * scroll to, `false` to not update the scroll position, or `true` for the\n * default behavior.\n * @example\n * exports.shouldUpdateScroll = ({\n *   routerProps: { location },\n *   getSavedScrollPosition\n * }) => {\n *   const currentPosition = getSavedScrollPosition(location)\n *   const queriedPosition = getSavedScrollPosition({ pathname: `/random` })\n *\n *   window.scrollTo(...(currentPosition || [0, 0]))\n *\n *   return false\n * }\n */\nexports.shouldUpdateScroll = true\n\n/**\n * Allow a plugin to register a Service Worker. Should be a function that returns true.\n * @example\n * exports.registerServiceWorker = () => true\n */\nexports.registerServiceWorker = true\n\n/**\n * Allow a plugin to replace the page component renderer. This api runner can be used to\n * implement page transitions. See https://github.com/gatsbyjs/gatsby/tree/master/examples/using-page-transitions for an example of this.\n * @param {object} $0\n * @param {object} $0.props The props of the page.\n * @param {object} $0.loader The gatsby loader.\n */\nexports.replaceComponentRenderer = true\n\n/**\n * Allow a plugin to wrap the page element.\n *\n * This is useful for setting wrapper component around pages that won't get\n * unmounted on page change. For setting Provider components use [wrapRootElement](#wrapRootElement).\n *\n * _Note:_ [There is equivalent hook in SSR API](/docs/ssr-apis/#wrapPageElement)\n * @param {object} $0\n * @param {object} $0.element The \"Page\" React Element built by Gatsby.\n * @param {object} $0.props Props object used by page.\n * @example\n * import React from \"react\"\n * import Layout from \"./src/components/Layout\"\n *\n * export const wrapPageElement = ({ element, props }) => {\n *   // props provide same data to Layout as Page element will get\n *   // including location, data, etc - you don't need to pass it\n *   return <Layout {...props}>{element}</Layout>\n * }\n */\nexports.wrapPageElement = true\n\n/**\n * Allow a plugin to wrap the root element.\n *\n * This is useful to setup any Providers component that will wrap your application.\n * For setting persistent UI elements around pages use [wrapPageElement](#wrapPageElement).\n *\n * _Note:_ [There is equivalent hook in SSR API](/docs/ssr-apis/#wrapRootElement)\n * @param {object} $0\n * @param {object} $0.element The \"Root\" React Element built by Gatsby.\n * @example\n * import React from \"react\"\n * import { Provider } from \"react-redux\"\n *\n * import createStore from \"./src/state/createStore\"\n * const store = createStore()\n *\n * export const wrapRootElement = ({ element }) => {\n *   return (\n *     <Provider store={store}>\n *       {element}\n *     </Provider>\n *   )\n * }\n */\nexports.wrapRootElement = true\n\n/**\n * Called when prefetching for a pathname is triggered. Allows\n * for plugins with custom prefetching logic.\n * @param {object} $0\n * @param {string} $0.pathname The pathname whose resources should now be prefetched\n * @param {function} $0.getResourcesForPathname Function for fetching resources related to pathname\n */\nexports.onPrefetchPathname = true\n\n/**\n * Called when prefetching for a pathname is successful. Allows\n * for plugins with custom prefetching logic.\n * @param {object} $0\n * @param {string} $0.pathname The pathname whose resources have now been prefetched\n * @param {function} $0.getResourceURLsForPathname Function for fetching URLs for resources related to the pathname\n */\nexports.onPostPrefetchPathname = true\n\n/**\n * Plugins can take over prefetching logic. If they do, they should call this\n * to disable the now duplicate core prefetching logic.\n * @example\n * exports.disableCorePrefetching = () => true\n */\nexports.disableCorePrefetching = true\n\n/**\n * Allow a plugin to replace the ReactDOM.render function call by a custom renderer.\n * This method takes no param and should return a function with same signature as ReactDOM.render()\n * Note it's very important to call the callback after rendering, otherwise Gatsby will not be able to call `onInitialClientRender`\n * @example\n * exports.replaceHydrateFunction = () => {\n *   return (element, container, callback) => {\n *     console.log(\"rendering!\");\n *     ReactDOM.render(element, container, callback);\n *   };\n * };\n */\nexports.replaceHydrateFunction = true\n\n/**\n * Inform plugins when a service worker has been installed.\n * @param {object} $0\n * @param {object} $0.serviceWorker The service worker instance.\n */\nexports.onServiceWorkerInstalled = true\n\n/**\n * Inform plugins of when a service worker has an update available.\n * @param {object} $0\n * @param {object} $0.serviceWorker The service worker instance.\n */\nexports.onServiceWorkerUpdateFound = true\n\n/**\n * Inform plugins when a service worker has become active.\n * @param {object} $0\n * @param {object} $0.serviceWorker The service worker instance.\n */\nexports.onServiceWorkerActive = true\n\n/**\n * Inform plugins when a service worker is redundant.\n * @param {object} $0\n * @param {object} $0.serviceWorker The service worker instance.\n */\nexports.onServiceWorkerRedundant = true\n"],"file":"api-browser-docs.js"}