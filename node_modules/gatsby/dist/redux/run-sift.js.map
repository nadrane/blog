{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["sift","require","_","prepareRegex","Promise","trackInlineObjectsInRootNode","getNode","getNodesByType","resolvedNodesCache","Map","enhancedNodeCache","enhancedNodePromiseCache","enhancedNodeCacheId","node","args","internal","contentDigest","JSON","stringify","nodeid","id","digest","nodesCache","loadNodes","type","nodes","process","env","NODE_ENV","has","get","set","siftifyArgs","object","newObject","each","v","k","isPlainObject","Minimatch","mm","makeRe","extractFieldsToSift","prekey","key","preobj","obj","val","forEach","parseFilter","filter","siftArgs","fieldsToSift","includes","push","isEqId","firstOnly","Object","keys","length","awaitSiftField","fields","field","resolve","fieldName","undefined","resolveRecursive","siftFieldsObj","gqFields","all","map","then","innerSift","innerGqConfig","isObject","isFunction","getFields","isArray","ofType","item","resolvedFields","myNode","resolveNodes","typeName","gqlFields","nodesCacheKey","nodesLength","cacheKey","enhancedNodeGenerationPromise","resolvedNode","resolvedNodes","handleFirst","index","isEmpty","indexOf","$and","handleMany","sort","result","convertedFields","replace","orderBy","order","module","exports","queryArgs","gqlType","clonedArgs","parse","name"],"mappings":"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","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst Promise = require(`bluebird`)\nconst { trackInlineObjectsInRootNode } = require(`../db/node-tracking`)\nconst { getNode, getNodesByType } = require(`../db/nodes`)\n\nconst resolvedNodesCache = new Map()\nconst enhancedNodeCache = new Map()\nconst enhancedNodePromiseCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? JSON.stringify({\n        nodeid: node.id,\n        digest: node.internal.contentDigest,\n        ...args,\n      })\n    : null\n\nconst nodesCache = new Map()\n\nfunction loadNodes(type) {\n  let nodes\n  // this caching can be removed if we move to loki\n  if (process.env.NODE_ENV === `production` && nodesCache.has(type)) {\n    nodes = nodesCache.get(type)\n  } else {\n    nodes = getNodesByType(type)\n    nodesCache.set(type, nodes)\n  }\n  return nodes\n}\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nfunction siftifyArgs(object) {\n  const newObject = {}\n  _.each(object, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        k = `$elemMatch`\n      }\n      newObject[k] = siftifyArgs(v)\n    } else {\n      // Compile regex first.\n      if (k === `regex`) {\n        newObject[`$regex`] = prepareRegex(v)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        newObject[`$regex`] = mm.makeRe()\n      } else {\n        newObject[`$${k}`] = v\n      }\n    }\n  })\n  return newObject\n}\n\n// Build an object that excludes the innermost leafs,\n// this avoids including { eq: x } when resolving fields.\nfunction extractFieldsToSift(prekey, key, preobj, obj, val) {\n  if (_.isPlainObject(val)) {\n    _.forEach((val: any), (v, k) => {\n      if (k === `elemMatch`) {\n        // elemMatch is operator for arrays and not field we want to prepare\n        // so we need to skip it\n        extractFieldsToSift(prekey, key, preobj, obj, v)\n        return\n      }\n      preobj[prekey] = obj\n      extractFieldsToSift(key, k, obj, {}, v)\n    })\n  } else {\n    preobj[prekey] = true\n  }\n}\n\n/**\n * Parse filter and returns an object with two fields:\n * - siftArgs: the filter in a format that sift understands\n * - fieldsToSift: filter with operate leaves (e.g { eq: 3 })\n *   removed. Used later to resolve all filter fields\n */\nfunction parseFilter(filter) {\n  const siftArgs = []\n  const fieldsToSift = {}\n  if (filter) {\n    _.each(filter, (v, k) => {\n      // Ignore connection and sorting args.\n      if (_.includes([`skip`, `limit`, `sort`], k)) return\n\n      siftArgs.push(\n        siftifyArgs({\n          [k]: v,\n        })\n      )\n      extractFieldsToSift(``, k, {}, fieldsToSift, v)\n    })\n  }\n  return { siftArgs, fieldsToSift }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Resolve nodes\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(firstOnly, fieldsToSift, siftArgs) {\n  return (\n    firstOnly &&\n    Object.keys(fieldsToSift).length === 1 &&\n    Object.keys(fieldsToSift)[0] === `id` &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    return field.resolve(\n      node,\n      {},\n      {},\n      {\n        fieldName: k,\n      }\n    )\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n// Resolves every field used in the node.\nfunction resolveRecursive(node, siftFieldsObj, gqFields) {\n  return Promise.all(\n    _.keys(siftFieldsObj).map(k =>\n      Promise.resolve(awaitSiftField(gqFields, node, k))\n        .then(v => {\n          const innerSift = siftFieldsObj[k]\n          const innerGqConfig = gqFields[k]\n          if (\n            _.isObject(innerSift) &&\n            v != null &&\n            innerGqConfig &&\n            innerGqConfig.type\n          ) {\n            if (_.isFunction(innerGqConfig.type.getFields)) {\n              // this is single object\n              return resolveRecursive(\n                v,\n                innerSift,\n                innerGqConfig.type.getFields()\n              )\n            } else if (\n              _.isArray(v) &&\n              innerGqConfig.type.ofType &&\n              _.isFunction(innerGqConfig.type.ofType.getFields)\n            ) {\n              // this is array\n              return Promise.all(\n                v.map(item =>\n                  resolveRecursive(\n                    item,\n                    innerSift,\n                    innerGqConfig.type.ofType.getFields()\n                  )\n                )\n              )\n            }\n          }\n\n          return v\n        })\n        .then(v => [k, v])\n    )\n  ).then(resolvedFields => {\n    const myNode = {\n      ...node,\n    }\n    resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n    return myNode\n  })\n}\n\nfunction resolveNodes(nodes, typeName, firstOnly, fieldsToSift, gqlFields) {\n  const nodesCacheKey = JSON.stringify({\n    // typeName + count being the same is a pretty good\n    // indication that the nodes are the same.\n    typeName,\n    firstOnly,\n    nodesLength: nodes.length,\n    ...fieldsToSift,\n  })\n  if (\n    process.env.NODE_ENV === `production` &&\n    resolvedNodesCache.has(nodesCacheKey)\n  ) {\n    return Promise.resolve(resolvedNodesCache.get(nodesCacheKey))\n  } else {\n    return Promise.all(\n      nodes.map(node => {\n        const cacheKey = enhancedNodeCacheId({\n          node,\n          args: fieldsToSift,\n        })\n        if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n          return Promise.resolve(enhancedNodeCache.get(cacheKey))\n        } else if (cacheKey && enhancedNodePromiseCache.has(cacheKey)) {\n          return enhancedNodePromiseCache.get(cacheKey)\n        }\n\n        const enhancedNodeGenerationPromise = new Promise(resolve => {\n          resolveRecursive(node, fieldsToSift, gqlFields).then(resolvedNode => {\n            trackInlineObjectsInRootNode(resolvedNode)\n            if (cacheKey) {\n              enhancedNodeCache.set(cacheKey, resolvedNode)\n            }\n            resolve(resolvedNode)\n          })\n        })\n        enhancedNodePromiseCache.set(cacheKey, enhancedNodeGenerationPromise)\n        return enhancedNodeGenerationPromise\n      })\n    ).then(resolvedNodes => {\n      resolvedNodesCache.set(nodesCacheKey, resolvedNodes)\n      return resolvedNodes\n    })\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction handleFirst(siftArgs, nodes) {\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : sift.indexOf(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes, sort) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : sift(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (!result || !result.length) return null\n\n  // Sort results.\n  if (sort) {\n    // create functions that return the item to compare on\n    // uses _.get so nested fields can be retrieved\n    const convertedFields = sort.fields\n      .map(field => field.replace(/___/g, `.`))\n      .map(field => v => _.get(v, field))\n\n    result = _.orderBy(result, convertedFields, sort.order)\n  }\n  return result\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over (Optional\n *   will load itself if not present)\n * @param type gqlType. Created in build-node-types\n * @param firstOnly true if you want to return only the first result\n *   found. This will return a collection of size 1. Not a single\n *   element\n * @returns Collection of results. Collection will be limited to size\n *   if `firstOnly` is true\n */\nmodule.exports = (args: Object) => {\n  const { queryArgs, gqlType, firstOnly = false } = args\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const clonedArgs = JSON.parse(JSON.stringify(queryArgs))\n\n  // If nodes weren't provided, then load them from the DB\n  const nodes = args.nodes || loadNodes(gqlType.name)\n\n  const { siftArgs, fieldsToSift } = parseFilter(clonedArgs.filter)\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(firstOnly, fieldsToSift, siftArgs)) {\n    return resolveRecursive(\n      getNode(siftArgs[0].id[`$eq`]),\n      fieldsToSift,\n      gqlType.getFields()\n    ).then(node => (node ? [node] : []))\n  }\n\n  return resolveNodes(\n    nodes,\n    gqlType.name,\n    firstOnly,\n    fieldsToSift,\n    gqlType.getFields()\n  ).then(resolvedNodes => {\n    if (firstOnly) {\n      return handleFirst(siftArgs, resolvedNodes)\n    } else {\n      return handleMany(siftArgs, resolvedNodes, clonedArgs.sort)\n    }\n  })\n}\n"],"file":"run-sift.js"}