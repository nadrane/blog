{"version":3,"sources":["../../../src/internal-plugins/query-runner/file-parser.js"],"names":["fs","require","crypto","_","getGraphQLTag","report","apiRunnerNode","generateQueryName","def","hash","file","name","value","camelCase","kind","parseToAst","filePath","fileStr","ast","transpiled","filename","contents","length","item","tmp","error","undefined","warnForGlobalTag","warn","findGraphQLTags","text","Promise","resolve","reject","then","queries","documentLocations","WeakMap","extractStaticQuery","taggedTemplateExpressPath","gqlAst","isGlobal","definitions","forEach","set","node","start","loc","map","d","isStaticQuery","push","JSXElement","path","openingElement","traverse","JSXAttribute","jsxPath","TaggedTemplateExpression","templatePath","Identifier","identifierPath","varName","found","VariableDeclarator","varPath","id","init","type","ExportNamedDeclaration","state","innerPath","uniqueQueries","uniqBy","q","get","catch","cache","FileParser","parseFile","readFile","err","indexOf","createHash","update","digest","astDefinitions","parseFiles","files","documents","Map","all","doc"],"mappings":"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","sourcesContent":["// @flow\nconst fs = require(`fs-extra`)\nconst crypto = require(`crypto`)\nconst _ = require(`lodash`)\n\n// Traverse is a es6 module...\nimport traverse from \"babel-traverse\"\nconst getGraphQLTag = require(`babel-plugin-remove-graphql-queries`)\n  .getGraphQLTag\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\nimport { babelParseToAst } from \"../../utils/babel-parse-to-ast\"\n\nconst apiRunnerNode = require(`../../utils/api-runner-node`)\n\n/**\n * Add autogenerated query name if it wasn't defined by user.\n */\nconst generateQueryName = ({ def, hash, file }) => {\n  if (!def.name || !def.name.value) {\n    def.name = {\n      value: `${_.camelCase(file)}${hash}`,\n      kind: `Name`,\n    }\n  }\n  return def\n}\n\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  const transpiled = await apiRunnerNode(`preprocessSource`, {\n    filename: filePath,\n    contents: fileStr,\n  })\n  if (transpiled && transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babelParseToAst(item, filePath)\n        ast = tmp\n        break\n      } catch (error) {\n        report.error(error)\n        continue\n      }\n    }\n    if (ast === undefined) {\n      report.error(`Failed to parse preprocessed file ${filePath}`)\n    }\n  } else {\n    try {\n      ast = babelParseToAst(fileStr, filePath)\n    } catch (error) {\n      report.error(\n        `There was a problem parsing \"${filePath}\"; any GraphQL ` +\n          `fragments or queries in this file were not processed. \\n` +\n          `This may indicate a syntax error in the code, or it may be a file type ` +\n          `that Gatsby does not know how to parse.`\n      )\n    }\n  }\n\n  return ast\n}\n\nconst warnForGlobalTag = file =>\n  report.warn(\n    `Using the global \\`graphql\\` tag is deprecated, and will not be supported in v3.\\n` +\n      `Import it instead like:  import { graphql } from 'gatsby' in file:\\n` +\n      file\n  )\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  return new Promise((resolve, reject) => {\n    parseToAst(file, text)\n      .then(ast => {\n        let queries = []\n        if (!ast) {\n          resolve(queries)\n          return\n        }\n\n        /**\n         * A map of graphql documents to unique locations.\n         *\n         * A graphql document's unique location is made of:\n         *\n         *  - the location of the graphql template literal that contains the document, and\n         *  - the document's location within the graphql template literal\n         *\n         * This is used to prevent returning duplicated documents.\n         */\n        const documentLocations = new WeakMap()\n\n        const extractStaticQuery = taggedTemplateExpressPath => {\n          const { ast: gqlAst, text, hash, isGlobal } = getGraphQLTag(\n            taggedTemplateExpressPath\n          )\n          if (!gqlAst) return\n\n          if (isGlobal) warnForGlobalTag(file)\n\n          gqlAst.definitions.forEach(def => {\n            documentLocations.set(\n              def,\n              `${taggedTemplateExpressPath.node.start}-${def.loc.start}`\n            )\n            generateQueryName({\n              def,\n              hash,\n              file,\n            })\n          })\n\n          const definitions = [...gqlAst.definitions].map(d => {\n            d.isStaticQuery = true\n            d.text = text\n            d.hash = hash\n            return d\n          })\n\n          queries.push(...definitions)\n        }\n\n        // Look for queries in <StaticQuery /> elements.\n        traverse(ast, {\n          JSXElement(path) {\n            if (path.node.openingElement.name.name !== `StaticQuery`) {\n              return\n            }\n\n            // astexplorer.com link I (@kyleamathews) used when prototyping this algorithm\n            // https://astexplorer.net/#/gist/ab5d71c0f08f287fbb840bf1dd8b85ff/2f188345d8e5a4152fe7c96f0d52dbcc6e9da466\n            path.traverse({\n              JSXAttribute(jsxPath) {\n                if (jsxPath.node.name.name !== `query`) {\n                  return\n                }\n                jsxPath.traverse({\n                  // Assume the query is inline in the component and extract that.\n                  TaggedTemplateExpression(templatePath) {\n                    extractStaticQuery(templatePath)\n                  },\n                  // Also see if it's a variable that's passed in as a prop\n                  // and if it is, go find it.\n                  Identifier(identifierPath) {\n                    if (identifierPath.node.name !== `graphql`) {\n                      const varName = identifierPath.node.name\n                      let found = false\n                      traverse(ast, {\n                        VariableDeclarator(varPath) {\n                          if (\n                            varPath.node.id.name === varName &&\n                            varPath.node.init.type ===\n                              `TaggedTemplateExpression`\n                          ) {\n                            varPath.traverse({\n                              TaggedTemplateExpression(templatePath) {\n                                found = true\n                                extractStaticQuery(templatePath)\n                              },\n                            })\n                          }\n                        },\n                      })\n                      if (!found) {\n                        report.warn(\n                          `\\nWe were unable to find the declaration of variable \"${varName}\", which you passed as the \"query\" prop into the <StaticQuery> declaration in \"${file}\".\n\nPerhaps the variable name has a typo?\n\nAlso note that we are currently unable to use queries defined in files other than the file where the <StaticQuery> is defined. If you're attempting to import the query, please move it into \"${file}\". If being able to import queries from another file is an important capability for you, we invite your help fixing it.\\n`\n                        )\n                      }\n                    }\n                  },\n                })\n              },\n            })\n            return\n          },\n        })\n\n        // Look for exported page queries\n        traverse(ast, {\n          ExportNamedDeclaration(path, state) {\n            path.traverse({\n              TaggedTemplateExpression(innerPath) {\n                const { ast: gqlAst, isGlobal, hash } = getGraphQLTag(innerPath)\n                if (!gqlAst) return\n\n                if (isGlobal) warnForGlobalTag(file)\n\n                gqlAst.definitions.forEach(def => {\n                  documentLocations.set(\n                    def,\n                    `${innerPath.node.start}-${def.loc.start}`\n                  )\n                  generateQueryName({\n                    def,\n                    hash,\n                    file,\n                  })\n                })\n\n                queries.push(...gqlAst.definitions)\n              },\n            })\n          },\n        })\n\n        // Remove duplicate queries\n        const uniqueQueries = _.uniqBy(queries, q => documentLocations.get(q))\n\n        resolve(uniqueQueries)\n      })\n      .catch(reject)\n  })\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    let text\n    try {\n      text = await fs.readFile(file, `utf8`)\n    } catch (err) {\n      report.error(`There was a problem reading the file: ${file}`, err)\n      return null\n    }\n\n    if (text.indexOf(`graphql`) === -1) return null\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    try {\n      let astDefinitions =\n        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n      return astDefinitions.length\n        ? {\n            kind: `Document`,\n            definitions: astDefinitions,\n          }\n        : null\n    } catch (err) {\n      report.error(\n        `There was a problem parsing the GraphQL query in file: ${file}`,\n        err\n      )\n      return null\n    }\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n\n    return Promise.all(\n      files.map(file =>\n        this.parseFile(file).then(doc => {\n          if (!doc) return\n          documents.set(file, doc)\n        })\n      )\n    ).then(() => documents)\n  }\n}\n"],"file":"file-parser.js"}