{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-queue.js"],"names":["Queue","require","queryRunner","store","emitter","websocketManager","processing","Set","waiting","Map","queueOptions","concurrent","merge","oldTask","newTask","cb","priority","job","activePaths","Array","from","values","id","includes","filter","has","set","process","env","gatsby_executing_command","queue","plObj","callback","state","getState","add","components","component","catch","e","console","log","then","result","delete","push","get","error","on","pause","resume","emit","module","exports"],"mappings":"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","sourcesContent":["const Queue = require(`better-queue`)\n\nconst queryRunner = require(`./query-runner`)\nconst { store, emitter } = require(`../../redux`)\nconst websocketManager = require(`../../utils/websocket-manager`)\n\nconst processing = new Set()\nconst waiting = new Map()\n\nconst queueOptions = {\n  concurrent: 4,\n  // Merge duplicate jobs.\n  merge: (oldTask, newTask, cb) => {\n    cb(null, newTask)\n  },\n  priority: (job, cb) => {\n    const activePaths = Array.from(websocketManager.activePaths.values())\n    if (job.id && activePaths.includes(job.id)) {\n      cb(null, 10)\n    } else {\n      cb(null, 1)\n    }\n  },\n  // Filter out new query jobs if that query is already running.  When the\n  // query finshes, it checks the waiting map and pushes another job to\n  // make sure all the user changes are captured.\n  filter: (job, cb) => {\n    if (processing.has(job.id)) {\n      waiting.set(job.id, job)\n      cb(`already running`)\n    } else {\n      cb(null, job)\n    }\n  },\n}\n\n// During builds we don't need all the filtering, etc. so we\n// remove them to speed up queries\nif (process.env.gatsby_executing_command === `build`) {\n  delete queueOptions.filter\n  delete queueOptions.priority\n  delete queueOptions.merge\n}\n\nconst queue = new Queue((plObj, callback) => {\n  const state = store.getState()\n  processing.add(plObj.id)\n\n  return queryRunner(plObj, state.components[plObj.component])\n    .catch(e => console.log(`Error running queryRunner`, e))\n    .then(\n      result => {\n        processing.delete(plObj.id)\n        if (waiting.has(plObj.id)) {\n          queue.push(waiting.get(plObj.id))\n          waiting.delete(plObj.id)\n        }\n        return callback(null, result)\n      },\n      error => callback(error)\n    )\n}, queueOptions)\n\n// Pause running queries when new nodes are added (processing starts).\nemitter.on(`CREATE_NODE`, () => {\n  queue.pause()\n})\n\n// Resume running queries as soon as the api queue is empty.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, () => {\n  queue.resume()\n})\n\nqueue.on(`drain`, () => {\n  emitter.emit(`QUERY_QUEUE_DRAINED`)\n})\n\nqueue.on(`task_queued`, () => {\n  emitter.emit(`QUERY_ENQUEUED`)\n})\n\nmodule.exports = queue\n"],"file":"query-queue.js"}