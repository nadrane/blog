{"componentChunkName":"component---src-templates-category-js","path":"/categories/JavaScript/","webpackCompilationHash":"be161c4017b1db4ff602","result":{"data":{"allMarkdownRemark":{"nodes":[{"html":"<p>I posted my article <a href=\"https://nickdrane.com/build-your-own-regex/\">Build Your Own Regex Engine</a> on Reddit the other day, and one of the commenters claimed that the implementation should be trivial to break. Since I had already tested my program against a customized suite of tests, the remark got me thinking about how I could further increase my confidence in the correctness of my program. One extremely low cost however effective strategy for identifying faults in software is known as fuzzing.</p>\n<!-- more -->\n<h2>What is Fuzzing?</h2>\n<p>Fuzzing is a automated testing technique where a program is provided a series of invalid or randomly generated inputs. If we were testing an HTTP API, we might send randomized combinations of query parameters and ensure that our server always returns a 2xx status code. Since JavaScript comes with a regular expression engine, my fuzzer asserts that given the same random input, both engine's return the same output.</p>\n<h2>Specifying the Grammar</h2>\n<p>The first step is to specify the grammar that our regex engine supports.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> lowercase <span class=\"token operator\">=</span> <span class=\"token string\">\"abcdefghijklmnopqrstuvwxyz\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> uppercase <span class=\"token operator\">=</span> lowercase<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">letter</span> <span class=\"token operator\">=></span> letter<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> special <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"?\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"*\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regexGrammar <span class=\"token operator\">=</span> special<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>lowercase<span class=\"token punctuation\">,</span> uppercase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>You might notice we skipped the <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> characters. More on these in a little bit.</p>\n<h2>Generated Valid Regular Expressions</h2>\n<p>We want to write a function <code class=\"language-text\">generateRegex</code> that will select <code class=\"language-text\">n</code> random characters from the <code class=\"language-text\">regexGrammar</code> and concatenate them together into a string. This string will be used to create a test regex.</p>\n<p>Here are three possible returns values of <code class=\"language-text\">generateRegex</code>:</p>\n<ol>\n<li><code class=\"language-text\">.AnrQ?QNLQX.syBsOcJlbJZd</code></li>\n<li><code class=\"language-text\">.LkuZ?Ynj</code></li>\n<li><code class=\"language-text\">.UN?eiyddhXvyNj</code></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> regexString <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>chooseOne<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> regexString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Pick one element randomly from the grammar and return it</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">chooseOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> regexGrammar<span class=\"token punctuation\">[</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> regexGrammar<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Removing Invalid Regex Strings</h2>\n<p>My regex engine only deals with a very small subset of available regex syntax, and furthermore, it does not contain any error handling. What happens if <code class=\"language-text\">generateRegex</code> returns the pattern <code class=\"language-text\">**</code> or <code class=\"language-text\">^*</code>? My regex engine was never designed to handle these inputs, though they are possible outputs of <code class=\"language-text\">generateRegex</code>. We need to make a choice about how to handle these expressions. Since the primary goal of my regex engine is accessibility and simplicity of implementation, I'm not about to begin supporting these edge cases. That means my fuzzer should not generate them either.</p>\n<p>One solution to determine if a given regex string is valid is to specify my regex engine's allowable grammar in <a href=\"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form\">BNF</a>. BNF is a formal notation for specifying the syntax of a language. Given this BNF notation, I could ask another program if the randomly generated regex string can be created using my BNF specification. This sounds like a little more work than I want, however, since the invalid cases can simply be manually enumerated and filtered.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">validRegex</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">regexString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">// None of the following sequences are properly</span>\n    <span class=\"token comment\">// defined by my regex engine</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"**\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"??\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"*?\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"?*\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"^?\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"^*\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>regexString<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"*\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>regexString<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"?\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> regexString <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>chooseOne<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// If the generated string is valid, return it</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">validRegex</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> regexString<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Otherwise generate a new string and return that</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">generateRegexString</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>One more modification to <code class=\"language-text\">generateRegex</code> is necessary to support <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code>, and then we are basically done.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token comment\">// We need to ensure that '^' and '$' only go at the beginning</span>\n  <span class=\"token comment\">// and the end of the string, respectively.</span>\n  <span class=\"token comment\">// Give each a 10% probability of appearing in a string</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span> regexString <span class=\"token operator\">=</span> <span class=\"token string\">\"^\"</span> <span class=\"token operator\">+</span> regexString<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span> regexString <span class=\"token operator\">=</span> regexString <span class=\"token operator\">+</span> <span class=\"token string\">\"$\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Comparing Regex Implementations</h2>\n<p>All that is required now is to repeatedly invoke <code class=\"language-text\">generateRegex</code> a fixed number of times and then compare the output of the native JS implementation with the output of my implementation.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// The corpus is the string of text we are matching the pattern against.</span>\n<span class=\"token comment\">// I used a segment of Gulliver's Travels from Project Gutenberg.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fuzzer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">totalTests<span class=\"token punctuation\">,</span> corpus</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> maxRegexLength <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// max will actually be 50 - 1</span>\n  <span class=\"token keyword\">let</span> testsRun <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>testsRun <span class=\"token operator\">&lt;</span> totalTests<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> regexLength <span class=\"token operator\">=</span> <span class=\"token function\">getRandomInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> maxRegexLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> regexString <span class=\"token operator\">=</span> <span class=\"token function\">generateRegexString</span><span class=\"token punctuation\">(</span>regexLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> testRegex <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>testRegex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>corpus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">myRegexEngine</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">,</span> corpus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>testRegex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    testsRun<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Thank you Mozzila :)</span>\n<span class=\"token comment\">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getRandomInt</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">min<span class=\"token punctuation\">,</span> max</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  min <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">ceil</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  max <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>max <span class=\"token operator\">-</span> min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> min<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Results</h2>\n<p>I ran my fuzzer for a couple million randomly generated cases and ended up learning two things about my regex engine.</p>\n<ol>\n<li>My implementation fails extraordinarily with longer texts. I knew recursion would be a problem for any practical regex implementation (at least without <a href=\"https://en.wikipedia.org/wiki/Tail_call\">tail calls</a>) and would cause stack overflows, but I didn't expect it to fail with texts that were only a couple thousand words. I think this is because I make liberal use of backtracking algorithms in <code class=\"language-text\">matchQuestion</code> and <code class=\"language-text\">matchStar</code>. Since I was forced to test with a relatively short input text, it makes sense to use multiple text inputs to increase the probability of discovering an error.</li>\n<li>My implementation treats the <code class=\"language-text\">.</code> character differently than the native implementation. In the RegExp implementation, <code class=\"language-text\">.</code> will not match various line terminators (<code class=\"language-text\">\\n</code>, <code class=\"language-text\">\\r</code>, <code class=\"language-text\">\\u2028</code> or <code class=\"language-text\">\\u2029</code>). My implementation does.</li>\n</ol>\n<h2>Conclusion</h2>\n<p>The biggest takeaway is that fuzzing is an simple and inexpensive way to enumerate enormous sets of inputs and identify bugs in your software. This fuzzer took less than an hour to write.</p>\n<p>But remember, this fuzzer's blessing of a couple million input combinations <strong>does not</strong> verify the correctness of my program. Not even close. A fuzzer is a tool to identify potential errors. Unless you enumerate all possible inputs (completely impossible in this case where they are infinite), you are not guaranteed your program is error free.</p>","excerpt":"<p>I posted my article <a href=\"https://nickdrane.com/build-your-own-regex/\">Build Your Own Regex Engine</a> on Reddit the other day, and one of the commenters claimed that the implementation should be trivial to break. Since I had already tested my program against a customized suite of tests, the remark got me thinking about how I could further increase my confidence in the correctness of my program. One extremely low cost however effective strategy for identifying faults in software is known as fuzzing.</p>\n","frontmatter":{"title":"Regex And Automated Test Fuzzing","date":"2017-12-06T00:00:00.000Z","url":"regex-and-automated-test-fuzzing"}},{"html":"<p>The other day at work, one of my colleagues was frated that he was unable to encode nested objects in a query string and still maintain a readable URL. I went home that night and coded up a simple solution to this problem, and I thought I'd share it here today. This <a href=\"https://github.com/nadrane/querystring-encoder\">Github repo</a> contains specs and the solution code.</p>\n<!-- more -->\n<h2>Motivation</h2>\n<p>Today, in the Node.js ecosystem, numerous modules exist to encode query strings, but they generally have one of two flaws:</p>\n<ol>\n<li>They do not permit the encoding of nested objects.</li>\n<li>They can encode nested objects, but they delimit nesting using unsafe URL characters, yielding an operation and a result that look like this <sup><a href=\"#footnote1\">1</a></sup>:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> b<span class=\"token punctuation\">:</span> <span class=\"token string\">'c'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">>>></span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">a%5Bb%5D=c</span><span class=\"token template-punctuation string\">`</span></span></code></pre></div>\n<h2>The Problem in Detail</h2>\n<p>Node.js provides a <a href=\"https://nodejs.org/api/querystring.html\"><code class=\"language-text\">querystring</code></a> module to encode objects to query strings. The only problem is that conforms to an official specification that doesn't allow nested objects. Unfortunately, this specification does not allow for enough flexibility when creating a RESTful API.</p>\n<p>For example, suppose the client wants to filter a collection of cars by make and model. The route might look like this:</p>\n<p><code class=\"language-text\">/api/cars?make=honda&amp;model=civic</code></p>\n<p>This URI makes it reasonably clear that we want to filter cars by their make and model.</p>\n<p>What if we wanted to do something more complicated. What if we wanted to filter cars and order them by price?</p>\n<p><code class=\"language-text\">/api/cars?order=price&amp;make=honda&amp;model=civic</code></p>\n<p>It's no longer clear which query parameters describe the ordering and which describe the filter. Ideally, we want the url to look like this:</p>\n<p><code class=\"language-text\">/api/cars?order=price&amp;filter.make=honda&amp;filter.model=civic</code></p>\n<p>If we were to represent the query string of the above URI as a JavaScript object, it would probably look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    order<span class=\"token punctuation\">:</span> <span class=\"token string\">\"price\"</span><span class=\"token punctuation\">,</span>\n    filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        make<span class=\"token punctuation\">:</span> <span class=\"token string\">\"honda\"</span><span class=\"token punctuation\">,</span>\n        model<span class=\"token punctuation\">:</span> <span class=\"token string\">\"civic\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And then we quickly run into our problem. We need to encode the object above into</p>\n<p><code class=\"language-text\">order=price&amp;filter.make=honda&amp;filter.model=civic</code></p>\n<p>but Node.js's <a href=\"https://nodejs.org/api/querystring.html\"><code class=\"language-text\">querystring</code></a> can't encode nested objects.</p>\n<h2>Existing Modules Supporting Nested Querystrings</h2>\n<p>By default, the <a href=\"https://www.npmjs.com/package/qs\">qs</a> module creates ugly urls when it encodes nested query strings. If we encode our object above, we get</p>\n<p><code class=\"language-text\">order=price&amp;filter[make]=honda&amp;filter[model]=civic</code></p>\n<p>The <code class=\"language-text\">[</code> and <code class=\"language-text\">]</code> characters are both considered unsafe in a URL and are required to be escaped. The URL becomes unreadable after this percent encoding operation.</p>\n<p><code class=\"language-text\">order=price&amp;filter%5Bmake%5D=honda&amp;filter%5Bmodel%5D=civic</code></p>\n<p>Fortunately, the <code class=\"language-text\">.</code> is not considered unsafe and does not need to be escaped, making it the perfect character to express object nesting.</p>\n<h2>The Solution</h2>\n<p>The solution is broken down into two parts. The first is <em>encoding</em> a nested object into a query string. The second part is <em>decoding</em> a query string back into a nested object.</p>\n<h2>Encoding Nested Objects <sup><a href=\"#footnote2\">2</a></sup></h2>\n<p>Let's write some code to encode</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    make<span class=\"token punctuation\">:</span> <span class=\"token string\">\"honda\"</span><span class=\"token punctuation\">;</span>\n    model<span class=\"token punctuation\">:</span> <span class=\"token string\">\"civic\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>into the query string <code class=\"language-text\">filter.make=honda&amp;filter.model=civic</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> escape <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"querystring\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> queryString <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> pairs <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Handle the nested, recursive case, where the value to encode is an object itself</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">+</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Handle base case, where the value to encode is simply a string.</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> pairs<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice that we use the <a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_escape_str\">escape</a> function provided in Node.js core to percent encode specific characters.</p>\n<h2>Encoding Arrays as Values</h2>\n<p>If we want to add support to encode an object with array values, like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"nick\"</span><span class=\"token punctuation\">,</span>\n    hobbies<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"cooking\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"coding\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>then we only need to add another base case to our function</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> queryString <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> pairs <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Handle a second base case where the value to encode is an array</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> val\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">subVal</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> subVal<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">+</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> pairs<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>An encoding function is not very useful unless you can decode the encoded string back to it's original form.</p>\n<h2>Decoding Nested Objects</h2>\n<p>We want to write a function that will decode <code class=\"language-text\">filter.make=honda&amp;filter.model=civic</code> back into a nested object</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    make<span class=\"token punctuation\">:</span> <span class=\"token string\">\"honda\"</span><span class=\"token punctuation\">;</span>\n    model<span class=\"token punctuation\">:</span> <span class=\"token string\">\"civic\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code to do this is fairly straightforward if we use a <a href=\"https://lodash.com/docs\">Lodash</a> utility called <a href=\"https://lodash.com/docs/4.17.5#set\">set</a> that allows us to set an arbitrarily nested key in an object.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.set\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">queryString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> queryStringPieces <span class=\"token operator\">=</span> queryString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> decodedQueryString <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> piece <span class=\"token keyword\">of</span> queryStringPieces<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> piece<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    value <span class=\"token operator\">=</span> value <span class=\"token operator\">||</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// If a value is not defined, it should be decoded as an empty string</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> decodedQueryString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Decoding Arrays as Values</h2>\n<p>If we want to add support to decode arrays like we did above, then we need to do a little additional work. Fortunately, two additional <a href=\"https://lodash.com/docs\">Lodash</a> utilities, <a href=\"https://lodash.com/docs/4.17.5#has\">has</a> and <a href=\"https://lodash.com/docs/4.17.5#get\">get</a>, allow us to check for the existence of a nested key and to get the value associated with a nested key, respectively, greatly simplifying our problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.set\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> has <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.has\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">get</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.get\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">queryString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> queryStringPieces <span class=\"token operator\">=</span> queryString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> decodedQueryString <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> piece <span class=\"token keyword\">of</span> queryStringPieces<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> piece<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    value <span class=\"token operator\">=</span> value <span class=\"token operator\">||</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> currentValueForKey <span class=\"token operator\">=</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>currentValueForKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>currentValueForKey<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        currentValueForKey<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> decodedQueryString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>And that's it! The whole thing, encoding and decoding, only takes ~40 lines of code. Perhaps next time you encounter something that feels a little too fundamental to code yourself, you won't hesitate to write some code if you can't find a sufficient open source package.</p>\n<p><em>If you've run into challenges with your web applications, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: This example is straight from the <a href=\"https://www.npmjs.com/package/qs\">qs</a> documentation. Incidentally, qs provides an option to encode using a url safe character, which would result in readable urls, but this is not the default.</p>\n<p><a name=\"footnote2\">2</a>: It's worth noting that you might not want to use this code in production. I've written the code in a functional style for clarity and conciseness. If you have a high read volume, given that this code might potentially run on a significant portion of GET requests, it should probably be written in an imperative style that doesn't disregard performance. Even more importantly, this code does not protect against potential attackers who might try to create an arbitrarily deeply nested object or might include an unwieldy number of query parameters.</p>","excerpt":"<p>The other day at work, one of my colleagues was frated that he was unable to encode nested objects in a query string and still maintain a readable URL. I went home that night and coded up a simple solution to this problem, and I thought I'd share it here today. This <a href=\"https://github.com/nadrane/querystring-encoder\">Github repo</a> contains specs and the solution code.</p>\n","frontmatter":{"title":"Build Your Own Nested Query String Encoder/Decoder","date":"2018-04-13T00:00:00.000Z","url":"build-your-own-nested-query-string-encoder"}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"JavaScript"}}}