{"componentChunkName":"component---src-templates-category-js","path":"/categories/Build-Your-Own/","webpackCompilationHash":"efb0bb0915c91dac7b0a","result":{"data":{"allMarkdownRemark":{"nodes":[{"html":"<p><em>My inspiration for this blog post came from <a href=\"https://www.youtube.com/watch?v=VJ38wSFbM3A\">this video</a> where Dan Abramov walks through the source code to react-redux</em></p>\n<p>As frontend web developers, it's not uncommon that we follow well-specified patterns - often blindly. The frontend landscape is changing rapidly, and sometimes there isn't time to investigate why we use a specific pattern; we just know we should.</p>\n<p>One widely used pattern in <a href=\"https://github.com/reactjs/react-redux\">react-redux</a> applications looks like this</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  mapStateToProps<span class=\"token punctuation\">,</span>\n  mapDispatchToProps\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>I'll assume you know how to implement this pattern, but why do we use it and how does it work under the hood?</p>\n<!-- more -->\n<h2>Why Do we Need React-Redux?</h2>\n<p>React and Redux are two completely independent tools that have nothing to do with each other. React is a tool for creating user interfaces in the browser. Redux is a tool for managing state. Either tool can be used without the other. We often use them together because they both solve separate but very important and closely related problems. The purpose of react-redux is to get these two tools to talk.</p>\n<p>But first, what would we do without react-redux? How would React and Redux talk?</p>\n<h2>How to Integrate React and Redux Without react-redux</h2>\n<p>More precisely, how do we ensure that a React component re-renders when the Redux store changes? The answer lies in Redux's <a href=\"http://redux.js.org/docs/api/Store.html#subscribe\">subscribe</a> API.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> store <span class=\"token keyword\">from</span> <span class=\"token string\">\"./store\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// One solution is to make each component</span>\n    <span class=\"token comment\">// store the entirety of the redux state.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Callbacks passed to store.subscribe will be</span>\n    <span class=\"token comment\">// invoked every time the store's state changes.</span>\n    <span class=\"token comment\">// Our callback can get the state of the</span>\n    <span class=\"token comment\">// store and add it to the component's local state.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>unsubscribe <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// We need to make sure that we don't accidentally</span>\n  <span class=\"token comment\">// subscribe to the store multiple times in the case</span>\n  <span class=\"token comment\">// where a component mounts, unmounts, and then mounts a second time.</span>\n  <span class=\"token comment\">// Fortunately, Redux makes this easy by returning</span>\n  <span class=\"token comment\">// an unsubscribe function when store.subscribe is invoked.</span>\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If we insert the above boilerplate into every one of our React component's, then every component could have access to the store and would be informed through a subscription the moment the store's state changes. This configuration has three flaws.</p>\n<ol>\n<li>The boilerplate of subscribing and unsubscribing to the store is highly error prone and unnecessarily verbose.</li>\n<li>All of our React component's are dependent upon knowledge of the Redux store. This is a complete failure of <a href=\"https://en.wikipedia.org/wiki/Separation_of_concerns\">separation of concerns</a>.</li>\n<li>Every component is dependent upon the entirety of the store's state tree. This means that whenever an action is dispatched, <code class=\"language-text\">setState</code> is called on every mounted component, causing each one to re-render, regardless of whether its render function depends on the store state that changed. Woah! Let that sink in for a moment.</li>\n</ol>\n<p>Let's write a rudimentary implementation of connect that resolves the first problem.</p>\n<h2>Understanding The Syntax of Connect</h2>\n<p>Typically, we invoke <code class=\"language-text\">connect</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  mapStateToProps<span class=\"token punctuation\">,</span>\n  mapDispatchToProps\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>WrappedComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">connect</code> takes in two functions as arguments and returns a function. Yes, you heard me, <code class=\"language-text\">connect</code> returns a function, not a component. Suppose I invoke <code class=\"language-text\">connect</code> and neglect to pass in a component.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> connectFunc <span class=\"token operator\">=</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  mapStateToProps<span class=\"token punctuation\">,</span>\n  mapDispatchToProps\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> connctedComponent <span class=\"token operator\">=</span> <span class=\"token function\">connectFunc</span><span class=\"token punctuation\">(</span>WrappedComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">connect</code> will return to me a function. It's that function that takes in my component (<code class=\"language-text\">connect</code> is implemented this way as opposed to simply taking in 3 arguments to support decorator syntax. The Dan Abramov video I linked above explains this.)</p>\n<p>Thus, the very first few lines of <code class=\"language-text\">connect</code> must look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mapStateToProps<span class=\"token punctuation\">,</span> mapDispatchToProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Higher Order Components</h2>\n<p>And what does the function we returned above do? This function is implemented as a <a href=\"https://reactjs.org/docs/higher-order-components.html\">higher order component</a> (HOC). A HOC is a function that takes in a component as a parameter and returns a new component. The new component is generally a modified or augmented version of the original component.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mapStateToProps<span class=\"token punctuation\">,</span> mapDispatchToProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// We are returning a brand new component.</span>\n    <span class=\"token comment\">// Note that this new component does</span>\n    <span class=\"token comment\">// not inherit from WrappedComponent.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WrapperComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// All we are doing is returning a new component</span>\n      <span class=\"token comment\">// that renders our original component.</span>\n      <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Notice that we need to pass WrappedComponent</span>\n        <span class=\"token comment\">// WrapperComponent's props.</span>\n        <span class=\"token comment\">// If we didn't do this, then WrappedComponent</span>\n        <span class=\"token comment\">// would never have access to any props.</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>this<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If we were to run the above <code class=\"language-text\">connect</code> function on a component, the connected component would behave identically to original component. Furthermore, we could nest <code class=\"language-text\">connect</code> as many times as we want</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>App<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>and still never distort the behavior of the original component. Our current implementation is effectively <a href=\"https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation\">idempotent</a>.</p>\n<h2>Eliminating Boilerplate</h2>\n<p>Our next step is to eliminate some of the boilerplate code. We don't want to have to subscribe to the store every time we create a new component, so let's have our new <code class=\"language-text\">connect</code> function do it instead.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mapStateToProps<span class=\"token punctuation\">,</span> mapDispatchToProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WrapperComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>unsubscribe <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Since the whole point of this HOC is to get WrappedComponent</span>\n        <span class=\"token comment\">// access to the store, we need to pass that state down as props.</span>\n        <span class=\"token keyword\">const</span> storeState <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>storeState<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>this<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>storeState<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We just made huge progress! Now, whenever we invoke</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>we get a component that is subscribed to state changes on the store, and this state will be passed down to our component as props.</p>\n<h2>Implementing Support for mapStateToProps</h2>\n<p>Our connected components still all depend on the entirety of the store's state tree. Look up above, the entire state is passed down as props to every connected component. To reiterate, this means that if any piece of the store's state is updated, our component will re-render.</p>\n<p>This is where <code class=\"language-text\">mapStateToProps</code> comes to the rescue. <code class=\"language-text\">mapStateToProps</code> takes as its argument the store's state, and it allows us to return the particular pieces of the store's state that a component depends on. It then passes that state as props to our component instead.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mapStateToProps<span class=\"token punctuation\">,</span> mapDispatchToProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WrapperComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>unsubscribe <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Now, instead of passing down all of the store state,</span>\n        <span class=\"token comment\">// we only pass down the subset of state return from</span>\n        <span class=\"token comment\">// mapStateToProps</span>\n        <span class=\"token keyword\">const</span> storeProps <span class=\"token operator\">=</span> <span class=\"token function\">mapStateToProps</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>storeState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>this<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>storeProps<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>All we did was insert a call to <code class=\"language-text\">mapStateToProps</code>, allowing us to make each connected component dependent upon only the state it cares about, as defined by the return value of <code class=\"language-text\">mapStateToProps</code>. <code class=\"language-text\">mapStateToProps</code> is a wonderful form of explicit documentation, clearly stating the slices of the state tree each component depends on. Unfortunately, our change does not fix the efficiency problems noted above. More on that below.</p>\n<h2>mapStateToProps and ownProps</h2>\n<p>An astute reader might note that <code class=\"language-text\">mapStateToProps</code> actually takes two arguments: the first is a copy of the store's state, and the second are the props that are originally passed down to <code class=\"language-text\">WrapperComponent</code>. <code class=\"language-text\">react-redux</code> does not pass these down to the wrapped component by default as we do in the example immediately above. Let's modify our implementation to mirror <code class=\"language-text\">react-redux</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mapStateToProps<span class=\"token punctuation\">,</span> mapDispatchToProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WrapperComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>unsubscribe <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> newProps <span class=\"token operator\">=</span> <span class=\"token function\">mapStateToProps</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>storeState<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>newProps<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now the implementer of <code class=\"language-text\">mapStateToProps</code> can choose which of <code class=\"language-text\">WrapperComponent</code>'s props it would like to keep and which it would like to disregard.</p>\n<h2>What's the Point of mapDispatchToProps?</h2>\n<p><code class=\"language-text\">mapDispatchToProps</code> is designed to eliminate React's dependency upon Redux. If we were to use the above implementation of <code class=\"language-text\">connect</code>, every component that dispatch's an action must import <code class=\"language-text\">store.dispatch</code>, and the implementation would look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> store <span class=\"token keyword\">from</span> <span class=\"token string\">\"./store\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> updateThing <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./store/actions\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ExampleComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">handleChange</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token function\">updateThing</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The above component 'knows' that it is part of a Redux application because it is explicitly referencing the store to dispatch actions. But we should always try to minimize the interaction of different pieces of architecture, esspecially when they have no need to interact. Ultimately, React components should not been intertwined with Redux code!</p>\n<h2>Implementing Support for mapDispatchToProps</h2>\n<p><code class=\"language-text\">connect</code> resolves this problem for us by injecting the <code class=\"language-text\">store.dispatch</code> dependency into <code class=\"language-text\">mapDispatchToProps</code>, allowing us to explicitly define functions that dispatch actions without requiring that our <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">presentation components</a> have a dependency on the store. Just as the return value of <code class=\"language-text\">mapStateToProps</code> is passed down to <code class=\"language-text\">WrappedComponent</code>, the return value of <code class=\"language-text\">mapDispatchToProps</code> will be passed down as well.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mapStateToProps<span class=\"token punctuation\">,</span> mapDispatchToProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WrapperComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>unsubscribe <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Now we merge the results from mapStateToProps</span>\n        <span class=\"token comment\">// and mapDispatchToProps and pass everything down</span>\n        <span class=\"token keyword\">const</span> newProps <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>\n          <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token function\">mapStateToProps</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>storeState<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          <span class=\"token comment\">// If you aren't intimately familiar with the this keyword,</span>\n          <span class=\"token comment\">// it's okay if you don't understand why we use bind here</span>\n          <span class=\"token function\">mapDispatchToProps</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>newProps<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>More Efficiency Issues - Hello shouldComponentUpdate</h2>\n<p>We never actually fixed any of the performance issues noted above. The crux of the problem is that every time the store updates, <code class=\"language-text\">WrapperComponent</code> re-renders (because of its Redux store subscription that calls <code class=\"language-text\">setState</code>) and that means <code class=\"language-text\">WrappedComponent</code> re-renders. This <a href=\"/leveraging-immutability-in-react\">re-rendering</a> happens despite the fact that <code class=\"language-text\">WrappedComponent</code>'s props might be unchanged between two invocations of <code class=\"language-text\">setState</code>. In fact, this scenario is highly probable and will occur whenever a piece of state in the store changes that your component does not depend on (aka, a piece of store state not returned from from <code class=\"language-text\">mapStateToProps</code>).</p>\n<p>React has a handy lifecycle method called <a href=\"https://reactjs.org/docs/react-component.html#shouldcomponentupdate\"><code class=\"language-text\">shouldComponentUpdate</code></a> that allows us to return a boolean that indicates whether a component should re-render. In essence, if we implement this method on <code class=\"language-text\">WrapperComponent</code> and it returns <code class=\"language-text\">false</code>, then React will not re-render <code class=\"language-text\">WrapperComponent</code>. And it follows that <code class=\"language-text\">WrappedComponent</code> won't re-render either.</p>\n<p>So, in the above scenario, when <code class=\"language-text\">WrapperComponent</code> calls <code class=\"language-text\">setState</code>, React first calls the <code class=\"language-text\">shouldComponentUpdate</code> method to see if a re-render should actually happen. Let's implement it below.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Just a simple shallow equality function</span>\n<span class=\"token keyword\">import</span> shallowEqual <span class=\"token keyword\">from</span> <span class=\"token string\">\"shallow-equal/objects\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mapStateToProps<span class=\"token punctuation\">,</span> mapDispatchToProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WrapperComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// If the props to WrapperComponent do not change</span>\n        <span class=\"token comment\">// between setState calls, then we don't need to re-render.</span>\n        <span class=\"token comment\">// On the previous re-render, we cached the results of</span>\n        <span class=\"token comment\">// mapStateToProps. That's what this.oldProps is.</span>\n        <span class=\"token keyword\">const</span> newProps <span class=\"token operator\">=</span> <span class=\"token function\">mapStateToProps</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>storeState<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token function\">shallowEqual</span><span class=\"token punctuation\">(</span>newProps<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>oldProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>unsubscribe <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> storeState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// We need to hang onto the previous result of</span>\n        <span class=\"token comment\">// mapStateToProps to use the next time</span>\n        <span class=\"token comment\">// shouldComponentUpdate runs</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>oldProps <span class=\"token operator\">=</span> <span class=\"token function\">mapStateToProps</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>storeState<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> newProps <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>\n          <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>oldProps<span class=\"token punctuation\">,</span>\n          <span class=\"token function\">mapDispatchToProps</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>newProps<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I've created a demo <a href=\"https://codesandbox.io/s/o43p70k66\">here</a>. Open the console and prove to yourself that <code class=\"language-text\">shouldComponentUpdate</code> is doing its job.</p>\n<p><em>I should note that this is not exactly what react-redux does because of edge cases, but the concept is still the same.</em></p>\n<p>Now our wrapper and wrapped components will only re-render when the props returned from <code class=\"language-text\">mapStateToProps</code> change! This is a huge performance gain. This implementation of <code class=\"language-text\">connect</code> explains why adherence to <a href=\"http://redux.js.org/docs/faq/ReactRedux.html#react-not-rerendering\">immutability is so important</a> in redux's reducers. If you fail to respect immutability, the shallow comparison in the <code class=\"language-text\">shouldComponentUpdate</code> in <code class=\"language-text\">WrapperComponent</code> will likely return <code class=\"language-text\">false</code>, causing your connected component to not re-render when it should.</p>\n<h2>Wrapping up</h2>\n<p>React-redux's <code class=\"language-text\">connect</code> method is remarkably simple and only performs a handful of operations.</p>\n<ol>\n<li>It manages our component's subscription to the store so that our component can update when the store updates.</li>\n<li>It allows us to explicitly define the slice of state our component is dependent upon using <code class=\"language-text\">mapStateToProps</code>.</li>\n<li>It gives our component access to <code class=\"language-text\">store.dispatch</code> without requiring a direct dependency on the store.</li>\n<li>It defines <code class=\"language-text\">shouldComponentUpdate</code>, ensuring that our components only re-render when the store state they depend on changes.</li>\n</ol>\n<p>I hope you found this article helpful. Please feel free to email me and reach out if you have questions. I put a <a href=\"https://gist.github.com/nadrane/5221c64c421efe421bda9fdaab167dc2\">gist</a> online containing the same code as the demo.</p>\n<p><em>If you use the React/Redux stack and need help, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>","excerpt":"<p><em>My inspiration for this blog post came from <a href=\"https://www.youtube.com/watch?v=VJ38wSFbM3A\">this video</a> where Dan Abramov walks through the source code to react-redux</em></p>\n<p>As frontend web developers, it's not uncommon that we follow well-specified patterns - often blindly. The frontend landscape is changing rapidly, and sometimes there isn't time to investigate why we use a specific pattern; we just know we should.</p>\n<p>One widely used pattern in <a href=\"https://github.com/reactjs/react-redux\">react-redux</a> applications looks like this</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  mapStateToProps<span class=\"token punctuation\">,</span>\n  mapDispatchToProps\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>I'll assume you know how to implement this pattern, but why do we use it and how does it work under the hood?</p>\n","frontmatter":{"title":"Write Your Own React-Redux Connect","date":"2017-09-29T00:00:00.000Z","url":"write-your-own-redux-connect"}},{"html":"<p>I stumbled upon an <a href=\"https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\">article</a> the other day where Rob Pike implements a rudimentary regular expression engine in c. I converted his code to Javascript and added test specs so that someone can self-guide themselves through the creation of the regex engine. The specs and solution can be found in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a>. This blog post walks through my solution.</p>\n<!-- more -->\n<h2>The Problem</h2>\n<p>Our regex engine will support the following syntax:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Meaning</th>\n<th>Example</th>\n<th>matches</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>Matches the specified character literal</td>\n<td>q</td>\n<td>q</td>\n</tr>\n<tr>\n<td>*</td>\n<td>Matches 0 or more of the previous character</td>\n<td>a*</td>\n<td>\"\", a, aa, aaa</td>\n</tr>\n<tr>\n<td>?</td>\n<td>Matches 0 or 1 of the previous character</td>\n<td>a?</td>\n<td>\"\", a</td>\n</tr>\n<tr>\n<td>.</td>\n<td>Matches any character literal</td>\n<td>.</td>\n<td>a, b, c, d, e ...</td>\n</tr>\n<tr>\n<td>^</td>\n<td>Matches the start of a string</td>\n<td>^c</td>\n<td>c, ca, caa, cbb ...</td>\n</tr>\n<tr>\n<td>$</td>\n<td>Matches the end of a string</td>\n<td>a$</td>\n<td>ba, baaa, qwerta ...</td>\n</tr>\n</tbody>\n</table>\n<p>The goal is to provide a syntax robust enough to match a large portion of regex use cases with minimal code.</p>\n<h2>Matching One Character</h2>\n<p>The first step is to write a function that takes in a one character pattern and a one character text string and returns a boolean indicating if they match. A pattern of <code class=\"language-text\">.</code> is considered a wildcard and matches against any character literal.</p>\n<p>Here are some examples</p>\n<p><code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;)</code> -> <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">matchOne(&#39;.&#39;, &#39;z&#39;)</code> -> <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">matchOne(&#39;&#39;, &#39;h&#39;)</code> -> <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">matchOne(&#39;a&#39;, &#39;b&#39;)</code> -> <code class=\"language-text\">false</code></p>\n<p><code class=\"language-text\">matchOne(&#39;p&#39;, &#39;&#39;)</code> -> <code class=\"language-text\">false</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pattern<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Any text matches an empty pattern</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>text<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// If the pattern is defined but the text is empty, there cannot be a match</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Any inputted text matches the wildcard</span>\n  <span class=\"token keyword\">return</span> pattern <span class=\"token operator\">===</span> text<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Matching Same Length Strings</h2>\n<p>Now we want to add support for patterns and text strings of greater length. For now, let's only consider a pattern/text pair of the same length. I happen to know that the solution lends itself very naturally to recursion, so we will use it here. We are going to want to repeatedly invoke <code class=\"language-text\">matchOne</code> on successive pairs of characters from the pattern/text combination.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// Our base case - if the pattern is empty, any inputted text is a match</span>\n  <span class=\"token keyword\">else</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The above code advances character by character across the the pattern/text pair. It first compares <code class=\"language-text\">pattern[0]</code> to <code class=\"language-text\">text[0]</code> and then <code class=\"language-text\">pattern[1]</code> to <code class=\"language-text\">text[1]</code> and continues comparing <code class=\"language-text\">pattern[i]</code> to <code class=\"language-text\">text[i]</code> until <code class=\"language-text\">i === pattern.length - 1</code>. If they ever don't match, then we know that the pattern cannot match the text.</p>\n<p>Let's take an example. Suppose we invoke <code class=\"language-text\">match(&#39;a.c&#39;, &#39;abc&#39;)</code>, which returns <code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; match(&#39;.c&#39;, &#39;bc&#39;)</code>.</p>\n<p>If we continue evaluating these functions, we get <code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; matchOne(&#39;.&#39;, &#39;b&#39;) &amp;&amp; matchOne(&#39;c&#39;, &#39;c&#39;) &amp;&amp; match(&quot;&quot;, &quot;&quot;)</code>, which is just equal to <code class=\"language-text\">true &amp;&amp; true &amp;&amp; true &amp;&amp; true</code>, So we have a match!</p>\n<h2>The $ Character</h2>\n<p>Let's add support for the special pattern character <code class=\"language-text\">$</code> that allows us to match the end of a string. The solution simply requires adding an additional base case to the match function.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\"$\"</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>The ^ Character</h2>\n<p>Let's add support for the special pattern character <code class=\"language-text\">^</code> that allows us to match the beginning of a string. I'm going to introduce a new function called <code class=\"language-text\">search</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"^\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This function will be the new entry point to our code. Up till this point, we were only matching patterns that began at the beginning of the text. We are simply making that more clear now by forcing the user to preface the pattern with a <code class=\"language-text\">^</code>. But how do we support patterns that appear anywhere within the text?</p>\n<h2>Matches Starting Anywhere</h2>\n<p>Currently, the following return <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">search(&quot;^abc&quot;, &quot;abc&quot;)</code></p>\n<p><code class=\"language-text\">search(&quot;^abcd&quot;, &quot;abcd&quot;)</code></p>\n<p>But <code class=\"language-text\">search(&quot;bc&quot;, &quot;abcd&quot;)</code> will just return <code class=\"language-text\">undefined</code>. We want it to return <code class=\"language-text\">true</code></p>\n<p>If the user does not specify that the pattern matches the beginning of the text, then we want to search for that pattern at every possible starting point within the text. We will default to this behavior if the pattern does not begin with <code class=\"language-text\">^</code><sup><a href=\"#footnote1\">1</a></sup>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"^\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This code will run match(pattern, text.slice(index)) on every index of the text.</span>\n    <span class=\"token comment\">// This means that we test the pattern against every starting point of the text.</span>\n    <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">some</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>The ? Character</h2>\n<p>We want to be able to match 0 to 1 of the character before <code class=\"language-text\">?</code>.</p>\n<p>Here are some examples</p>\n<p><code class=\"language-text\">search(&quot;ab?c&quot;, &quot;ac&quot;)</code> -> <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">search(&quot;ab?c&quot;, &quot;abc&quot;)</code> -> <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">search(&quot;a?b?c?&quot;, &quot;abc&quot;)</code> -> <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">search(&quot;a?b?c?&quot;, &quot;&quot;)</code> -> <code class=\"language-text\">true</code></p>\n<p>The first step is to modify <code class=\"language-text\">match</code> to detect when a <code class=\"language-text\">?</code> character is present and then delegate to the <code class=\"language-text\">matchQuestion</code> function, which we will define shortly.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\"$\"</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Notice that we are looking at pattern[1] instead of pattern[0].</span>\n    <span class=\"token comment\">// pattern[0] is the character to match 0 or 1 of.</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"?\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">matchQuestion</code> needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code class=\"language-text\">?</code> is not matched but the text matches the remainder of the pattern (everything after the <code class=\"language-text\">?</code>).</li>\n<li>Where the character before the <code class=\"language-text\">?</code> is matched and the rest of the text (minus the 1 matched character) matches the remainder of the pattern.</li>\n</ol>\n<p>If either of these cases is truthy, then <code class=\"language-text\">matchQuestion</code> can return <code class=\"language-text\">true</code>.</p>\n<p>Let's consider the first case. How do we check if the text matches everything in the pattern except the <code class=\"language-text\">_?</code> syntax? In order words, how do we check if the character before the <code class=\"language-text\">?</code> appears 0 times? We strip 2 characters off the pattern (the first character is the one before the <code class=\"language-text\">?</code> and the second is the <code class=\"language-text\">?</code> itself) and invoke the match function.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The second case is a little more challenging, but just like before, it reuses functions we've already written</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If the <code class=\"language-text\">text[0]</code> matches <code class=\"language-text\">pattern[0]</code>, and the rest of the text (minus the part that is matched by <code class=\"language-text\">matchOne</code>) matches the remainder of the pattern, then we are golden. Note that we could rewrite the code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n    <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The one thing I like about this latter approach is that the boolean OR makes it explicitly clear that there are two cases, either of which may be true.</p>\n<h2>The * Character</h2>\n<p>We want to be able to match the character before the <code class=\"language-text\">*</code> 0 or more times.</p>\n<p>All of these should return <code class=\"language-text\">true</code>.</p>\n<p><code class=\"language-text\">search(&quot;a*&quot;, &quot;&quot;)</code></p>\n<p><code class=\"language-text\">search(&quot;a*&quot;, &quot;aaaaaaa&quot;)</code></p>\n<p><code class=\"language-text\">search(&quot;a*b&quot;, &quot;aaaaaaab&quot;)</code></p>\n<p>Similar to what we did when supporting <code class=\"language-text\">?</code>, we wan to delegate to a <code class=\"language-text\">matchStar</code> function within our <code class=\"language-text\">match</code> function</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">\"$\"</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"?\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"*\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchStar</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">matchStar</code>, like <code class=\"language-text\">matchQuestion</code>, also needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code class=\"language-text\">*</code> is not matched but the text matches the remainder of the pattern (everything after the <code class=\"language-text\">*</code>).</li>\n<li>Where the character before the <code class=\"language-text\">*</code> is matched one or more times and the rest of the text matches the remainder of the pattern.</li>\n</ol>\n<p>Since there are two cases that both result in a match (0 matches OR more matches), we know that <code class=\"language-text\">matchStar</code> can be implemented with a boolean OR. Furthermore, case 1 for <code class=\"language-text\">matchStar</code> is exactly the same as it was for <code class=\"language-text\">matchQuestion</code> and can be implemented identically using <code class=\"language-text\">match(pattern.slice(2), text)</code>. That means we only need to formulate an expression that satisfies case 2.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchStar</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n    <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Refactoring</h2>\n<p>We can now go back and cleverly simplify <code class=\"language-text\">search</code> using a trick I learned in <a href=\"https://www.udacity.com/course/design-of-computer-programs--cs212\">Peter Norvig's class</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"^\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".*\"</span> <span class=\"token operator\">+</span> pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We use the <code class=\"language-text\">*</code> character itself to allow for the pattern to appear anywhere in the string. The prepended <code class=\"language-text\">.*</code> says that any number of any character can appear before the pattern we wish to match.</p>\n<h2>Conclusion</h2>\n<p>It's remarkable how simple and elegant the code for such a sophisticated and generalized program can be. The full source is available in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a></p>\n<p>Here is a <a href=\"https://nickdrane.com/regex-and-automated-test-fuzzing/\">follow up article</a> where I fuzz test the regex engine.</p>\n<p><em>If you work at a company using javascript, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: There is a small bug in this code that I'm choosing to ignore. We don't account for the case that text is an empty string. Currently when <code class=\"language-text\">text === &#39;&#39;</code>, <code class=\"language-text\">text.split(&quot;&quot;)</code> will return <code class=\"language-text\">[]</code> and will not appropriately call <code class=\"language-text\">match</code>.</p>","excerpt":"<p>I stumbled upon an <a href=\"https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\">article</a> the other day where Rob Pike implements a rudimentary regular expression engine in c. I converted his code to Javascript and added test specs so that someone can self-guide themselves through the creation of the regex engine. The specs and solution can be found in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a>. This blog post walks through my solution.</p>\n","frontmatter":{"title":"Build a Regex Engine in Less than 40 Lines of Code","date":"2017-11-28T00:00:00.000Z","url":"build-your-own-regex"}},{"html":"<p>The other day at work, one of my colleagues was frated that he was unable to encode nested objects in a query string and still maintain a readable URL. I went home that night and coded up a simple solution to this problem, and I thought I'd share it here today. This <a href=\"https://github.com/nadrane/querystring-encoder\">Github repo</a> contains specs and the solution code.</p>\n<!-- more -->\n<h2>Motivation</h2>\n<p>Today, in the Node.js ecosystem, numerous modules exist to encode query strings, but they generally have one of two flaws:</p>\n<ol>\n<li>They do not permit the encoding of nested objects.</li>\n<li>They can encode nested objects, but they delimit nesting using unsafe URL characters, yielding an operation and a result that look like this <sup><a href=\"#footnote1\">1</a></sup>:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> b<span class=\"token punctuation\">:</span> <span class=\"token string\">'c'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">>>></span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">a%5Bb%5D=c</span><span class=\"token template-punctuation string\">`</span></span></code></pre></div>\n<h2>The Problem in Detail</h2>\n<p>Node.js provides a <a href=\"https://nodejs.org/api/querystring.html\"><code class=\"language-text\">querystring</code></a> module to encode objects to query strings. The only problem is that conforms to an official specification that doesn't allow nested objects. Unfortunately, this specification does not allow for enough flexibility when creating a RESTful API.</p>\n<p>For example, suppose the client wants to filter a collection of cars by make and model. The route might look like this:</p>\n<p><code class=\"language-text\">/api/cars?make=honda&amp;model=civic</code></p>\n<p>This URI makes it reasonably clear that we want to filter cars by their make and model.</p>\n<p>What if we wanted to do something more complicated. What if we wanted to filter cars and order them by price?</p>\n<p><code class=\"language-text\">/api/cars?order=price&amp;make=honda&amp;model=civic</code></p>\n<p>It's no longer clear which query parameters describe the ordering and which describe the filter. Ideally, we want the url to look like this:</p>\n<p><code class=\"language-text\">/api/cars?order=price&amp;filter.make=honda&amp;filter.model=civic</code></p>\n<p>If we were to represent the query string of the above URI as a JavaScript object, it would probably look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    order<span class=\"token punctuation\">:</span> <span class=\"token string\">\"price\"</span><span class=\"token punctuation\">,</span>\n    filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        make<span class=\"token punctuation\">:</span> <span class=\"token string\">\"honda\"</span><span class=\"token punctuation\">,</span>\n        model<span class=\"token punctuation\">:</span> <span class=\"token string\">\"civic\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And then we quickly run into our problem. We need to encode the object above into</p>\n<p><code class=\"language-text\">order=price&amp;filter.make=honda&amp;filter.model=civic</code></p>\n<p>but Node.js's <a href=\"https://nodejs.org/api/querystring.html\"><code class=\"language-text\">querystring</code></a> can't encode nested objects.</p>\n<h2>Existing Modules Supporting Nested Querystrings</h2>\n<p>By default, the <a href=\"https://www.npmjs.com/package/qs\">qs</a> module creates ugly urls when it encodes nested query strings. If we encode our object above, we get</p>\n<p><code class=\"language-text\">order=price&amp;filter[make]=honda&amp;filter[model]=civic</code></p>\n<p>The <code class=\"language-text\">[</code> and <code class=\"language-text\">]</code> characters are both considered unsafe in a URL and are required to be escaped. The URL becomes unreadable after this percent encoding operation.</p>\n<p><code class=\"language-text\">order=price&amp;filter%5Bmake%5D=honda&amp;filter%5Bmodel%5D=civic</code></p>\n<p>Fortunately, the <code class=\"language-text\">.</code> is not considered unsafe and does not need to be escaped, making it the perfect character to express object nesting.</p>\n<h2>The Solution</h2>\n<p>The solution is broken down into two parts. The first is <em>encoding</em> a nested object into a query string. The second part is <em>decoding</em> a query string back into a nested object.</p>\n<h2>Encoding Nested Objects <sup><a href=\"#footnote2\">2</a></sup></h2>\n<p>Let's write some code to encode</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    make<span class=\"token punctuation\">:</span> <span class=\"token string\">\"honda\"</span><span class=\"token punctuation\">;</span>\n    model<span class=\"token punctuation\">:</span> <span class=\"token string\">\"civic\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>into the query string <code class=\"language-text\">filter.make=honda&amp;filter.model=civic</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> escape <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"querystring\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> queryString <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> pairs <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Handle the nested, recursive case, where the value to encode is an object itself</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">+</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Handle base case, where the value to encode is simply a string.</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> pairs<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice that we use the <a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_escape_str\">escape</a> function provided in Node.js core to percent encode specific characters.</p>\n<h2>Encoding Arrays as Values</h2>\n<p>If we want to add support to encode an object with array values, like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"nick\"</span><span class=\"token punctuation\">,</span>\n    hobbies<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"cooking\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"coding\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>then we only need to add another base case to our function</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> queryString <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> pairs <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Handle a second base case where the value to encode is an array</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> val\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">subVal</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> subVal<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">+</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> pairs<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>An encoding function is not very useful unless you can decode the encoded string back to it's original form.</p>\n<h2>Decoding Nested Objects</h2>\n<p>We want to write a function that will decode <code class=\"language-text\">filter.make=honda&amp;filter.model=civic</code> back into a nested object</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    make<span class=\"token punctuation\">:</span> <span class=\"token string\">\"honda\"</span><span class=\"token punctuation\">;</span>\n    model<span class=\"token punctuation\">:</span> <span class=\"token string\">\"civic\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code to do this is fairly straightforward if we use a <a href=\"https://lodash.com/docs\">Lodash</a> utility called <a href=\"https://lodash.com/docs/4.17.5#set\">set</a> that allows us to set an arbitrarily nested key in an object.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.set\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">queryString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> queryStringPieces <span class=\"token operator\">=</span> queryString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> decodedQueryString <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> piece <span class=\"token keyword\">of</span> queryStringPieces<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> piece<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    value <span class=\"token operator\">=</span> value <span class=\"token operator\">||</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// If a value is not defined, it should be decoded as an empty string</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> decodedQueryString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Decoding Arrays as Values</h2>\n<p>If we want to add support to decode arrays like we did above, then we need to do a little additional work. Fortunately, two additional <a href=\"https://lodash.com/docs\">Lodash</a> utilities, <a href=\"https://lodash.com/docs/4.17.5#has\">has</a> and <a href=\"https://lodash.com/docs/4.17.5#get\">get</a>, allow us to check for the existence of a nested key and to get the value associated with a nested key, respectively, greatly simplifying our problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.set\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> has <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.has\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">get</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lodash.get\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">queryString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> queryStringPieces <span class=\"token operator\">=</span> queryString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> decodedQueryString <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> piece <span class=\"token keyword\">of</span> queryStringPieces<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> piece<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    value <span class=\"token operator\">=</span> value <span class=\"token operator\">||</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> currentValueForKey <span class=\"token operator\">=</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>currentValueForKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>currentValueForKey<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        currentValueForKey<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> decodedQueryString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>And that's it! The whole thing, encoding and decoding, only takes ~40 lines of code. Perhaps next time you encounter something that feels a little too fundamental to code yourself, you won't hesitate to write some code if you can't find a sufficient open source package.</p>\n<p><em>If you've run into challenges with your web applications, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: This example is straight from the <a href=\"https://www.npmjs.com/package/qs\">qs</a> documentation. Incidentally, qs provides an option to encode using a url safe character, which would result in readable urls, but this is not the default.</p>\n<p><a name=\"footnote2\">2</a>: It's worth noting that you might not want to use this code in production. I've written the code in a functional style for clarity and conciseness. If you have a high read volume, given that this code might potentially run on a significant portion of GET requests, it should probably be written in an imperative style that doesn't disregard performance. Even more importantly, this code does not protect against potential attackers who might try to create an arbitrarily deeply nested object or might include an unwieldy number of query parameters.</p>","excerpt":"<p>The other day at work, one of my colleagues was frated that he was unable to encode nested objects in a query string and still maintain a readable URL. I went home that night and coded up a simple solution to this problem, and I thought I'd share it here today. This <a href=\"https://github.com/nadrane/querystring-encoder\">Github repo</a> contains specs and the solution code.</p>\n","frontmatter":{"title":"Build Your Own Nested Query String Encoder/Decoder","date":"2018-04-13T00:00:00.000Z","url":"build-your-own-nested-query-string-encoder"}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Build Your Own"}}}