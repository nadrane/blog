{"componentChunkName":"component---src-templates-article-js","path":"/hidden-costs-of-postgresql-jsonb/","webpackCompilationHash":"17aab0c6c8bb8bde0f93","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://www.postgresql.org/\">Postgres</a> introduced the <a href=\"https://www.postgresql.org/docs/current/static/datatype-json.html\">JSONB</a> type in version 9.4 with considerable excitement. JSONB promised to marry a favorite relational database with the noSQL world, permitting data to be stored in the database as JSON without the need for re-parsing whenever a field is accessed. Moreover, the binary storage format permits indexing and complex queries against the stored JSON blobs. This data format embodies the flexible schema and was readily adopted at <a href=\"https://fraight.ai/\">Fraight</a>.</p>\n<!-- more -->\n<h2>Background</h2>\n<p>At Fraight, we've built a centralized communication platform that collates all inbound/outbound communications between our brokerage company and thousands of trucking partners. One of our main objectives is to build a system that parses and automatically responds to inbound text messages, emails, and faxes. We knew we would eventually need the nitty-gritty details of these messages, so we captured the data by dumping entire http response bodies into a JSONB column named <code class=\"language-text\">meta</code> in our database’s <code class=\"language-text\">message</code> table.</p>\n<p>In an ideal world, the third party API responses we collected would have been broken down into discrete chunks and stored in separate columns, but our approach was a pragmatic design decision. We knew it wasn't worth the engineering effort to try to understand the multitude of fields we receive from a half-dozen APIs, particularly when we had no idea at the time how we might use this information. But we did know it was valuable. And since we wanted it to be queryable, we chose JSONB over it's more inert and sometimes more size efficient cousin, the JSON datatype.</p>\n<h2>Discovery</h2>\n<p>Fraight’s CTO approached me the other day and explained that query performance over the <code class=\"language-text\">message</code> table had deteriorated. He elaborated that the queries were only slow when the <code class=\"language-text\">meta</code> column was included in the result set. We had previously experienced slowdown in the <code class=\"language-text\">message</code> table when entire email attachment bodies were getting serialized and stored in the <code class=\"language-text\">meta</code> column, and I suspected that the root cause of our current performance problem was in a similar vein. A quick <a href=\"#footnote1\">query</a> revealed that our <code class=\"language-text\">meta</code> column was often quite large.</p>\n<p>The average size of the <code class=\"language-text\">meta</code> column was 3.7 kb. That might not seem large, but for our 100,000 row table, that meant 400mb of (mostly unused) metadata. At the high end of the spectrum, some messages were up to 17mb in size. The precise details of why this dataset slows down queries are a bit esoteric<sup><a href=\"#footnote2\">2</a></sup>, but it was clear that we were storing too much information. You can read more about how Postgres stores large data values using <a href=\"https://www.postgresql.org/docs/current/static/storage-toast.html\">TOAST</a> and <a href=\"#footnote3\">how I validated this was a problem</a>.</p>\n<h2>Further Complications</h2>\n<p>The first queries against the <code class=\"language-text\">meta</code> column were for very simple tasks like showing the raw contents of an email to a user, perhaps in the case where message content extraction failed. Over time we began using specific fields to drive business logic, and our application code started to expect that <code class=\"language-text\">meta</code>'s JSON would adhere to a specific shape. Any proposed solution would likely necessitate changes to this application code.</p>\n<p>So the problem was twofold:</p>\n<ol>\n<li>We needed to extract the actual metadata (as opposed to fields that drove business logic) from the <code class=\"language-text\">meta</code> column and place it in a location where it would not affect query performance over the <code class=\"language-text\">message</code> table.</li>\n<li>We wanted to make the metadata less easily accessible. We recognized that making it accessible through the ORM made it ripe for misuse. We wanted to give it an alternative API that would lessen a developer's likeliness to rely on its structure.</li>\n</ol>\n<h2>Solutioning</h2>\n<p>We looked at several solutions. Below are the three we considered most seriously:</p>\n<ol>\n<li>Use the ORM to omit the <code class=\"language-text\">meta</code> column from all queries unless specifically included. Since we unnecessarily perform <code class=\"language-text\">select *</code> <sup><a href=\"#footnote4\">4</a></sup> queries over the <code class=\"language-text\">message</code> table, this strategy, despite its messiness, would increase the performance in most cases (with the occasional slow query when metadata was actually required) and would in theory be simple to implement. It wouldn't, however, resolve our initial design shortcut.</li>\n<li>Keep the <code class=\"language-text\">meta</code> column as-is but extract specific keys to <a href=\"https://aws.amazon.com/s3/\">S3</a>. In general, greater than 99% of the size of any given column's <code class=\"language-text\">meta</code> field was from a single key. For example, many of the emails we capture include large attachments. Other times message bodies retain long, historical email chains. By extracting these problematic fields and uploading them to S3, the database would only need to store a reference to the S3 content. Then, upon request, the server could generate a <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/dev//ShareObjectPreSignedURL.html\">pre-signed URL</a>, allowing the client to download large files directly from S3.</li>\n<li>Create a separate <code class=\"language-text\">metadata</code> table in Postgres. It would have a foreign key back to the original table where the metadata belonged. This solution solves the <code class=\"language-text\">select *</code> problem described above and offers an additional advantage: since the <code class=\"language-text\">meta</code> column pattern exists on more than just the <code class=\"language-text\">message</code> table, it offers a unified strategy for storing metadata.</li>\n</ol>\n<p>Our instinct was to go with #1 — the most simple and straightforward solution — and omit the <code class=\"language-text\">meta</code> column from most queries. Unfortunately, bugs in our ORM made it impossible to omit columns across joins without the occasional crash. We needed an alternate approach.</p>\n<p>This hiccup left the choice between S3 and a separate Postgres table. We agreed that pre-signed S3 URLs offered an ideal long-term alternative but ultimately chose a separate Postgres table for the same reason that we wanted to choose option #1: minimal risk and complexity. Our team is exceptionally experienced with Postgres, and we knew we could hit the ground running. S3, in contrast, had more unknowns, and given how rarely we access most of this metadata today, the value it would add over Postgres was tenuous at best.</p>\n<p>In addition to migrating metadata to its own table, we took a couple additional steps:</p>\n<ol>\n<li>We extracted the handful of regularly used fields from the metadata and migrated them into their own columns in the <code class=\"language-text\">message</code> table. This meant that we didn't need to retrieve large, megabyte sized blobs whenever we wanted a single field<sup><a href=\"#footnote5\">5</a></sup>. As an added advantage, we regained simple access to database <a href=\"https://www.postgresql.org/docs/current/static/ddl-constraints.html\">constraints</a>.</li>\n<li>When we created the new <code class=\"language-text\">metadata</code> table in Postgres, we made sure not to define a relationship between it and its related tables at the ORM layer, only the database layer. This makes it far more difficult for a developer to hobble performance by absentmindedly joining large metadata into queries. We introduced an API for accessing the metadata instead. The added advantage of this API is that we can now change the underlying implementation to use S3 (or anything else) in the future, without modifying dependent application code.</li>\n</ol>\n<p><em>If you have ever had performance problems with PostgreSQL, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: I used the following query:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token function\">avg</span><span class=\"token punctuation\">(</span>octet_length<span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span><span class=\"token string\">\"meta\"</span>::<span class=\"token keyword\">text</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">FROM</span> message <span class=\"token keyword\">as</span> m</code></pre></div>\n<p><a name=\"footnote2\">2</a>: I should clarify that performance measurements were done with a local Postgres installation where network congestion/throughput is not a relevant factor.</p>\n<p><a name=\"footnote3\">3</a>:\nI verified that the <code class=\"language-text\">meta</code> column was toasting with a little help from the <a href=\"https://www.postgresql.org/docs/10/static/disk-usage.html\">Postgres docs</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> relname<span class=\"token punctuation\">,</span> relpages<span class=\"token punctuation\">,</span> relpages <span class=\"token operator\">*</span> <span class=\"token number\">8191</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> size\n<span class=\"token keyword\">FROM</span> pg_class<span class=\"token punctuation\">,</span>\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> reltoastrelid\n      <span class=\"token keyword\">FROM</span> pg_class\n      <span class=\"token keyword\">WHERE</span> relname <span class=\"token operator\">=</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> ss\n<span class=\"token keyword\">WHERE</span> oid <span class=\"token operator\">=</span> ss<span class=\"token punctuation\">.</span>reltoastrelid <span class=\"token operator\">OR</span>\n      oid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> indexrelid\n             <span class=\"token keyword\">FROM</span> pg_index\n             <span class=\"token keyword\">WHERE</span> indrelid <span class=\"token operator\">=</span> ss<span class=\"token punctuation\">.</span>reltoastrelid<span class=\"token punctuation\">)</span></code></pre></div>\n<p>For specifically the <code class=\"language-text\">message</code> table, this query returns the number of disk pages in the toast table and their total size in megabytes.</p>\n<table>\n<thead>\n<tr>\n<th>table</th>\n<th>disk pages</th>\n<th>size (mb)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>toast table</td>\n<td>17731</td>\n<td>139</td>\n</tr>\n<tr>\n<td>toast index</td>\n<td>209</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><a name=\"footnote4\">4</a>: We were not literally doing any <code class=\"language-text\">select *</code> queries. Our ORM's message model did, however, specify all of the columns of the <code class=\"language-text\">message</code> table. In retrospect, this was probably our biggest mistake. It meant that a call to <code class=\"language-text\">Message.find</code>, which is used all over the place, retrieved all columns on the <code class=\"language-text\">message</code> table, unless specifically directed otherwise. Usually, for a RESTful API, this is an acceptable performance tradeoff, but it didn't hold true in this circumstance.</p>\n<p><a name=\"footnote5\">5</a>: As I write this, I wonder if it wouldn't have been possible to leverage indexes to only retrieve specific pieces of the <code class=\"language-text\">meta</code> field. I wonder if our ORM provides any support for firstclass fields that are subfields of another field.</p>","frontmatter":{"title":"The Hidden Costs of PostgreSQL's JSONB Datatype","date":"2018-09-30T00:00:00.000Z","url":"hidden-costs-of-postgresql-jsonb"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"title":"The Hidden Costs of PostgreSQL's JSONB Datatype"}}}