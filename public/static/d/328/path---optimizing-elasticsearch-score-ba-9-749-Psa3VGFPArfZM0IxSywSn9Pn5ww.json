{"data":{"markdownRemark":{"html":"<p>A client approached me with a puzzling problem:</p>\n<p>At Fraight, we have an omnisearch interface backed by an Elasticsearch datastore. The interface allows users yo type a freetext query and get a list of database records sorted by relevancy. At it's core, this is a simple problem: if the user types in <code class=\"language-text\">Joe</code>, return all people whose name contains the word <code class=\"language-text\">Joe</code>. And indeed, returning all the <code class=\"language-text\">Joe&#39;s</code> in the system is trivial; the problem is that we worked hundreds, possibly even thousands of <code class=\"language-text\">Joes</code>. How do we identify the particular <code class=\"language-text\">Joe</code> that we care about?</p>\n<!-- more -->\n<h2>A Poor Solution</h2>\n<p>When I worked at <a href=\"https://www.epic.com/\">Epic</a>, we had a similar problem. We had a search interface that allowed us to look up patients. Unfortunately, our full names are not as unique as we like to believe, and a simple query for <code class=\"language-text\">Luke Smith</code> would surely bring the system to a halt. Epic solved this problem by providing additional fields. That's why (along with HIPPA reasons), when you call the doctor, they might ask for your birthdate or your address; this additional identifying information is used to pare down the search results. This solution is slow, cumbersome and was deemed wholly inadequate for us.</p>\n<h2>Fraight's Solution</h2>\n<p>We settled on two attributes that should influence the score of a particular record:</p>\n<ol>\n<li>How often we interact with an entity</li>\n<li>How recently we've interacted with an entity</li>\n</ol>\n<p>It's important to know that most of the trucking organizations in our system have been worked with minimally. We needed a remove this noise from the search results. Phrased differently, if we regularly work with a particular <code class=\"language-text\">Great America Truckers</code> more than the other 1000 <code class=\"language-text\">Great America Truckers</code>, we want our partner to appear higher in the search results.</p>\n<p>Similarly, if we have recently interacted with an organization, there's a good chance we will need to interact with them in the future. For example, if we've just initiated a conversation with a new business partner, there's a good chance we will continue interacting with them regularly in the near-term. It's important, however, to consider the time since our last interaction. If we interacted with someone yesterday or the day before, it's very important for them to be ranked higher than an organization we interacted with 10 days ago.</p>\n<h2>Getting the Data</h2>\n<p>Both of these solutions require populating our database with information regarding how recently we've interacted with particular entities. Fortunately, all of this can be done during the data ingestion phase when records are loaded in Elasticsearch. The only requirement is making sure to keep the information in Elasticsearch up to date with our PostgreSQL database</p>\n<p>The one challenge with this solution is that it requires augmenting our documents with special data regarding total interactions and recency of interactions. The huge advantage, however, is that it works seamlessly. We don't require there to be any special configuration when we begin working with a new partner.</p>\n<h2>Function Score Queries</h2>\n<p>Elasticsearch provides <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html\">function score queries</a> that allow you to modify Elasticsearch's calculated score. Their documentation provides a really simple example explaining boost the relevancy of a document that has many <code class=\"language-text\">likes</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">GET /_search\n{\n    &quot;query&quot;: {\n        &quot;function_score&quot;: {\n            &quot;field_value_factor&quot;: {\n                &quot;field&quot;: &quot;likes&quot;,\n                &quot;factor&quot;: 1.2,\n                &quot;modifier&quot;: &quot;sqrt&quot;,\n            }\n        }\n    }\n}</code></pre></div>\n<p>This code says that every document's score will be <code class=\"language-text\">sqrt(1.2 * doc[&#39;likes&#39;].value)</code></p>\n<p>We used a particular kind of Function Score Query known as a <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-script-score\">Script Score</a>.</p>\n<p>We wanted our ultimate score to be a function of three values: the score returned from elasticsearch, the days since our last interaction, and our total interactions. Initially, our function looked something like this</p>\n<p><code class=\"language-text\">newscore</code> = _score _ doc['interactions'] _</p>\n<p>We found that Elasticsearch's relevancy score was being overwhelmed by parters with a high number of interactions, so much so that given a search term of <code class=\"language-text\">nick drane</code>, we might return <code class=\"language-text\">nick smith</code>, simply because we've worked with nick smith more.</p>\n<p>We needed to place an upperbound of the potential contribution of the total interactions. After initially looking at <a href=\"https://en.wikipedia.org/wiki/Logistic_function\">logistic functions</a> and other overly complicated strategies, we settled on a simple step function. If the number of interactions is greater than 25, then we multiply Elasticsearch's relevancy score by 2, otherwise we multiply it 1.</p>\n<p>The frequency contribution's function was similarly simple.</p>\n<p>(could be some density/decay function that looks at density of interactions over time)</p>\n<h2>challenges</h2>\n<p>Keeping the extra attributes up to date</p>\n<p>We did try to combine two guassian curves but couldn't get it working</p>\n<p>Sometimes was built using a <code class=\"language-text\">query_string</code> query against the <code class=\"language-text\">_all</code> field. Sometimes the returned results were good, but most of the time they fell short. Their problem was simple: how do we ensure that the</p>\n<p>health care\nselect based on recent claim\nselect based on scheduled appointment\nselect based on upcoming event\nspecify table to search</p>","frontmatter":{"title":"Optimizing Elasticsearch Score: How to Rank and Differentiate Similar Records","date":"2017-10-11T00:00:00.000Z"}}},"pageContext":{"slug":"optimizing-elasticsearch-score"}}