{"data":{"markdownRemark":{"html":"<p><em>My inspiration for this blog post came from <a href=\"https://www.youtube.com/watch?v=VJ38wSFbM3A\">this video</a> where Dan Abramov walks through the source code to react-redux</em></p>\n<p>As frontend web developers, it's not uncommon that we follow well-specified patterns - often blindly. The frontend landscape is changing rapidly, and sometimes there isn't time to investigate why we use a specific pattern; we just know we should.</p>\n<p>One widely used pattern in <a href=\"https://github.com/reactjs/react-redux\">react-redux</a> applications looks like this</p>\n<pre><code class=\"language-js\">connect(mapStateToProps, mapDispatchToProps)(MyComponent)\n</code></pre>\n<p>I'll assume you know how to implement this pattern, but why do we use it and how does it work under the hood?</p>\n<!-- more -->\n<h1>Why Do we Need React-Redux?</h1>\n<p>React and Redux are two completely independent tools that have nothing to do with each other. React is a tool for creating user interfaces in the browser. Redux is a tool for managing state. Either tool can be used without the other. We often use them together because they both solve separate but very important and closely related problems. The purpose of react-redux is to get these two tools to talk.</p>\n<p>But first, what would we do without react-redux? How would React and Redux talk?</p>\n<h1>How to Integrate React and Redux Without react-redux</h1>\n<p>More precisely, how do we ensure that a React component re-renders when the Redux store changes? The answer lies in Redux's <a href=\"http://redux.js.org/docs/api/Store.html#subscribe\">subscribe</a> API.</p>\n<pre><code class=\"language-js\">import store from './store'\nimport { Component } from 'react'\n\nclass MyComponent extends Component {\n  constructor() {\n    super();\n    // One solution is to make each component\n    // store the entirety of the redux state.\n    this.state = { storeState: store.getState() };\n  }\n\n  componentDidMount() {\n    // Callbacks passed to store.subscribe will be\n    // invoked every time the store's state changes.\n    // Our callback can get the state of the\n    // store and add it to the component's local state.\n    this.unsubscribe = store.subscribe(() => {\n      this.setState({ storeState: store.getState() });\n    });\n  }\n\n  // We need to make sure that we don't accidentally\n  // subscribe to the store multiple times in the case\n  // where a component mounts, unmounts, and then mounts a second time.\n  // Fortunately, Redux makes this easy by returning\n  // an unsubscribe function when store.subscribe is invoked.\n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n}\n</code></pre>\n<p>If we insert the above boilerplate into every one of our React component's, then every component could have access to the store and would be informed through a subscription the moment the store's state changes. This configuration has three  flaws.</p>\n<ol>\n<li>The boilerplate of subscribing and unsubscribing to the store is highly error prone and unnecessarily verbose.</li>\n<li>All of our React component's are dependent upon knowledge of the Redux store. This is a complete failure of <a href=\"https://en.wikipedia.org/wiki/Separation_of_concerns\">separation of concerns</a>.</li>\n<li>Every component is dependent upon the entirety of the store's state tree. This means that whenever an action is dispatched, <code>setState</code> is called on every mounted component, causing each one to re-render, regardless of whether its render function depends on the store state that changed. Woah! Let that sink in for a moment.</li>\n</ol>\n<p>Let's write a rudimentary implementation of connect that resolves the first problem.</p>\n<h1>Understanding The Syntax of Connect</h1>\n<p>Typically, we invoke <code>connect</code> like this:</p>\n<pre><code class=\"language-js\">connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n</code></pre>\n<p><code>connect</code> takes in two functions as arguments and returns a function. Yes, you heard me, <code>connect</code> returns a function, not a component. Suppose I invoke <code>connect</code> and neglect to pass in a component.</p>\n<pre><code class=\"language-js\">const connectFunc = connect(mapStateToProps, mapDispatchToProps);\nconst connctedComponent = connectFunc(WrappedComponent);\n</code></pre>\n<p> <code>connect</code> will return to me a function. It's that function that takes in my component (<code>connect</code> is implemented this way as opposed to simply taking in 3 arguments to support decorator syntax. The Dan Abramov video I linked above explains this.)</p>\n<p>Thus, the very first few lines of <code>connect</code> must look like this:</p>\n<pre><code class=\"language-js\">function connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n\n  };\n}\n</code></pre>\n<h1>Higher Order Components</h1>\n<p>And what does the function we returned above do? This function is implemented as a <a href=\"https://reactjs.org/docs/higher-order-components.html\">higher order component</a> (HOC). A HOC is a function that takes in a component as a parameter and returns a new component. The new component is generally a modified or augmented version of the original component.</p>\n<pre><code class=\"language-js\">function connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n    // We are returning a brand new component.\n    // Note that this new component does\n    // not inherit from WrappedComponent.\n    return class WrapperComponent extends Component {\n      // All we are doing is returning a new component\n      // that renders our original component.\n      render() {\n        // Notice that we need to pass WrappedComponent\n        // WrapperComponent's props.\n        // If we didn't do this, then WrappedComponent\n        // would never have access to any props.\n        return &#x3C;WrappedComponent {...this.props} />;\n      }\n    };\n  };\n}\n</code></pre>\n<p>If we were to run the above <code>connect</code> function on a component, the connected component would behave identically to original component. Furthermore, we could nest <code>connect</code> as many times as we want</p>\n<pre><code class=\"language-js\">connect(null, null)(connect(null, null)(App))\n</code></pre>\n<p>and still never distort the behavior of the original component. Our current implementation is effectively <a href=\"https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation\">idempotent</a>.</p>\n<h1>Eliminating Boilerplate</h1>\n<p>Our next step is to eliminate some of the boilerplate code. We don't want to have to subscribe to the store every time we create a new component, so let's have our new <code>connect</code> function do it instead.</p>\n<pre><code class=\"language-js\">function connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n    return class WrapperComponent extends Component {\n      constructor() {\n        super();\n        this.state = { storeState: store.getState() };\n      }\n\n      componentDidMount() {\n        this.unsubscribe = store.subscribe(() => {\n          this.setState({ storeState: store.getState() });\n        });\n      }\n\n      componentWillUnmount() {\n        this.unsubscribe();\n      }\n\n      render() {\n        // Since the whole point of this HOC is to get WrappedComponent\n        // access to the store, we need to pass that state down as props.\n        const storeState = this.state.storeState;\n        return &#x3C;WrappedComponent {...this.props} {...storeState} />;\n      }\n    };\n  };\n}\n</code></pre>\n<p>We just made huge progress! Now, whenever we invoke</p>\n<pre><code class=\"language-js\">connect(null, null)(MyComponent)\n</code></pre>\n<p>we get a component that is subscribed to state changes on the store, and this state will be passed down to our component as props.</p>\n<h1>Implementing Support for mapStateToProps</h1>\n<p>Our connected components still all depend on the entirety of the store's state tree. Look up above, the entire state is passed down as props to every connected component. To reiterate, this means that if any piece of the store's state is updated, our component will re-render.</p>\n<p>This is where <code>mapStateToProps</code> comes to the rescue. <code>mapStateToProps</code> takes as its argument the store's state, and it allows us to return the particular pieces of the store's state that a component depends on. It then passes that state as props to our component instead.</p>\n<pre><code class=\"language-js\">function connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n    return class WrapperComponent extends Component {\n      constructor() {\n        super();\n        this.state = { storeState: store.getState() };\n      }\n\n      componentDidMount() {\n        this.unsubscribe = store.subscribe(() => {\n          this.setState({ storeState: store.getState() });\n        });\n      }\n\n      componentWillUnmount() {\n        this.unsubscribe();\n      }\n\n      render() {\n        // Now, instead of passing down all of the store state,\n        // we only pass down the subset of state return from\n        // mapStateToProps\n        const storeProps = mapStateToProps(this.state.storeState);\n        return &#x3C;WrappedComponent {...this.props} {...storeProps} />;\n      }\n    };\n  };\n}\n</code></pre>\n<p>All we did was insert a call to <code>mapStateToProps</code>, allowing us to make each connected component dependent upon only the state it cares about, as defined by the return value of <code>mapStateToProps</code>. <code>mapStateToProps</code> is a wonderful form of explicit documentation, clearly stating the slices of the state tree each component depends on. Unfortunately, our change does not fix the efficiency problems noted above. More on that below.</p>\n<h1>mapStateToProps and ownProps</h1>\n<p>An astute reader might note that <code>mapStateToProps</code> actually takes two arguments: the first is a copy of the store's state, and the second are the props that are originally passed down to <code>WrapperComponent</code>. <code>react-redux</code> does not pass these down to the wrapped component by default as we do in the example immediately above. Let's modify our implementation to mirror <code>react-redux</code>.</p>\n<pre><code class=\"language-js\">function connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n    return class WrapperComponent extends Component {\n      constructor() {\n        super();\n        this.state = { storeState: store.getState() };\n      }\n\n      componentDidMount() {\n        this.unsubscribe = store.subscribe(() => {\n          this.setState({ storeState: store.getState() });\n        });\n      }\n\n      componentWillUnmount() {\n        this.unsubscribe();\n      }\n\n      render() {\n        const newProps = mapStateToProps(this.state.storeState, this.props);\n        return &#x3C;WrappedComponent {...newProps} />;\n      }\n    };\n  };\n}\n</code></pre>\n<p>Now the implementer of <code>mapStateToProps</code> can choose which of <code>WrapperComponent</code>'s props it would like to keep and which it would like to disregard.</p>\n<h1>What's the Point of mapDispatchToProps?</h1>\n<p><code>mapDispatchToProps</code> is designed to eliminate React's dependency upon Redux. If we were to use the above implementation of <code>connect</code>, every component that dispatch's an action must import <code>store.dispatch</code>, and the implementation would look like this:</p>\n<pre><code class=\"language-js\">import store from \"./store\";\nimport { Component } from \"react\";\nimport { updateThing } from \"./store/actions\";\n\nclass ExampleComponent extends Component {\n  handleChange(e) {\n    store.dispatch(updateThing(e.target));\n  }\n}\n</code></pre>\n<p>The above component 'knows' that it is part of a Redux application because it is explicitly referencing the store to dispatch actions. But we should always try to minimize the interaction of different pieces of architecture, esspecially when they have no need to interact. Ultimately, React components should not been intertwined with Redux code!</p>\n<h2>Implementing Support for mapDispatchToProps</h2>\n<p><code>connect</code> resolves this problem for us by injecting the <code>store.dispatch</code> dependency into <code>mapDispatchToProps</code>, allowing us to explicitly define functions that dispatch actions without requiring that our <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">presentation components</a> have a dependency on the store. Just as the return value of <code>mapStateToProps</code> is passed down to <code>WrappedComponent</code>, the return value of <code>mapDispatchToProps</code> will be passed down as well.</p>\n<pre><code class=\"language-js\">function connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n    return class WrapperComponent extends Component {\n      constructor() {\n        super();\n        this.state = { storeState: store.getState() };\n      }\n\n      componentDidMount() {\n        this.unsubscribe = store.subscribe(() => {\n          this.setState({ storeState: store.getState() });\n        });\n      }\n\n      componentWillUnmount() {\n        this.unsubscribe();\n      }\n\n      render() {\n        // Now we merge the results from mapStateToProps\n        // and mapDispatchToProps and pass everything down\n        const newProps = Object.assign(\n          {},\n          mapStateToProps(this.state.storeState, this.props),\n          // If you aren't intimately familiar with the this keyword,\n          // it's okay if you don't understand why we use bind here\n          mapDispatchToProps(store.dispatch.bind(this))\n        );\n        return &#x3C;WrappedComponent {...newProps} />;\n      }\n    };\n  };\n}\n</code></pre>\n<h1>More Efficiency Issues - Hello shouldComponentUpdate</h1>\n<p>We never actually fixed any of the performance issues noted above. The crux of the problem is that every time the store updates, <code>WrapperComponent</code> re-renders (because of its Redux store subscription that calls <code>setState</code>) and that means <code>WrappedComponent</code> re-renders. This <a href=\"/leveraging-immutability-in-react\">re-rendering</a> happens despite the fact that <code>WrappedComponent</code>'s props might be unchanged between two invocations of <code>setState</code>. In fact, this scenario is highly probable and will occur whenever a piece of state in the store changes that your component does not depend on (aka, a piece of store state not returned from from <code>mapStateToProps</code>).</p>\n<p>React has a handy lifecycle method called <a href=\"https://reactjs.org/docs/react-component.html#shouldcomponentupdate\"><code>shouldComponentUpdate</code></a> that allows us to return a boolean that indicates whether a component should re-render. In essence, if we implement this method on <code>WrapperComponent</code> and it returns <code>false</code>, then React will not re-render <code>WrapperComponent</code>. And it follows that <code>WrappedComponent</code> won't re-render either.</p>\n<p>So, in the above scenario, when <code>WrapperComponent</code> calls <code>setState</code>, React first calls the <code>shouldComponentUpdate</code> method to see if a re-render should actually happen. Let's implement it below.</p>\n<pre><code class=\"language-js\">// Just a simple shallow equality function\nimport shallowEqual from \"shallow-equal/objects\"\n\nfunction connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n    return class WrapperComponent extends Component {\n      constructor() {\n        super();\n        this.state = { storeState: store.getState() };\n      }\n\n      shouldComponentUpdate() {\n        // If the props to WrapperComponent do not change\n        // between setState calls, then we don't need to re-render.\n        // On the previous re-render, we cached the results of\n        // mapStateToProps. That's what this.oldProps is.\n        const newProps = mapStateToProps(this.state.storeState, this.props);\n        return !shallowEqual(newProps, this.oldProps);\n      }\n\n      componentDidMount() {\n        this.unsubscribe = store.subscribe(() => {\n          this.setState({ storeState: store.getState() });\n        });\n      }\n\n      componentWillUnmount() {\n        this.unsubscribe();\n      }\n\n      render() {\n        // We need to hang onto the previous result of\n        // mapStateToProps to use the next time\n        // shouldComponentUpdate runs\n        this.oldProps = mapStateToProps(this.state.storeState, this.props)\n        const newProps = Object.assign(\n          {},\n          this.oldProps,\n          mapDispatchToProps(store.dispatch.bind(this))\n        );\n        return &#x3C;WrappedComponent {...newProps} />;\n      }\n    };\n  };\n}\n</code></pre>\n<p>I've created a demo <a href=\"https://codesandbox.io/s/o43p70k66\">here</a>. Open the console and prove to yourself that <code>shouldComponentUpdate</code> is doing its job.</p>\n<p><em>I should note that this is not exactly what react-redux does because of edge cases, but the concept is still the same.</em></p>\n<p>Now our wrapper and wrapped components will only re-render when the props returned from <code>mapStateToProps</code> change! This is a huge performance gain. This implementation of <code>connect</code> explains why adherence to <a href=\"http://redux.js.org/docs/faq/ReactRedux.html#react-not-rerendering\">immutability is so important</a> in redux's reducers. If you fail to respect immutability, the shallow comparison in the <code>shouldComponentUpdate</code> in <code>WrapperComponent</code> will likely return <code>false</code>, causing your connected component to not re-render when it should.</p>\n<h1>Wrapping up</h1>\n<p>React-redux's <code>connect</code> method is remarkably simple and only performs a handful of operations.</p>\n<ol>\n<li>It manages our component's subscription to the store so that our component can update when the store updates.</li>\n<li>It allows us to explicitly define the slice of state our component is dependent upon using <code>mapStateToProps</code>.</li>\n<li>It gives our component access to <code>store.dispatch</code> without requiring a direct dependency on the store.</li>\n<li>It defines <code>shouldComponentUpdate</code>, ensuring that our components only re-render when the store state they depend on changes.</li>\n</ol>\n<p>I hope you found this article helpful. Please feel free to email me and reach out if you have questions. I put a <a href=\"https://gist.github.com/nadrane/5221c64c421efe421bda9fdaab167dc2\">gist</a> online containing the same code as the demo.</p>","frontmatter":{"title":"Write Your Own React-Redux Connect"}}},"pageContext":{"slug":"write-your-own-redux-connect"}}