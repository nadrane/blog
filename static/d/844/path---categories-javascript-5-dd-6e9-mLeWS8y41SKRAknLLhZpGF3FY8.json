{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>The other day at work, one of my colleagues was frated that he was unable to encode nested objects in a query string and still maintain a readable URL. I went home that night and coded up a simple solution to this problem, and I thought I'd share it here today. This <a href=\"https://github.com/nadrane/querystring-encoder\">Github repo</a> contains specs and the solution code.</p>\n<!-- more -->\n<h2>Motivation</h2>\n<p>Today, in the Node.js ecosystem, numerous modules exist to encode query strings, but they generally have one of two flaws:</p>\n<ol>\n<li>\n<p>They do not permit the encoding of nested objects.</p>\n</li>\n<li>\n<p>They can encode nested objects, but they delimit nesting using unsafe URL characters, yielding an operation and a result that look like this <sup><a href=\"#footnote1\">1</a></sup>:</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> b<span class=\"token punctuation\">:</span> <span class=\"token string\">'c'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">>>></span><span class=\"token template-string\"><span class=\"token string\">`a%5Bb%5D=c`</span></span></code></pre></div>\n<h2>The Problem in Detail</h2>\n<p>Node.js provides a <a href=\"https://nodejs.org/api/querystring.html\"><code class=\"language-text\">querystring</code></a> module to encode objects to query strings. The only problem is that conforms to an official specification that doesn't allow nested objects. Unfortunately, this specification does not allow for enough flexibility when creating a RESTful API.</p>\n<p>For example, suppose the client wants to filter a collection of cars by make and model. The route might look like this:</p>\n<p><code class=\"language-text\">/api/cars?make=honda&amp;model=civic</code></p>\n<p>This URI makes it reasonably clear that we want to filter cars by their make and model.</p>\n<p>What if we wanted to do something more complicated. What if we wanted to filter cars and order them by price?</p>\n<p><code class=\"language-text\">/api/cars?order=price&amp;make=honda&amp;model=civic</code></p>\n<p>It's no longer clear which query parameters describe the ordering and which describe the filter. Ideally, we want the url to look like this:</p>\n<p><code class=\"language-text\">/api/cars?order=price&amp;filter.make=honda&amp;filter.model=civic</code></p>\n<p>If we were to represent the query string of the above URI as a Javascript object, it would probably look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    order<span class=\"token punctuation\">:</span> <span class=\"token string\">\"price\"</span><span class=\"token punctuation\">,</span>\n    filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        make<span class=\"token punctuation\">:</span> <span class=\"token string\">\"honda\"</span><span class=\"token punctuation\">,</span>\n        model<span class=\"token punctuation\">:</span> <span class=\"token string\">\"civic\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And then we quickly run into our problem. We need to encode the object above into</p>\n<p><code class=\"language-text\">order=price&amp;filter.make=honda&amp;filter.model=civic</code></p>\n<p>but Node.js's <a href=\"https://nodejs.org/api/querystring.html\"><code class=\"language-text\">querystring</code></a> can't encode nested objects.</p>\n<h2>Existing Modules Supporting Nested Querystrings</h2>\n<p>By default, the <a href=\"https://www.npmjs.com/package/qs\">qs</a> module creates ugly urls when it encodes nested query strings. If we encode our object above, we get</p>\n<p><code class=\"language-text\">order=price&amp;filter[make]=honda&amp;filter[model]=civic</code></p>\n<p>The <code class=\"language-text\">[</code> and <code class=\"language-text\">]</code> characters are both considered unsafe in a URL and are required to be escaped. The URL becomes unreadable after this percent encoding operation.</p>\n<p><code class=\"language-text\">order=price&amp;filter%5Bmake%5D=honda&amp;filter%5Bmodel%5D=civic</code></p>\n<p>Fortunately, the <code class=\"language-text\">.</code> is not considered unsafe and does not need to be escaped, making it the perfect character to express object nesting.</p>\n<h2>The Solution</h2>\n<p>The solution is broken down into two parts. The first is <em>encoding</em> a nested object into a query string. The second part is <em>decoding</em> a query string back into a nested object.</p>\n<h3>Encoding Nested Objects <sup><a href=\"#footnote2\">2</a></sup></h3>\n<p>Let's write some code to encode</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    make<span class=\"token punctuation\">:</span> <span class=\"token string\">'honda'</span><span class=\"token punctuation\">;</span>\n    model<span class=\"token punctuation\">:</span> <span class=\"token string\">'civic'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>into the query string <code class=\"language-text\">filter.make=honda&amp;filter.model=civic</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> escape <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'querystring'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> queryString <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> pairs <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Handle the nested, recursive case, where the value to encode is an object itself</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">+</span> <span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Handle base case, where the value to encode is simply a string.</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> pairs<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice that we use the <a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_escape_str\">escape</a> function provided in Node.js core to percent encode specific characters.</p>\n<h3>Encoding Arrays as Values</h3>\n<p>If we want to add support to encode an object with array values, like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"nick\"</span><span class=\"token punctuation\">,</span>\n    hobbies<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"cooking\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"coding\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>then we only need to add another base case to our function</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> queryString <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> pairs <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>queryObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Handle a second base case where the value to encode is an array</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> val<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>subVal <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> subVal<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> nesting <span class=\"token operator\">+</span> <span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>nesting <span class=\"token operator\">+</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> pairs<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>An encoding function is not very useful unless you can decode the encoded string back to it's original form.</p>\n<h3>Decoding Nested Objects</h3>\n<p>We want to write a function that will decode <code class=\"language-text\">filter.make=honda&amp;filter.model=civic</code> back into a nested object</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    make<span class=\"token punctuation\">:</span> <span class=\"token string\">'honda'</span><span class=\"token punctuation\">;</span>\n    model<span class=\"token punctuation\">:</span> <span class=\"token string\">'civic'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code to do this is fairly straightforward if we use a <a href=\"https://lodash.com/docs\">Lodash</a> utility called <a href=\"https://lodash.com/docs/4.17.5#set\">set</a> that allows us to set an arbitrarily nested key in an object.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lodash.set'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>queryString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> queryStringPieces <span class=\"token operator\">=</span> queryString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> decodedQueryString <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> piece <span class=\"token keyword\">of</span> queryStringPieces<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> piece<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    value <span class=\"token operator\">=</span> value <span class=\"token operator\">||</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// If a value is not defined, it should be decoded as an empty string</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> decodedQueryString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Decoding Arrays as Values</h3>\n<p>If we want to add support to decode arrays like we did above, then we need to do a little additional work. Fortunately, two additional <a href=\"https://lodash.com/docs\">Lodash</a> utilities, <a href=\"https://lodash.com/docs/4.17.5#has\">has</a> and <a href=\"https://lodash.com/docs/4.17.5#get\">get</a>, allow us to check for the existence of a nested key and to get the value associated with a nested key, respectively, greatly simplifying our problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lodash.set'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> has <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lodash.has'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">get</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lodash.get'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>queryString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> queryStringPieces <span class=\"token operator\">=</span> queryString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> decodedQueryString <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> piece <span class=\"token keyword\">of</span> queryStringPieces<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> piece<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    value <span class=\"token operator\">=</span> value <span class=\"token operator\">||</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> currentValueForKey <span class=\"token operator\">=</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>currentValueForKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>currentValueForKey<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        currentValueForKey<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>decodedQueryString<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> decodedQueryString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>And that's it! The whole thing, encoding and decoding, only takes ~40 lines of code. Perhaps next time you encounter something that feels a little too fundamental to code yourself, you won't hesitate to write some code if you can't find a sufficient open source package.</p>\n<p><em>If you've run into challenges with your web applications, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: This example is straight from the <a href=\"https://www.npmjs.com/package/qs\">qs</a> documentation. Incidentally, qs provides an option to encode using a url safe character, which would result in readable urls, but this is not the default.</p>\n<p><a name=\"footnote2\">2</a>: It's worth noting that you might not want to use this code in production. I've written the code in a functional style for clarity and conciseness. If you have a high read volume, given that this code might potentially run on a significant portion of GET requests, it should probably be written in an imperative style that doesn't disregard performance. Even more importantly, this code does not protect against potential attackers who might try to create an arbitrarily deeply nested object or might include an unwieldy number of query parameters.</p>","slug":"build-your-own-nested-query-string-encoder","frontmatter":{"title":"Build Your Own Nested Query String Encoder/Decoder","date":"2018-04-13T15:17:00.000Z"}}},{"node":{"html":"<p>I stumbled upon an <a href=\"https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\">article</a> the other day where Rob Pike implements a rudimentary regular expression engine in c. I converted his code to Javascript and added test specs so that someone can self-guide themselves through the creation of the regex engine. The specs and solution can be found in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a>. This blog post walks through my solution.</p>\n<!-- more -->\n<h2>The Problem</h2>\n<p>Our regex engine will support the following syntax:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Meaning</th>\n<th>Example</th>\n<th>matches</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>Matches the specified character literal</td>\n<td>q</td>\n<td>q</td>\n</tr>\n<tr>\n<td>*</td>\n<td>Matches 0 or more of the previous character</td>\n<td>a*</td>\n<td>\"\", a, aa, aaa</td>\n</tr>\n<tr>\n<td>?</td>\n<td>Matches 0 or 1 of the previous character</td>\n<td>a?</td>\n<td>\"\", a</td>\n</tr>\n<tr>\n<td>.</td>\n<td>Matches any character literal</td>\n<td>.</td>\n<td>a, b, c, d, e ...</td>\n</tr>\n<tr>\n<td>^</td>\n<td>Matches the start of a string</td>\n<td>^c</td>\n<td>c, ca, caa, cbb ...</td>\n</tr>\n<tr>\n<td>$</td>\n<td>Matches the end of a string</td>\n<td>a$</td>\n<td>ba, baaa, qwerta ...</td>\n</tr>\n</tbody>\n</table>\n<p>The goal is to provide a syntax robust enough to match a large portion of regex use cases with minimal code.</p>\n<h2>Matching One Character</h2>\n<p>The first step is to write a function that takes in a one character pattern and a one character text string and returns a boolean indicating if they match. A pattern of <code class=\"language-text\">.</code> is considered a wildcard and matches against any character literal.</p>\n<p>Here are some examples</p>\n<p><code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">matchOne(&#39;.&#39;, &#39;z&#39;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">matchOne(&#39;&#39;, &#39;h&#39;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">matchOne(&#39;a&#39;, &#39;b&#39;)</code> -> <code class=\"language-text\">false</code>\n<code class=\"language-text\">matchOne(&#39;p&#39;, &#39;&#39;)</code> -> <code class=\"language-text\">false</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pattern<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Any text matches an empty pattern</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>text<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// If the pattern is defined but the text is empty, there cannot be a match</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Any inputted text matches the wildcard</span>\n  <span class=\"token keyword\">return</span> pattern <span class=\"token operator\">===</span> text<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Matching Same Length Strings</h2>\n<p>Now we want to add support for patterns and text strings of greater length. For now, let's only consider a pattern/text pair of the same length. I happen to know that the solution lends itself very naturally to recursion, so we will use it here. We are going to want to repeatedly invoke <code class=\"language-text\">matchOne</code> on successive pairs of characters from the pattern/text combination.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// Our base case - if the pattern is empty, any inputted text is a match</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The above code advances character by character across the the pattern/text pair. It first compares <code class=\"language-text\">pattern[0]</code> to <code class=\"language-text\">text[0]</code> and then <code class=\"language-text\">pattern[1]</code> to <code class=\"language-text\">text[1]</code> and continues comparing <code class=\"language-text\">pattern[i]</code> to <code class=\"language-text\">text[i]</code> until <code class=\"language-text\">i === pattern.length - 1</code>. If they ever don't match, then we know that the pattern cannot match the text.</p>\n<p>Let's take an example. Suppose we invoke <code class=\"language-text\">match(&#39;a.c&#39;, &#39;abc&#39;)</code>, which returns <code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; match(&#39;.c&#39;, &#39;bc&#39;)</code>.</p>\n<p>If we continue evaluating these functions, we get <code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; matchOne(&#39;.&#39;, &#39;b&#39;) &amp;&amp; matchOne(&#39;c&#39;, &#39;c&#39;) &amp;&amp; match(&quot;&quot;, &quot;&quot;)</code>, which is just equal to <code class=\"language-text\">true &amp;&amp; true &amp;&amp; true &amp;&amp; true</code>, So we have a match!</p>\n<h2>The $ Character</h2>\n<p>Let's add support for the special pattern character <code class=\"language-text\">$</code> that allows us to match the end of a string. The solution simply requires adding an additional base case to the match function.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'$'</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>The ^ Character</h2>\n<p>Let's add support for the special pattern character <code class=\"language-text\">^</code> that allows us to match the beginning of a string. I'm going to introduce a new function called <code class=\"language-text\">search</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'^'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This function will be the new entry point to our code. Up till this point, we were only matching patterns that began at the beginning of the text. We are simply making that more clear now by forcing the user to preface the pattern with a <code class=\"language-text\">^</code>. But how do we support patterns that appear anywhere within the text?</p>\n<h2>Matches Starting Anywhere</h2>\n<p>Currently, the following return <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">search(&quot;^abc&quot;, &quot;abc&quot;)</code>\n<code class=\"language-text\">search(&quot;^abcd&quot;, &quot;abcd&quot;)</code></p>\n<p>But <code class=\"language-text\">search(&quot;bc&quot;, &quot;abcd&quot;)</code> will just return <code class=\"language-text\">undefined</code>. We want it to return <code class=\"language-text\">true</code></p>\n<p>If the user does not specify that the pattern matches the beginning of the text, then we want to search for that pattern at every possible starting point within the text. We will default to this behavior if the pattern does not begin with <code class=\"language-text\">^</code><sup><a href=\"#footnote1\">1</a></sup>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'^'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This code will run match(pattern, text.slice(index)) on every index of the text.</span>\n    <span class=\"token comment\">// This means that we test the pattern against every starting point of the text.</span>\n    <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">some</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>The ? Character</h2>\n<p>We want to be able to match 0 to 1 of the character before <code class=\"language-text\">?</code>.</p>\n<p>Here are some examples</p>\n<p><code class=\"language-text\">search(&quot;ab?c&quot;, &quot;ac&quot;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">search(&quot;ab?c&quot;, &quot;abc&quot;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">search(&quot;a?b?c?&quot;, &quot;abc&quot;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">search(&quot;a?b?c?&quot;, &quot;&quot;)</code> -> <code class=\"language-text\">true</code></p>\n<p>The first step is to modify <code class=\"language-text\">match</code> to detect when a <code class=\"language-text\">?</code> character is present and then delegate to the <code class=\"language-text\">matchQuestion</code> function, which we will define shortly.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'$'</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Notice that we are looking at pattern[1] instead of pattern[0].</span>\n    <span class=\"token comment\">// pattern[0] is the character to match 0 or 1 of.</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">matchQuestion</code> needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code class=\"language-text\">?</code> is not matched but the text matches the remainder of the pattern (everything after the <code class=\"language-text\">?</code>).</li>\n<li>Where the character before the <code class=\"language-text\">?</code> is matched and the rest of the text (minus the 1 matched character) matches the remainder of the pattern.</li>\n</ol>\n<p>If either of these cases is truthy, then <code class=\"language-text\">matchQuestion</code> can return <code class=\"language-text\">true</code>.</p>\n<p>Let's consider the first case. How do we check if the text matches everything in the pattern except the <code class=\"language-text\">_?</code> syntax? In order words, how do we check if the character before the <code class=\"language-text\">?</code> appears 0 times? We strip 2 characters off the pattern (the first character is the one before the <code class=\"language-text\">?</code> and the second is the <code class=\"language-text\">?</code> itself) and invoke the match function.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The second case is a little more challenging, but just like before, it reuses functions we've already written</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If the <code class=\"language-text\">text[0]</code> matches <code class=\"language-text\">pattern[0]</code>, and the rest of the text (minus the part that is matched by <code class=\"language-text\">matchOne</code>) matches the remainder of the pattern, then we are golden. Note that we could rewrite the code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n    <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The one thing I like about this latter approach is that the boolean OR makes it explicitly clear that there are two cases, either of which may be true.</p>\n<h2>The * Character</h2>\n<p>We want to be able to match the character before the <code class=\"language-text\">*</code> 0 or more times.</p>\n<p>All of these should return <code class=\"language-text\">true</code>.</p>\n<p><code class=\"language-text\">search(&quot;a*&quot;, &quot;&quot;)</code>\n<code class=\"language-text\">search(&quot;a*&quot;, &quot;aaaaaaa&quot;)</code>\n<code class=\"language-text\">search(&quot;a*b&quot;, &quot;aaaaaaab&quot;)</code></p>\n<p>Similar to what we did when supporting <code class=\"language-text\">?</code>, we wan to delegate to a <code class=\"language-text\">matchStar</code> function within our <code class=\"language-text\">match</code> function</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'$'</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchStar</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">matchStar</code>, like <code class=\"language-text\">matchQuestion</code>, also needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code class=\"language-text\">*</code> is not matched but the text matches the remainder of the pattern (everything after the <code class=\"language-text\">*</code>).</li>\n<li>Where the character before the <code class=\"language-text\">*</code> is matched one or more times and the rest of the text matches the remainder of the pattern.</li>\n</ol>\n<p>Since there are two cases that both result in a match (0 matches OR more matches), we know that <code class=\"language-text\">matchStar</code> can be implemented with a boolean OR. Furthermore, case 1 for <code class=\"language-text\">matchStar</code> is exactly the same as it was for <code class=\"language-text\">matchQuestion</code> and can be implemented identically using <code class=\"language-text\">match(pattern.slice(2), text)</code>. That means we only need to formulate an expression that satisfies case 2.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchStar</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Refactoring</h2>\n<p>We can now go back and cleverly simplify <code class=\"language-text\">search</code> using a trick I learned in Peter Norvig's <a href=\"https://www.udacity.com/course/design-of-computer-programs--cs212\">class</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'^'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.*'</span> <span class=\"token operator\">+</span> pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We use the <code class=\"language-text\">*</code> character itself to allow for the pattern to appear anywhere in the string. The prepended <code class=\"language-text\">.*</code> says that any number of any character can appear before the pattern we wish to match.</p>\n<h2>Conclusion</h2>\n<p>It's remarkable how simple and elegant the code for such a sophisticated and generalized program can be. The full source is available in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a></p>\n<p>Here is a <a href=\"https://nickdrane.com/regex-and-automated-test-fuzzing/\">follow up article</a> where I fuzz test the regex engine.</p>\n<p><em>If you work at a company using javascript, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: There is a small bug in this code that I'm choosing to ignore. We don't account for the case that text is an empty string. Currently when <code class=\"language-text\">text === &#39;&#39;</code>, <code class=\"language-text\">text.split(&quot;&quot;)</code> will return <code class=\"language-text\">[]</code> and will not appropriately call <code class=\"language-text\">match</code>.</p>","slug":"build-your-own-regex","frontmatter":{"title":"Build a Regex Engine in Less than 40 Lines of Code","date":"2017-11-28T00:00:00.000Z"}}},{"node":{"html":"<p>I posted my article <a href=\"https://nickdrane.com/build-your-own-regex/\">Build Your Own Regex Engine</a> on Reddit the other day, and one of the commenters claimed that the implementation should be trivial to break. Since I had already tested my program against a customized suite of tests, the remark got me thinking about how I could further increase my confidence in the correctness of my program. One extremely low cost however effective strategy for identifying faults in software is known as fuzzing.</p>\n<!-- more -->\n<h2>What is Fuzzing?</h2>\n<p>Fuzzing is a automated testing technique where a program is provided a series of invalid or randomly generated inputs. If we were testing an HTTP API, we might send randomized combinations of query parameters and ensure that our server always returns a 2xx status code. Since Javascript comes with a regular expression engine, my fuzzer asserts that given the same random input, both engine's return the same output.</p>\n<h2>Specifying the Grammar</h2>\n<p>The first step is to specify the grammar that our regex engine supports.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> lowercase <span class=\"token operator\">=</span> <span class=\"token string\">'abcdefghijklmnopqrstuvwxyz'</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> uppercase <span class=\"token operator\">=</span> lowercase<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>letter <span class=\"token operator\">=></span> letter<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> special <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regexGrammar <span class=\"token operator\">=</span> special<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>lowercase<span class=\"token punctuation\">,</span> uppercase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>You might notice we skipped the <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> characters. More on these in a little bit.</p>\n<h2>Generated Valid Regular Expressions</h2>\n<p>We want to write a function <code class=\"language-text\">generateRegex</code> that will select <code class=\"language-text\">n</code> random characters from the <code class=\"language-text\">regexGrammar</code> and concatenate them together into a string. This string will be used to create a test regex.</p>\n<p>Here are three possible returns values of <code class=\"language-text\">generateRegex</code>:</p>\n<ol>\n<li><code class=\"language-text\">.AnrQ?QNLQX.syBsOcJlbJZd</code></li>\n<li><code class=\"language-text\">.LkuZ?Ynj</code></li>\n<li><code class=\"language-text\">.UN?eiyddhXvyNj</code></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> regexString <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>chooseOne<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> regexString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Pick one element randomly from the grammar and return it</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">chooseOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> regexGrammar<span class=\"token punctuation\">[</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> regexGrammar<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Removing Invalid Regex Strings</h2>\n<p>My regex engine only deals with a very small subset of available regex syntax, and furthermore, it does not contain any error handling. What happens if <code class=\"language-text\">generateRegex</code> returns the pattern <code class=\"language-text\">**</code> or <code class=\"language-text\">^*</code>? My regex engine was never designed to handle these inputs, though they are possible outputs of <code class=\"language-text\">generateRegex</code>. We need to make a choice about how to handle these expressions. Since the primary goal of my regex engine is accessibility and simplicity of implementation, I'm not about to begin supporting these edge cases. That means my fuzzer should not generate them either.</p>\n<p>One solution to determine if a given regex string is valid is to specify my regex engine's allowable grammar in <a href=\"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form\">BNF</a>. BNF is a formal notation for specifying the syntax of a language. Given this BNF notation, I could ask another program if the randomly generated regex string can be created using my BNF specification. This sounds like a little more work than I want, however, since the invalid cases can simply be manually enumerated and filtered.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">validRegex</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">// None of the following sequences are properly</span>\n    <span class=\"token comment\">// defined by my regex engine</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'**'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'??'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'*?'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?*'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'^?'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'^*'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>regexString<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>regexString<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> regexString <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>chooseOne<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// If the generated string is valid, return it</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">validRegex</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> regexString<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Otherwise generate a new string and return that</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">generateRegexString</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>One more modification to <code class=\"language-text\">generateRegex</code> is necessary to support <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code>, and then we are basically done.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token comment\">// We need to ensure that '^' and '$' only go at the beginning</span>\n  <span class=\"token comment\">// and the end of the string, respectively.</span>\n  <span class=\"token comment\">// Give each a 10% probability of appearing in a string</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span> regexString <span class=\"token operator\">=</span> <span class=\"token string\">\"^\"</span> <span class=\"token operator\">+</span> regexString<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span> regexString <span class=\"token operator\">=</span> regexString <span class=\"token operator\">+</span> <span class=\"token string\">\"$\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Comparing Regex Implementations</h2>\n<p>All that is required now is to repeatedly invoke <code class=\"language-text\">generateRegex</code> a fixed number of times and then compare the output of the native JS implementation with the output of my implementation.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// The corpus is the string of text we are matching the pattern against.</span>\n<span class=\"token comment\">// I used a segment of Gulliver's Travels from Project Gutenberg.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fuzzer</span><span class=\"token punctuation\">(</span>totalTests<span class=\"token punctuation\">,</span> corpus<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> maxRegexLength <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// max will actually be 50 - 1</span>\n  <span class=\"token keyword\">let</span> testsRun <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>testsRun <span class=\"token operator\">&lt;</span> totalTests<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> regexLength <span class=\"token operator\">=</span> <span class=\"token function\">getRandomInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> maxRegexLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> regexString <span class=\"token operator\">=</span> <span class=\"token function\">generateRegexString</span><span class=\"token punctuation\">(</span>regexLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> testRegex <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>testRegex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>corpus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">myRegexEngine</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">,</span> corpus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>testRegex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    testsRun<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Thank you Mozzila :)</span>\n<span class=\"token comment\">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getRandomInt</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  min <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">ceil</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  max <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>max <span class=\"token operator\">-</span> min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> min<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Results</h2>\n<p>I ran my fuzzer for a couple million randomly generated cases and ended up learning two things about my regex engine.</p>\n<ol>\n<li>\n<p>My implementation fails extraordinarily with longer texts. I knew recursion would be a problem for any practical regex implementation (at least without <a href=\"https://en.wikipedia.org/wiki/Tail_call\">tail calls</a>) and would cause stack overflows, but I didn't expect it to fail with texts that were only a couple thousand words. I think this is because I make liberal use of backtracking algorithms in <code class=\"language-text\">matchQuestion</code> and <code class=\"language-text\">matchStar</code>. Since I was forced to test with a relatively short input text, it makes sense to use multiple text inputs to increase the probability of discovering an error.</p>\n</li>\n<li>\n<p>My implementation treats the <code class=\"language-text\">.</code> character differently than the native implementation. In the RegExp implementation, <code class=\"language-text\">.</code> will not match various line terminators (<code class=\"language-text\">\\n</code>, <code class=\"language-text\">\\r</code>, <code class=\"language-text\">\\u2028</code> or <code class=\"language-text\">\\u2029</code>). My implementation does.</p>\n</li>\n</ol>\n<h2>Conclusion</h2>\n<p>The biggest takeaway is that fuzzing is an simple and inexpensive way to enumerate enormous sets of inputs and identify bugs in your software. This fuzzer took less than an hour to write.</p>\n<p>But remember, this fuzzer's blessing of a couple million input combinations <strong>does not</strong> verify the correctness of my program. Not even close. A fuzzer is a tool to identify potential errors. Unless you enumerate all possible inputs (completely impossible in this case where they are infinite), you are not guaranteed your program is error free.</p>","slug":"regex-and-automated-test-fuzzing","frontmatter":{"title":"Regex And Automated Test Fuzzing","date":"2017-12-06T00:00:00.000Z"}}},{"node":{"html":"<p>I'm currently contracted to create a web service using some data from a third party Angular application. I worked off a proof of concept codebase that used Chrome's new <a href=\"https://github.com/GoogleChrome/puppeteer\">Puppeteer</a> API to scrape this site. I strongly regret not starting from scratch.</p>\n<!-- more -->\n<h2>What is Puppeteer?</h2>\n<p>Puppeteer is a Node API that allows you to control Google's headless Chrome browser. Imagine a version of your browser that can send and receive requests but has no GUI. It works in the background, performing actions as instructed by an API. This makes Puppeteer great for end to end testing a web application. You can truly simulate the user experience, typing where they type and clicking where they click. Another use case for Puppeteer is web scraping a single page web application. Let's explore how this might work.</p>\n<h2>A Simple Example</h2>\n<p>For any Puppeteer project, the first task is to create an instance of the headless browser.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> browser <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> puppeteer<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// We will use this page instance and it's API frequently</span>\n<span class=\"token keyword\">const</span> page <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>browser<span class=\"token punctuation\">.</span><span class=\"token function\">newPage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>After that's done, it's trivial to navigate to and begin interacting with a webpage. Let's suppose I want to fill out a login form and submit an authentication request to a website. In an ideal situation, it looks like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Navigate to the website</span>\n<span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">goto</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://website/login'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Provide the selector of an input box and the content to type</span>\n<span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input#username'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">CREDENTIALS</span><span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input#password'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">CREDENTIALS</span><span class=\"token punctuation\">.</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button#login'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Click the login button</span>\n\n<span class=\"token comment\">// Wait until the screen changes and a node matching</span>\n<span class=\"token comment\">// the selector #logged-in-successfully appears,</span>\n<span class=\"token comment\">// at which point we know the login was successful</span>\n<span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">waitForSelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#logged-in-successfully'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We just successfully filled out a form, submitted an HTTP request containing our form data, and waited for the page to change upon successful login. This is where Puppeteer shines. Let's look at a more complicated example.</p>\n<h2>A More Complicated Example</h2>\n<p>Today's web uses a mix of simple html driven forms as well as more complicated, javascript-driven forms, rich with functionality like autocomplete and dynamic dropdown menus. I'm sure you've used a calendar date picker. These components each need to be treated differently.</p>\n<p>Here is a modified version of some code I wrote for my client:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// The form inputs I want to fill out</span>\n<span class=\"token comment\">// and their corresponding selectors</span>\n<span class=\"token keyword\">const</span> fields <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">'input[ng-model=\"type\"]'</span><span class=\"token punctuation\">,</span>\n  origin<span class=\"token punctuation\">:</span> <span class=\"token string\">'input[ng-model=\"origin\"]'</span><span class=\"token punctuation\">,</span>\n  destination<span class=\"token punctuation\">:</span> <span class=\"token string\">'input[ng-model=\"destination\"]'</span><span class=\"token punctuation\">,</span>\n  date<span class=\"token punctuation\">:</span> <span class=\"token string\">'input[ng-model=\"date\"]'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>searchParams<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> page <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>browser<span class=\"token punctuation\">.</span><span class=\"token function\">newPage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">goto</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://website/search\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// We need to click a button to make the search form</span>\n  <span class=\"token comment\">// appear, but first make sure that button has rendered</span>\n  <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">waitForSelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".new-search\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".new-search\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Fill out the form</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> field <span class=\"token keyword\">of</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>fields<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>searchParams<span class=\"token punctuation\">[</span>field<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> selector <span class=\"token operator\">=</span> fields<span class=\"token punctuation\">[</span>field<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// We want to make sure each DOM node is rendered</span>\n      <span class=\"token comment\">// before we try to do anything to it.</span>\n      <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">waitForSelector</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// Some inputs need to be focused first for page.type to work</span>\n      <span class=\"token comment\">// Might as well focus on all of them</span>\n      <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">focus</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// Some inputs have defaults that need to be</span>\n      <span class=\"token comment\">// erased before typing your own input</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>field <span class=\"token operator\">===</span> <span class=\"token string\">\"date\"</span> <span class=\"token operator\">||</span> field <span class=\"token operator\">===</span> <span class=\"token string\">\"type\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// This is a helper function I wrote</span>\n        <span class=\"token keyword\">await</span> <span class=\"token function\">deleteInput</span><span class=\"token punctuation\">(</span>page<span class=\"token punctuation\">,</span> selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> searchParams<span class=\"token punctuation\">[</span>field<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// This field won't register the typed data</span>\n      <span class=\"token comment\">// until Enter is pressed.</span>\n      <span class=\"token comment\">// This is because the 'type' field is a dropdown</span>\n      <span class=\"token comment\">// where one of a specific set of inputs must be clicked.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>field <span class=\"token operator\">===</span> <span class=\"token string\">\"type\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span>keyboard<span class=\"token punctuation\">.</span><span class=\"token function\">press</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The first thing to notice is that the code is messy and full of weird exceptions. To make matters worse, it doesn't always work.</p>\n<h2>Brace Yourself for Flaky Behavior</h2>\n<p>Working with Puppeteer was an exercise in guesswork. Given the same inputs, Puppeteer did not always produce the same outputs<sup><a href=\"#footnote1\">1</a></sup>. This flaky behavior made the project unnecessarily challenging and required me to do additional engineering to increase reliability, which was frustrating considering the alternative.</p>\n<h2>Puppeteer Was Completely Unnecessary</h2>\n<p>Puppeteer has a API that allows you to execute arbitrary code against the DOM. After scraping form results with this API and getting the same flaky behavior described above, I ditched the approach and started grabbing data from the HTTP response objects themselves. Below is a primitive version of some code I wrote to do this.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">waitForUrl</span><span class=\"token punctuation\">(</span>page<span class=\"token punctuation\">,</span> urlPrefix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span>resolve <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    page<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"response\"</span><span class=\"token punctuation\">,</span> res <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>res<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>urlPrefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The page passed into this function is the same page object created above by the Puppeteer API. Among other things, it is an event emitter that allows me to listen for any HTTP responses. I've essentially created a promise that resolves to the response body of a particular ajax request. This allowed me interact with the server API directly and removed the DOM from the data retrieval process, greatly reducing the chance for flaky behavior. But that begs the question, why use Puppeteer at all? Why not simply send http requests to the server API manually and ditch the complicated form submission code above That's how I should have started all along.</p>\n<h2>When is Puppeteer the Right Solution</h2>\n<p>I can only think of a single scenario where using Puppeteer for scraping is superior to the alternative: if the information you want is generated using a combination of API data and javascript code. After all, you would have no other way to simulate the javascript code without rewriting it.</p>\n<p>If, however, all you need is data from the server, go the simple route and hit the API with an HTTP library like <a href=\"https://github.com/axios/axios\">axios</a> or <a href=\"https://github.com/request/request\">request</a>. If you are scraping a server side rendered application, you can combine one of the aforementioned tools with <a href=\"https://github.com/cheeriojs/cheerio\">Cheerio</a>, giving you a far more user friendly DOM manipulation API than that offered my Puppeteer.</p>\n<p><em>If you need help with webscraping or puppeteer, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please contact me for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: You might be curious why Puppeteer exhibited flaky behavior. One issue that I ran into was animations. I might attempt to click a DOM node, but if the animation had not finished, the click would not register. In essence, it would appear as if the click had worked, but once the animation finished, the DOM would reset itself, undoing my click. I think this is simply how Angular's digest loop reacted to a click at an unexpected time. Unfortunately, Puppeteer provides no functionality to determine when an animation has finished (after all, how would it!). I tried a couple solutions. One entailed a sleep function to wait a couple hundred milliseconds for the animation to finish, but it simply exacerbated the flaky behavior. A second involved executing the click only once the DOM node had a particular class that indicated the animation had finished. At one point, I even tried to disable all animations across the website. All these solutions were half-baked.</p>","slug":"scraping-the-web-with-puppeteer-lessons-learned","frontmatter":{"title":"Scraping the Web with Puppeteer: Lessons Learned","date":"2017-12-09T15:35:13.000Z"}}},{"node":{"html":"<p>There are two major <a href=\"https://davidwalsh.name/introduction-static-site-generators\">static site generators</a> in the Javascript ecosystem: the incumbent <a href=\"https://hexo.io\">Hexo</a> and the up-and-coming <a href=\"https://www.gatsbyjs.org/\">Gatsby</a>. This site was first built with Hexo, but I've recently switched to Gatsby. Let's talk about why.</p>\n<!-- more -->\n<h2>Different Products</h2>\n<p>First, let's talk high level. Hexo and Gatsby both generate static websites, but at their hearts, they are very different products. Hexo is a blog generator; Gatsby is a generalized static site generator. Let me elaborate.</p>\n<h3>Hexo</h3>\n<p>Hexo specializes in creating markup (be it <a href=\"https://en.wikipedia.org/wiki/Markdown\">markdown</a> or <a href=\"https://en.wikipedia.org/wiki/ReStructuredText\">reStructuredText</a>) driven blogs. This specialization comes with tradeoffs. It's simple to get a blog up and running, but if you want to do anything more complicated, it ranges from challenging to impossible. This limitation might not restrict you, however.</p>\n<h3>Gatsby</h3>\n<p>Gatsby epitomizes customizability and allows for the creation of arbitrarily complex static sites, ranging from simple blogs to fully featured e-commerce websites. It provides <a href=\"https://www.gatsbyjs.org/docs/node-apis/\">an API</a> for you to build and query a <a href=\"https://graphql.org/\">GraphQL</a> API composed of data from a variety of sources. You can then dynamically compose your static website based on the results of your queries. Gatsby trades power for complexity, requiring users to learn some new tools to leverage its capabilities.</p>\n<p>Let's get into the nitty gritty details.</p>\n<h2>Getting Up and Running</h2>\n<p>Both platforms make it easy to get from <code class=\"language-text\">yarn install</code> to writing blog articles, though Hexo definitely excels in this regard.</p>\n<h3>Hexo</h3>\n<p>With Hexo, I was able to install the application, run a couple <a href=\"https://hexo.io/docs/setup\">configuration commands</a>, pick a <a href=\"https://hexo.io/themes/index.html\">theme from their website</a>, and start writing.</p>\n<h3>Gatsby</h3>\n<p>Gatsby's sheer volume of documentation made the setup process slightly more challenging, though hardly difficult. There are two places you can start: their <a href=\"https://www.gatsbyjs.org/docs/\">getting started page</a> or <a href=\"https://www.gatsbyjs.org/tutorial/\">their tutorial</a>. The former will link you to their <a href=\"https://www.gatsbyjs.org/starters/?v=2\">starter library</a> and will help you get a server up and running. The latter will teach you how to customize your website.</p>\n<h2>Developer Experience</h2>\n<p>Hexo does not provide any tooling out-of-the-box, and your experience is largely determined by your theme. Gatsby, in contrast, optimizes for developer productivity.</p>\n<h3>Hexo</h3>\n<p>When I began with Hexo, I picked a theme called <a href=\"https://github.com/hmybmny/hexo-theme-concise\">Concise</a>, and my experience mostly stems from customizing this theme. Hexo originally only supported a dated templating language called <a href=\"https://ejs.co/\">EJS</a>, and most themes including Concise use it. Here is some sample code from Concise.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f97f98761f9e68564060ccfd117dae13/e5894/concise-code.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 680px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 30.626780626780626%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAA6klEQVQY052QwVLEIBBE9/+/Uje7iQkJLIQAgSXPIepBq/RgV/UUHKZ59CXEiNcaM89cu477/YZSM/sa0NqRlgWeT4q4iqmV33QcB5c2inP0146X1zvdtWfoNf3NYIY34jhi+kEeuzHKPT0sDWLfd/ZcCSlTcz7Dmi5tPEPAqwUzeZxJPB4bs7HilS1EIdU4azHG4FbPpBROgu1WmBZHWd33wOI3YkrU6Bs4/9XHl9shBqLPQlHEEaUtw6RRixWijSyVHNJdW/jLJ2EVsm1e8MOEHTWr0nghXn2UrhI5l7Mj2tInxRfNz7Cmd/s30vXaFhfWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <picture>\n        <source\n          srcset=\"/static/f97f98761f9e68564060ccfd117dae13/4ca7d/concise-code.webp 170w,\n/static/f97f98761f9e68564060ccfd117dae13/515c8/concise-code.webp 340w,\n/static/f97f98761f9e68564060ccfd117dae13/d6460/concise-code.webp 680w,\n/static/f97f98761f9e68564060ccfd117dae13/0b31f/concise-code.webp 702w\"\n          sizes=\"(max-width: 680px) 100vw, 680px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/f97f98761f9e68564060ccfd117dae13/f4d37/concise-code.png 170w,\n/static/f97f98761f9e68564060ccfd117dae13/dee79/concise-code.png 340w,\n/static/f97f98761f9e68564060ccfd117dae13/7ef4c/concise-code.png 680w,\n/static/f97f98761f9e68564060ccfd117dae13/e5894/concise-code.png 702w\"\n          sizes=\"(max-width: 680px) 100vw, 680px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n          src=\"/static/f97f98761f9e68564060ccfd117dae13/7ef4c/concise-code.png\"\n          alt=\"Code sample from Concise\"\n          title=\"\"\n          src=\"/static/f97f98761f9e68564060ccfd117dae13/7ef4c/concise-code.png\"\n        />\n      </picture>\n      </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Apart from the obvious readability problems, the syntax is challenging to edit and thus is at odds with application discoverability. It makes trivial exercises like console logging error-prone. Furthermore, the syntax is incompatible with the modern formatting tool, <a href=\"https://prettier.io/\">Prettier</a>.</p>\n<p>Today Hexo supports other templating languages, but it's a shame so many themes are tightly coupled to such an unergonomic tool.</p>\n<h3>Gatsby</h3>\n<p>Gatsby emphasizes the developer experience, using <a href=\"https://reactjs.org/\">React</a> and <a href=\"https://graphql.org/\">GraphQL</a> as the foundation for every Gatsby application. These tools and their ecosystems were immediate productivity boosters for me, though they do have a non-trivial learning curve. Fortunately, the Gatsby docs assume no prior knowledge, and realistically, you only need minimal understanding to be productive.</p>\n<p>The aforementioned <a href=\"https://www.gatsbyjs.org/docs/node-apis/\">Gatsby API</a>, which is used the define the pages of your site (among other things), also requires study to understand. It's powerful but lacks detailed documentation. Use cases for the various methods and hooks are scattered throughout the docs, though I was able to supplement the documentation with blogs/tutorials such that learning the API was manageable.</p>\n<p>Gatsby also automatically configures numerous developer tools to optimize your productivity. For example, <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> (more on this later) allows you to explore your data sources, Prettier ensures that your code remains consistently formatted, hot-reloading updates your UI without refreshing, and <a href=\"https://eslint.org/\">ESlint</a> catches your mistakes.</p>\n<p>Behind the scenes, Gatsby configures <a href=\"https://webpack.js.org/\">webpack</a> for you, abstracting away the most challenging parts of the React ecosystem. It goes to extra mile and things like service workers, inlining critical CSS, and CSS modules are automatic or a plugin away. Here is an exhaustive list of its <a href=\"https://www.gatsbyjs.org/features/\">features</a>.</p>\n<h2>Documentation</h2>\n<p>Documentation can make or break a developer's experience, and Hexo and Gatsby approach documentation very differently.</p>\n<h3>Hexo</h3>\n<p>Hexo does a great job of ensuring you need to read as little text as possible to get a blog up and running. If you want to customize your blog, however, the documentation's previously appreciated brevity shows it's warts. I would often read a page and have no idea what I was looking at, even when it was exactly what I needed.</p>\n<p>For example, if you want to customize your theme, you will need to know what variables Hexo injects into your template engine's rendering system. This <a href=\"https://hexo.io/docs/variables.html\">site</a> provides the details but doesn't provide an overview explaining its purpose.</p>\n<p>I should provide one qualifying statement. Hexo augments its documentation with video tutorials. I never noticed them until I chose to write this article, but perhaps they provide the detail I previously yearned for.</p>\n<h3>Gatsby</h3>\n<p>Gatsby's documentation is thoughtful, well-organized, and detailed. It has everything from <a href=\"https://www.gatsbyjs.org/tutorial/\">tutorials</a> to deep dives <a href=\"https://www.gatsbyjs.org/docs/adding-images-fonts-files/\">1</a>, <a href=\"https://www.gatsbyjs.org/docs/creating-and-modifying-pages/\">2</a>, <a href=\"https://www.gatsbyjs.org/docs/styling/\">3</a>. It even has pages explaining and justifying <a href=\"https://www.gatsbyjs.org/docs/behind-the-scenes/\">architecture and implementation details</a>. And to top all this off, it has a <a href=\"https://www.gatsbyjs.org/docs/gatsby-style-guide/\">style guide</a> to ensure readability.</p>\n<p>With all this said, there are still <a href=\"https://www.gatsbyjs.org/docs/dropping-images-into-static-folders/\">placeholder pages</a>, though I never found myself unable to answer a question about their system.</p>\n<h2>API Discoverability</h2>\n<p>A static site generator needs to make it easy to edit your website. One of the first requirements to editing your site is understanding the data structures the static site generator makes available to you.</p>\n<h3>Hexo</h3>\n<p>Hexo documents its data structures in the <a href=\"https://hexo.io/docs/variables.html\">link mentioned above</a>. The page references many key topics but never elaborates. I remember agonizing over providing support for both pagination and article excerpts.</p>\n<p>The page seems to hint that the next and previous blog posts are available from their API, though the fields were always <code class=\"language-text\">undefined</code>. I never figured out why.</p>\n<p>It also suggests excerpts are available. It wasn't until I discovered this <a href=\"https://github.com/hexojs/hexo/issues/1143\">GitHub issue</a> that I learned it's required to add the comment <code class=\"language-text\">&lt;!-- more --&gt;</code> to each post to ensure that this excerpt is populated. This feature is otherwise undocumented.</p>\n<p>Moreover, EJS prevents rapid code changes and thus data structure exploration, exacerbating these documentation problems.</p>\n<h3>Gatsby</h3>\n<p>Gatsby solves the problem of discoverability with <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a>. It automatically spins up a GraphiQL server which allows you to interactively browse your data. Here is a simple example that queries article excerpts and titles:</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/88d7a264299e94fd26d656e6c241040e/255fa/graphiql.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 680px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 72.89256198347107%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+0lEQVQ4y41T6XLyMBDjjYAkju8zB5Qe833v/zCq7EALnenxQ8PGeDWSdr2b5wUpZ5RSGjLrEAJSjPA+tDqyrkgptm9rDLxV8E7BaIV5nlg7jOOIXXIS3kiIocfxeGwQw4BQIuYloUTHywaajTdIqXmvw+Gw3d/v96wPrd4Vr3CZPEYxtEv1cCChoYpzCQ3OaCgSKSWv0FQj0Pc9uq57wK4eOj3yT5J1n4R2jrBrRHku8JcC90pbbzO0N7BVqfHtXnftuWFXD27SuztCNwWYOeBEovXfAveU4c4JOjmYqlJbCDF+9HwovP+4JzTBwhKOBJbQtK2vlp1RsDYwS7U5+wuhVgrBGmRvW62aTf5WMi0htUcvzN8VujXBM7+ZliPhqu2XAkXVSzJ4Yhw+nRvp8Xj4ndByuobTP71MWF7nlmEdUlVYVymGxElzfbr+cSjfEtYM2WiiZZ7bHiq5ZTgFx2wzhBaQgmd2hFCMoB9+yJBDCMyvqtGWA3G6DUoxv6WsKKcLpJshRv+wj79muDC7/J/5PW+7qLNrCk9T5k56SCMw0Hp3tf494bRluDK7iftn+V2nLOWIU+b5tEL5qrBHP4hHwq+oFlqGVKL5jtuzo9Vbjpm5Kpt5lySHz75mWQiBr5CyNmtEkrUM21u+EnIolk9VSksCPr07h5X0Hc578FYsVRseAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <picture>\n        <source\n          srcset=\"/static/88d7a264299e94fd26d656e6c241040e/4ca7d/graphiql.webp 170w,\n/static/88d7a264299e94fd26d656e6c241040e/515c8/graphiql.webp 340w,\n/static/88d7a264299e94fd26d656e6c241040e/d6460/graphiql.webp 680w,\n/static/88d7a264299e94fd26d656e6c241040e/c4056/graphiql.webp 1020w,\n/static/88d7a264299e94fd26d656e6c241040e/862d7/graphiql.webp 1360w,\n/static/88d7a264299e94fd26d656e6c241040e/81026/graphiql.webp 2040w,\n/static/88d7a264299e94fd26d656e6c241040e/0fde8/graphiql.webp 2420w\"\n          sizes=\"(max-width: 680px) 100vw, 680px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/88d7a264299e94fd26d656e6c241040e/f4d37/graphiql.png 170w,\n/static/88d7a264299e94fd26d656e6c241040e/dee79/graphiql.png 340w,\n/static/88d7a264299e94fd26d656e6c241040e/7ef4c/graphiql.png 680w,\n/static/88d7a264299e94fd26d656e6c241040e/7236f/graphiql.png 1020w,\n/static/88d7a264299e94fd26d656e6c241040e/1cc92/graphiql.png 1360w,\n/static/88d7a264299e94fd26d656e6c241040e/1bb63/graphiql.png 2040w,\n/static/88d7a264299e94fd26d656e6c241040e/255fa/graphiql.png 2420w\"\n          sizes=\"(max-width: 680px) 100vw, 680px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n          src=\"/static/88d7a264299e94fd26d656e6c241040e/7ef4c/graphiql.png\"\n          alt=\"GraphiQL Example\"\n          title=\"\"\n          src=\"/static/88d7a264299e94fd26d656e6c241040e/7ef4c/graphiql.png\"\n        />\n      </picture>\n      </span>\n  </span>\n  \n  </a>\n    </p>\n<p>You can see the query on the left, the results in the middle, and interactive schema documentation on the right. To top it all off, the environment provides autocomplete and errors messages.</p>\n<p>The contrast with Hexo's variable page is stark.</p>\n<h2>Community</h2>\n<p>A large and active community makes on-boarding easier. It means more people have run into the same problems, which often translates into more tutorials and more stack overflow questions answered. Community quality can heavily influence a developer's experience.</p>\n<h3>Hexo</h3>\n<p>Hexo is the most popular static site generator in the JS ecosystem, though I did not feel like the this made solving problems easier. I had numerous question I had to answer by consulting the source code.</p>\n<p>I think my experiences stems from the fact that Hexo's user base is largely Chinese. Unless your bilingual, this makes potentially helpful documentation and conversations inaccessible.</p>\n<h3>Gatsby</h3>\n<p>I've been blown away by the quality of Gatsby's community so far.</p>\n<p>The maintainers have written tutorials about how to migrate from other blogging platforms, and dedicated community members write about solving their own problems.</p>\n<p>I've also been impressed as a contributor to Gatsby. I ran into an issue where excerpts only rendered in plain text, not HTML. I opened a <a href=\"https://github.com/gatsbyjs/gatsby/pull/9716\">PR</a> to fix this problem and received prompt and thoughtful replies.</p>\n<h2>Plugin Ecosystem</h2>\n<h3>Hexo</h3>\n<p>Hexo has a <a href=\"https://hexo.io/plugins/index.html\">plugin page</a> detailing links to everything from markdown parsers to image and css optimizers. There are 277 plugins available, and I never ran into a situation where I couldn't find a plugin to do what I needed.</p>\n<h3>Gatsby</h3>\n<p>Gatsby has a <a href=\"https://hexo.io/plugins/index.html\">plugin search system</a> with twice as many plugins - 550 to be exact - available to date, though it's not clear to me how much additional value this offers over Hexo.</p>\n<p>On a side note, I appreciated that Gatsby sorts their plugin search results based on number of downloads. This primitive but effective metric makes it easier to evaluate the quality of a given plugin.</p>\n<h2>Performance</h2>\n<p>There are two types of performance relevant to this discussion: the speed of the static site generator itself, and the speed of the website it produces.</p>\n<p>If a a static site generator is slow to render your changes, it slows down your development speed. Fortunately, both Hexo and Gatsby refresh changes without perceptible delay.</p>\n<p>The speed of the sites these tools produce varies quite drastically.</p>\n<h3>Hexo</h3>\n<p>With Hexo, the speed of your static site will be coupled with your theme. Your theme might load tons of unnecessary javascript; it also might not use any.</p>\n<p>I think the most important point here is that Hexo adds absolutely no overhead to your website. It introduces no additional dependencies into your built project. If you want a pure static site without any javascript, you can create that. If you want no page to exceed 40kb, that's entirely doable</p>\n<h3>Gatsby</h3>\n<p>Gatsby takes a much different approach.</p>\n<p>For starters, it introduces a javascript dependency into your web site, clocking in around 65kb. Moreover, this means that your site will never be able to run on browsers without javascript enabled. It does give quite a few benefits in return, however.</p>\n<p>Gatsby either automatically or through plugins applies numerous performance tricks to every website. To explain a few:</p>\n<ol>\n<li>\n<p>When you reference a style sheet using a <code class=\"language-text\">link</code> tag, page blocks rendering until the entire roundtrip server request is complete. Gatsby gets around this problem by inlining critical CSS into your HTML.</p>\n</li>\n<li>\n<p>When you visit a page, once it has finished loading, Gatsby will begin loading every page you can reach from the page you're on. This technique is known as prefetching and makes subsequent page clicks fast.</p>\n</li>\n<li>\n<p>Gatsby uses (service workers)[https://developers.google.com/web/fundamentals/primers/service-workers/] via <a href=\"https://www.gatsbyjs.org/packages/gatsby-plugin-offline/\">gatsby-plugin-offline</a> to cache all the pages you download. This allows subsequent requests for those pages to hit the cache instead of the network. It also allow for users to browse your page offline later.</p>\n</li>\n<li>\n<p><a href=\"https://www.gatsbyjs.org/packages/gatsby-image/\">Gatsby Image</a> preprocesses and calibrates images for various screen sizes. This ensures that high resolution screens get high resolution images and vice-versa, resulting in significant bandwidth savings for smaller screens.</p>\n</li>\n</ol>\n<p>All of these performance abstractions don't come without a cost. I think my experience was quite telling. When I finished my Hexo website, the main page was about 40kb; when I finished my Gatsby website, the main page was ~200kb, though it's a little difficult to be precise, which brings me to my next point.</p>\n<p>Optimization is initially challenging and opaque with Gatsby. When I started, not only did I have no idea my final site would contain Javascript, I had no idea what would influence its performance. It turns out that everything I returned from my GraphQL queries would need to be loaded at runtime, regardless of whether the site used it. Similarly, any dependencies used in my application code also made it into the final bundle. These were facts I simply didn't understand going in, and they've certainly influenced how I program in Gatsby going forward.</p>\n<h2>Misc</h2>\n<p>One thing I didn't know before I nearly completed my Gatsby blog is that even after building the project, it is not completely javascript free! This isn't to say the site is not fast; it excels in every performance test I've looked at so far. But your site will nevertheless not run on the machines of users who do not have javascript enabled.</p>\n<h2>Conclusion</h2>\n<p>Hexo are Gatsby are different products. If you're interested in picking a theme, spinning up a blog, and perhaps tweaking it, Hexo might be a simpler choice. If, however, you want flexibility and a productive developer experience, Gatsby overshadows Hexo in nearly every way.</p>","slug":"hexo-vs-gatsbyjs-comparing-nodejs-static-site-generators","frontmatter":{"title":"A Deep Dive into Javascript Static Site Generators: Gatsby vs. Hexo","date":"2018-11-24T00:00:00.000Z"}}}]}},"pageContext":{"category":"Javascript"}}