{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>The other day at work, one of my colleagues was frated that he was unable to encode nested objects in a query string and still maintain a readable URL. I went home that night and coded up a simple solution to this problem, and I thought I'd share it here today. This <a href=\"https://github.com/nadrane/querystring-encoder\">Github repo</a> contains specs and the solution code.</p>\n<!-- more -->\n<h2>Motivation</h2>\n<p>Today, in the Node.js ecosystem, numerous modules exist to encode query strings, but they generally have one of two flaws:</p>\n<ol>\n<li>\n<p>They do not permit the encoding of nested objects.</p>\n</li>\n<li>\n<p>They can encode nested objects, but they delimit nesting using unsafe URL characters, yielding an operation and a result that look like this <sup><a href=\"#footnote1\">1</a></sup>:</p>\n</li>\n</ol>\n<pre><code class=\"language-js\">encode({\n  a: { b: 'c' }\n});\n>>>`a%5Bb%5D=c`\n</code></pre>\n<h2>The Problem in Detail</h2>\n<p>Node.js provides a <a href=\"https://nodejs.org/api/querystring.html\"><code>querystring</code></a> module to encode objects to query strings. The only problem is that conforms to an official specification that doesn't allow nested objects. Unfortunately, this specification does not allow for enough flexibility when creating a RESTful API.</p>\n<p>For example, suppose the client wants to filter a collection of cars by make and model. The route might look like this:</p>\n<p><code>/api/cars?make=honda&#x26;model=civic</code></p>\n<p>This URI makes it reasonably clear that we want to filter cars by their make and model.</p>\n<p>What if we wanted to do something more complicated. What if we wanted to filter cars and order them by price?</p>\n<p><code>/api/cars?order=price&#x26;make=honda&#x26;model=civic</code></p>\n<p>It's no longer clear which query parameters describe the ordering and which describe the filter. Ideally, we want the url to look like this:</p>\n<p><code>/api/cars?order=price&#x26;filter.make=honda&#x26;filter.model=civic</code></p>\n<p>If we were to represent the query string of the above URI as a Javascript object, it would probably look like this:</p>\n<pre><code class=\"language-js\">{\n    order: \"price\",\n    filter: {\n        make: \"honda\",\n        model: \"civic\"\n    }\n}\n</code></pre>\n<p>And then we quickly run into our problem. We need to encode the object above into</p>\n<p><code>order=price&#x26;filter.make=honda&#x26;filter.model=civic</code></p>\n<p>but Node.js's <a href=\"https://nodejs.org/api/querystring.html\"><code>querystring</code></a> can't encode nested objects.</p>\n<h2>Existing Modules Supporting Nested Querystrings</h2>\n<p>By default, the <a href=\"https://www.npmjs.com/package/qs\">qs</a> module creates ugly urls when it encodes nested query strings. If we encode our object above, we get</p>\n<p><code>order=price&#x26;filter[make]=honda&#x26;filter[model]=civic</code></p>\n<p>The <code>[</code> and <code>]</code> characters are both considered unsafe in a URL and are required to be escaped. The URL becomes unreadable after this percent encoding operation.</p>\n<p><code>order=price&#x26;filter%5Bmake%5D=honda&#x26;filter%5Bmodel%5D=civic</code></p>\n<p>Fortunately, the <code>.</code> is not considered unsafe and does not need to be escaped, making it the perfect character to express object nesting.</p>\n<h2>The Solution</h2>\n<p>The solution is broken down into two parts. The first is <em>encoding</em> a nested object into a query string. The second part is <em>decoding</em> a query string back into a nested object.</p>\n<h3>Encoding Nested Objects <sup><a href=\"#footnote2\">2</a></sup></h3>\n<p>Let's write some code to encode</p>\n<pre><code class=\"language-js\">{\n  filter: {\n    make: 'honda';\n    model: 'civic';\n  }\n}\n</code></pre>\n<p>into the query string <code>filter.make=honda&#x26;filter.model=civic</code></p>\n<pre><code class=\"language-js\">const { escape } = require('querystring');\n\nfunction encode(queryObj, nesting = '') {\n  let queryString = '';\n\n  const pairs = Object.entries(queryObj).map(([key, val]) => {\n    // Handle the nested, recursive case, where the value to encode is an object itself\n    if (typeof val === 'object') {\n      return encode(val, nesting + `${key}.`);\n    } else {\n      // Handle base case, where the value to encode is simply a string.\n      return [nesting + key, val].map(escape).join('=');\n    }\n  });\n  return pairs.join('&#x26;');\n}\n</code></pre>\n<p>Notice that we use the <a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_escape_str\">escape</a> function provided in Node.js core to percent encode specific characters.</p>\n<h3>Encoding Arrays as Values</h3>\n<p>If we want to add support to encode an object with array values, like the following:</p>\n<pre><code class=\"language-js\">{\n    name: \"nick\",\n    hobbies: [\"cooking\", \"coding\"]\n}\n</code></pre>\n<p>then we only need to add another base case to our function</p>\n<pre><code class=\"language-js\">function encode(queryObj, nesting = '') {\n  let queryString = '';\n\n  const pairs = Object.entries(queryObj).map(([key, val]) => {\n    // Handle a second base case where the value to encode is an array\n    if (Array.isArray(val)) {\n      return val.map(subVal => [nesting + key, subVal].map(escape).join('=')).join('&#x26;');\n    } else if (typeof val === 'object') {\n      return encode(val, nesting + `${key}.`);\n    } else {\n      return [nesting + key, val].map(escape).join('=');\n    }\n  });\n  return pairs.join('&#x26;');\n}\n</code></pre>\n<p>An encoding function is not very useful unless you can decode the encoded string back to it's original form.</p>\n<h3>Decoding Nested Objects</h3>\n<p>We want to write a function that will decode <code>filter.make=honda&#x26;filter.model=civic</code> back into a nested object</p>\n<pre><code class=\"language-js\">{\n  filter: {\n    make: 'honda';\n    model: 'civic';\n  }\n}\n</code></pre>\n<p>The code to do this is fairly straightforward if we use a <a href=\"https://lodash.com/docs\">Lodash</a> utility called <a href=\"https://lodash.com/docs/4.17.5#set\">set</a> that allows us to set an arbitrarily nested key in an object.</p>\n<pre><code class=\"language-js\">const set = require('lodash.set');\n\nfunction decode(queryString) {\n  const queryStringPieces = queryString.split('&#x26;');\n  const decodedQueryString = {};\n\n  for (const piece of queryStringPieces) {\n    let [key, value] = piece.split('=');\n    value = value || ''; // If a value is not defined, it should be decoded as an empty string\n    set(decodedQueryString, key, value);\n  }\n  return decodedQueryString;\n}\n</code></pre>\n<h3>Decoding Arrays as Values</h3>\n<p>If we want to add support to decode arrays like we did above, then we need to do a little additional work. Fortunately, two additional <a href=\"https://lodash.com/docs\">Lodash</a> utilities, <a href=\"https://lodash.com/docs/4.17.5#has\">has</a> and <a href=\"https://lodash.com/docs/4.17.5#get\">get</a>, allow us to check for the existence of a nested key and to get the value associated with a nested key, respectively, greatly simplifying our problem.</p>\n<pre><code class=\"language-js\">const set = require('lodash.set');\nconst has = require('lodash.has');\nconst get = require('lodash.get');\n\nfunction decode(queryString) {\n  const queryStringPieces = queryString.split('&#x26;');\n  const decodedQueryString = {};\n\n  for (const piece of queryStringPieces) {\n    let [key, value] = piece.split('=');\n    value = value || '';\n    if (has(decodedQueryString, key)) {\n      const currentValueForKey = get(decodedQueryString, key);\n      if (!Array.isArray(currentValueForKey)) {\n        set(decodedQueryString, key, [currentValueForKey, value]);\n      } else {\n        currentValueForKey.push(value);\n      }\n    } else {\n      set(decodedQueryString, key, value);\n    }\n  }\n  return decodedQueryString;\n}\n</code></pre>\n<h2>Conclusion</h2>\n<p>And that's it! The whole thing, encoding and decoding, only takes ~40 lines of code. Perhaps next time you encounter something that feels a little too fundamental to code yourself, you won't hesitate to write some code if you can't find a sufficient open source package.</p>\n<p><em>If you've run into challenges with your web applications, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: This example is straight from the <a href=\"https://www.npmjs.com/package/qs\">qs</a> documentation. Incidentally, qs provides an option to encode using a url safe character, which would result in readable urls, but this is not the default.</p>\n<p><a name=\"footnote2\">2</a>: It's worth noting that you might not want to use this code in production. I've written the code in a functional style for clarity and conciseness. If you have a high read volume, given that this code might potentially run on a significant portion of GET requests, it should probably be written in an imperative style that doesn't disregard performance. Even more importantly, this code does not protect against potential attackers who might try to create an arbitrarily deeply nested object or might include an unwieldy number of query parameters.</p>","fields":{"slug":"build-your-own-nested-query-string-encoder"},"frontmatter":{"title":"Build Your Own Nested Query String Encoder/Decoder","date":"2018-04-13T15:17:00.000Z"}}},{"node":{"html":"<p>I stumbled upon an <a href=\"https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\">article</a> the other day where Rob Pike implements a rudimentary regular expression engine in c. I converted his code to Javascript and added test specs so that someone can self-guide themselves through the creation of the regex engine. The specs and solution can be found in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a>. This blog post walks through my solution.</p>\n<!-- more -->\n<h2>The Problem</h2>\n<p>Our regex engine will support the following syntax:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Meaning</th>\n<th>Example</th>\n<th>matches</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>Matches the specified character literal</td>\n<td>q</td>\n<td>q</td>\n</tr>\n<tr>\n<td>*</td>\n<td>Matches 0 or more of the previous character</td>\n<td>a*</td>\n<td>\"\", a, aa, aaa</td>\n</tr>\n<tr>\n<td>?</td>\n<td>Matches 0 or 1 of the previous character</td>\n<td>a?</td>\n<td>\"\", a</td>\n</tr>\n<tr>\n<td>.</td>\n<td>Matches any character literal</td>\n<td>.</td>\n<td>a, b, c, d, e ...</td>\n</tr>\n<tr>\n<td>^</td>\n<td>Matches the start of a string</td>\n<td>^c</td>\n<td>c, ca, caa, cbb ...</td>\n</tr>\n<tr>\n<td>$</td>\n<td>Matches the end of a string</td>\n<td>a$</td>\n<td>ba, baaa, qwerta ...</td>\n</tr>\n</tbody>\n</table>\n<p>The goal is to provide a syntax robust enough to match a large portion of regex use cases with minimal code.</p>\n<h2>Matching One Character</h2>\n<p>The first step is to write a function that takes in a one character pattern and a one character text string and returns a boolean indicating if they match. A pattern of <code>.</code> is considered a wildcard and matches against any character literal.</p>\n<p>Here are some examples</p>\n<p><code>matchOne('a', 'a')</code> -> <code>true</code>\n<code>matchOne('.', 'z')</code> -> <code>true</code>\n<code>matchOne('', 'h')</code> -> <code>true</code>\n<code>matchOne('a', 'b')</code> -> <code>false</code>\n<code>matchOne('p', '')</code> -> <code>false</code></p>\n<pre><code class=\"language-js\">function matchOne(pattern, text) {\n  if (!pattern) return true; // Any text matches an empty pattern\n  if (!text) return false; // If the pattern is defined but the text is empty, there cannot be a match\n  if (pattern === '.') return true; // Any inputted text matches the wildcard\n  return pattern === text;\n}\n</code></pre>\n<h2>Matching Same Length Strings</h2>\n<p>Now we want to add support for patterns and text strings of greater length. For now, let's only consider a pattern/text pair of the same length. I happen to know that the solution lends itself very naturally to recursion, so we will use it here. We are going to want to repeatedly invoke <code>matchOne</code> on successive pairs of characters from the pattern/text combination.</p>\n<pre><code class=\"language-js\">function match(pattern, text) {\n  if (pattern === '') return true;\n  // Our base case - if the pattern is empty, any inputted text is a match\n  else return matchOne(pattern[0], text[0]) &#x26;&#x26; match(pattern.slice(1), text.slice(1));\n}\n</code></pre>\n<p>The above code advances character by character across the the pattern/text pair. It first compares <code>pattern[0]</code> to <code>text[0]</code> and then <code>pattern[1]</code> to <code>text[1]</code> and continues comparing <code>pattern[i]</code> to <code>text[i]</code> until <code>i === pattern.length - 1</code>. If they ever don't match, then we know that the pattern cannot match the text.</p>\n<p>Let's take an example. Suppose we invoke <code>match('a.c', 'abc')</code>, which returns <code>matchOne('a', 'a') &#x26;&#x26; match('.c', 'bc')</code>.</p>\n<p>If we continue evaluating these functions, we get <code>matchOne('a', 'a') &#x26;&#x26; matchOne('.', 'b') &#x26;&#x26; matchOne('c', 'c') &#x26;&#x26; match(\"\", \"\")</code>, which is just equal to <code>true &#x26;&#x26; true &#x26;&#x26; true &#x26;&#x26; true</code>, So we have a match!</p>\n<h2>The $ Character</h2>\n<p>Let's add support for the special pattern character <code>$</code> that allows us to match the end of a string. The solution simply requires adding an additional base case to the match function.</p>\n<pre><code class=\"language-js\">function match(pattern, text) {\n  if (pattern === '') return true;\n  if (pattern === '$' &#x26;&#x26; text === '') return true;\n  else return matchOne(pattern[0], text[0]) &#x26;&#x26; match(pattern.slice(1), text.slice(1));\n}\n</code></pre>\n<h2>The ^ Character</h2>\n<p>Let's add support for the special pattern character <code>^</code> that allows us to match the beginning of a string. I'm going to introduce a new function called <code>search</code>.</p>\n<pre><code class=\"language-js\">function search(pattern, text) {\n  if (pattern[0] === '^') {\n    return match(pattern.slice(1), text);\n  }\n}\n</code></pre>\n<p>This function will be the new entry point to our code. Up till this point, we were only matching patterns that began at the beginning of the text. We are simply making that more clear now by forcing the user to preface the pattern with a <code>^</code>. But how do we support patterns that appear anywhere within the text?</p>\n<h2>Matches Starting Anywhere</h2>\n<p>Currently, the following return <code>true</code></p>\n<p><code>search(\"^abc\", \"abc\")</code>\n<code>search(\"^abcd\", \"abcd\")</code></p>\n<p>But <code>search(\"bc\", \"abcd\")</code> will just return <code>undefined</code>. We want it to return <code>true</code></p>\n<p>If the user does not specify that the pattern matches the beginning of the text, then we want to search for that pattern at every possible starting point within the text. We will default to this behavior if the pattern does not begin with <code>^</code><sup><a href=\"#footnote1\">1</a></sup>.</p>\n<pre><code class=\"language-js\">function search(pattern, text) {\n  if (pattern[0] === '^') {\n    return match(pattern.slice(1), text);\n  } else {\n    // This code will run match(pattern, text.slice(index)) on every index of the text.\n    // This means that we test the pattern against every starting point of the text.\n    return text.split('').some((_, index) => {\n      return match(pattern, text.slice(index));\n    });\n  }\n}\n</code></pre>\n<h2>The ? Character</h2>\n<p>We want to be able to match 0 to 1 of the character before <code>?</code>.</p>\n<p>Here are some examples</p>\n<p><code>search(\"ab?c\", \"ac\")</code> -> <code>true</code>\n<code>search(\"ab?c\", \"abc\")</code> -> <code>true</code>\n<code>search(\"a?b?c?\", \"abc\")</code> -> <code>true</code>\n<code>search(\"a?b?c?\", \"\")</code> -> <code>true</code></p>\n<p>The first step is to modify <code>match</code> to detect when a <code>?</code> character is present and then delegate to the <code>matchQuestion</code> function, which we will define shortly.</p>\n<pre><code class=\"language-js\">function match(pattern, text) {\n  if (pattern === '') {\n    return true;\n  } else if (pattern === '$' &#x26;&#x26; text === '') {\n    return true;\n    // Notice that we are looking at pattern[1] instead of pattern[0].\n    // pattern[0] is the character to match 0 or 1 of.\n  } else if (pattern[1] === '?') {\n    return matchQuestion(pattern, text);\n  } else {\n    return matchOne(pattern[0], text[0]) &#x26;&#x26; match(pattern.slice(1), text.slice(1));\n  }\n}\n</code></pre>\n<p><code>matchQuestion</code> needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code>?</code> is not matched but the text matches the remainder of the pattern (everything after the <code>?</code>).</li>\n<li>Where the character before the <code>?</code> is matched and the rest of the text (minus the 1 matched character) matches the remainder of the pattern.</li>\n</ol>\n<p>If either of these cases is truthy, then <code>matchQuestion</code> can return <code>true</code>.</p>\n<p>Let's consider the first case. How do we check if the text matches everything in the pattern except the <code>_?</code> syntax? In order words, how do we check if the character before the <code>?</code> appears 0 times? We strip 2 characters off the pattern (the first character is the one before the <code>?</code> and the second is the <code>?</code> itself) and invoke the match function.</p>\n<pre><code class=\"language-js\">function matchQuestion(pattern, text) {\n  return match(pattern.slice(2), text);\n}\n</code></pre>\n<p>The second case is a little more challenging, but just like before, it reuses functions we've already written</p>\n<pre><code class=\"language-js\">function matchQuestion(pattern, text) {\n  if (matchOne(pattern[0], text[0]) &#x26;&#x26; match(pattern.slice(2), text.slice(1))) {\n    return true;\n  } else {\n    return match(pattern.slice(2), text);\n  }\n}\n</code></pre>\n<p>If the <code>text[0]</code> matches <code>pattern[0]</code>, and the rest of the text (minus the part that is matched by <code>matchOne</code>) matches the remainder of the pattern, then we are golden. Note that we could rewrite the code like this:</p>\n<pre><code class=\"language-js\">function matchQuestion(pattern, text) {\n  return (\n    (matchOne(pattern[0], text[0]) &#x26;&#x26; match(pattern.slice(2), text.slice(1))) ||\n    match(pattern.slice(2), text)\n  );\n}\n</code></pre>\n<p>The one thing I like about this latter approach is that the boolean OR makes it explicitly clear that there are two cases, either of which may be true.</p>\n<h2>The * Character</h2>\n<p>We want to be able to match the character before the <code>*</code> 0 or more times.</p>\n<p>All of these should return <code>true</code>.</p>\n<p><code>search(\"a*\", \"\")</code>\n<code>search(\"a*\", \"aaaaaaa\")</code>\n<code>search(\"a*b\", \"aaaaaaab\")</code></p>\n<p>Similar to what we did when supporting <code>?</code>, we wan to delegate to a <code>matchStar</code> function within our <code>match</code> function</p>\n<pre><code class=\"language-js\">function match(pattern, text) {\n  if (pattern === '') {\n    return true;\n  } else if (pattern === '$' &#x26;&#x26; text === '') {\n    return true;\n  } else if (pattern[1] === '?') {\n    return matchQuestion(pattern, text);\n  } else if (pattern[1] === '*') {\n    return matchStar(pattern, text);\n  } else {\n    return matchOne(pattern[0], text[0]) &#x26;&#x26; match(pattern.slice(1), text.slice(1));\n  }\n}\n</code></pre>\n<p><code>matchStar</code>, like <code>matchQuestion</code>, also needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code>*</code> is not matched but the text matches the remainder of the pattern (everything after the <code>*</code>).</li>\n<li>Where the character before the <code>*</code> is matched one or more times and the rest of the text matches the remainder of the pattern.</li>\n</ol>\n<p>Since there are two cases that both result in a match (0 matches OR more matches), we know that <code>matchStar</code> can be implemented with a boolean OR. Furthermore, case 1 for <code>matchStar</code> is exactly the same as it was for <code>matchQuestion</code> and can be implemented identically using <code>match(pattern.slice(2), text)</code>. That means we only need to formulate an expression that satisfies case 2.</p>\n<pre><code class=\"language-js\">function matchStar(pattern, text) {\n  return (\n    (matchOne(pattern[0], text[0]) &#x26;&#x26; match(pattern, text.slice(1))) || match(pattern.slice(2), text)\n  );\n}\n</code></pre>\n<h2>Refactoring</h2>\n<p>We can now go back and cleverly simplify <code>search</code> using a trick I learned in Peter Norvig's <a href=\"https://www.udacity.com/course/design-of-computer-programs--cs212\">class</a>.</p>\n<pre><code class=\"language-js\">function search(pattern, text) {\n  if (pattern[0] === '^') {\n    return match(pattern.slice(1), text);\n  } else {\n    return match('.*' + pattern, text);\n  }\n}\n</code></pre>\n<p>We use the <code>*</code> character itself to allow for the pattern to appear anywhere in the string. The prepended <code>.*</code> says that any number of any character can appear before the pattern we wish to match.</p>\n<h2>Conclusion</h2>\n<p>It's remarkable how simple and elegant the code for such a sophisticated and generalized program can be. The full source is available in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a></p>\n<p>Here is a <a href=\"https://nickdrane.com/regex-and-automated-test-fuzzing/\">follow up article</a> where I fuzz test the regex engine.</p>\n<p><em>If you work at a company using javascript, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: There is a small bug in this code that I'm choosing to ignore. We don't account for the case that text is an empty string. Currently when <code>text === ''</code>, <code>text.split(\"\")</code> will return <code>[]</code> and will not appropriately call <code>match</code>.</p>","fields":{"slug":"build-your-own-regex"},"frontmatter":{"title":"Build a Regex Engine in Less than 40 Lines of Code","date":"2017-11-28T00:00:00.000Z"}}},{"node":{"html":"<p>I posted my article <a href=\"https://nickdrane.com/build-your-own-regex/\">Build Your Own Regex Engine</a> on Reddit the other day, and one of the commenters claimed that the implementation should be trivial to break. Since I had already tested my program against a customized suite of tests, the remark got me thinking about how I could further increase my confidence in the correctness of my program. One extremely low cost however effective strategy for identifying faults in software is known as fuzzing.</p>\n<!-- more -->\n<h2>What is Fuzzing?</h2>\n<p>Fuzzing is a automated testing technique where a program is provided a series of invalid or randomly generated inputs. If we were testing an HTTP API, we might send randomized combinations of query parameters and ensure that our server always returns a 2xx status code. Since Javascript comes with a regular expression engine, my fuzzer asserts that given the same random input, both engine's return the same output.</p>\n<h2>Specifying the Grammar</h2>\n<p>The first step is to specify the grammar that our regex engine supports.</p>\n<pre><code class=\"language-js\">const lowercase = 'abcdefghijklmnopqrstuvwxyz'.split('');\nconst uppercase = lowercase.map(letter => letter.toUpperCase());\nconst special = ['?', '*', '.'];\nconst regexGrammar = special.concat(lowercase, uppercase);\n</code></pre>\n<p>You might notice we skipped the <code>^</code> and <code>$</code> characters. More on these in a little bit.</p>\n<h2>Generated Valid Regular Expressions</h2>\n<p>We want to write a function <code>generateRegex</code> that will select <code>n</code> random characters from the <code>regexGrammar</code> and concatenate them together into a string. This string will be used to create a test regex.</p>\n<p>Here are three possible returns values of <code>generateRegex</code>:</p>\n<ol>\n<li><code>.AnrQ?QNLQX.syBsOcJlbJZd</code></li>\n<li><code>.LkuZ?Ynj</code></li>\n<li><code>.UN?eiyddhXvyNj</code></li>\n</ol>\n<pre><code class=\"language-js\">function generateRegex(n) {\n  let regexString = new Array(n)\n    .fill(0)\n    .map(chooseOne)\n    .join('');\n\n  return regexString;\n}\n\n// Pick one element randomly from the grammar and return it\nfunction chooseOne() {\n  return regexGrammar[Math.floor(Math.random() * regexGrammar.length)];\n}\n</code></pre>\n<h2>Removing Invalid Regex Strings</h2>\n<p>My regex engine only deals with a very small subset of available regex syntax, and furthermore, it does not contain any error handling. What happens if <code>generateRegex</code> returns the pattern <code>**</code> or <code>^*</code>? My regex engine was never designed to handle these inputs, though they are possible outputs of <code>generateRegex</code>. We need to make a choice about how to handle these expressions. Since the primary goal of my regex engine is accessibility and simplicity of implementation, I'm not about to begin supporting these edge cases. That means my fuzzer should not generate them either.</p>\n<p>One solution to determine if a given regex string is valid is to specify my regex engine's allowable grammar in <a href=\"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form\">BNF</a>. BNF is a formal notation for specifying the syntax of a language. Given this BNF notation, I could ask another program if the randomly generated regex string can be created using my BNF specification. This sounds like a little more work than I want, however, since the invalid cases can simply be manually enumerated and filtered.</p>\n<pre><code class=\"language-js\">function validRegex(regexString) {\n  return (\n    // None of the following sequences are properly\n    // defined by my regex engine\n    regexString.indexOf('**') === -1 &#x26;&#x26;\n    regexString.indexOf('??') === -1 &#x26;&#x26;\n    regexString.indexOf('*?') === -1 &#x26;&#x26;\n    regexString.indexOf('?*') === -1 &#x26;&#x26;\n    regexString.indexOf('^?') === -1 &#x26;&#x26;\n    regexString.indexOf('^*') === -1 &#x26;&#x26;\n    !regexString.startsWith('*') &#x26;&#x26;\n    !regexString.startsWith('?')\n  );\n}\n\nfunction generateRegex(n) {\n  let regexString = new Array(n)\n    .fill(0)\n    .map(chooseOne)\n    .join('');\n\n  // If the generated string is valid, return it\n  if (validRegex(regexString)) {\n    return regexString;\n    // Otherwise generate a new string and return that\n  } else {\n    return generateRegexString(n);\n  }\n}\n</code></pre>\n<p>One more modification to <code>generateRegex</code> is necessary to support <code>^</code> and <code>$</code>, and then we are basically done.</p>\n<pre><code class=\"language-js\">function generateRegex(n) {\n  ...\n  // We need to ensure that '^' and '$' only go at the beginning\n  // and the end of the string, respectively.\n  // Give each a 10% probability of appearing in a string\n  if (Math.random() &#x3C; 0.1) regexString = \"^\" + regexString;\n  if (Math.random() &#x3C; 0.1) regexString = regexString + \"$\";\n  ...\n}\n</code></pre>\n<h2>Comparing Regex Implementations</h2>\n<p>All that is required now is to repeatedly invoke <code>generateRegex</code> a fixed number of times and then compare the output of the native JS implementation with the output of my implementation.</p>\n<pre><code class=\"language-js\">// The corpus is the string of text we are matching the pattern against.\n// I used a segment of Gulliver's Travels from Project Gutenberg.\nfunction fuzzer(totalTests, corpus) {\n  const maxRegexLength = 50; // max will actually be 50 - 1\n  let testsRun = 0;\n  while (testsRun &#x3C; totalTests) {\n    const regexLength = getRandomInt(1, maxRegexLength);\n    const regexString = generateRegexString(regexLength);\n    const testRegex = new RegExp(regexString);\n    try {\n      assert.equal(testRegex.test(corpus), myRegexEngine(regexString, corpus));\n    } catch (err) {\n      console.log(testRegex);\n    }\n    testsRun++;\n  }\n}\n\n// Thank you Mozzila :)\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n</code></pre>\n<h2>Results</h2>\n<p>I ran my fuzzer for a couple million randomly generated cases and ended up learning two things about my regex engine.</p>\n<ol>\n<li>\n<p>My implementation fails extraordinarily with longer texts. I knew recursion would be a problem for any practical regex implementation (at least without <a href=\"https://en.wikipedia.org/wiki/Tail_call\">tail calls</a>) and would cause stack overflows, but I didn't expect it to fail with texts that were only a couple thousand words. I think this is because I make liberal use of backtracking algorithms in <code>matchQuestion</code> and <code>matchStar</code>. Since I was forced to test with a relatively short input text, it makes sense to use multiple text inputs to increase the probability of discovering an error.</p>\n</li>\n<li>\n<p>My implementation treats the <code>.</code> character differently than the native implementation. In the RegExp implementation, <code>.</code> will not match various line terminators (<code>\\n</code>, <code>\\r</code>, <code>\\u2028</code> or <code>\\u2029</code>). My implementation does.</p>\n</li>\n</ol>\n<h2>Conclusion</h2>\n<p>The biggest takeaway is that fuzzing is an simple and inexpensive way to enumerate enormous sets of inputs and identify bugs in your software. This fuzzer took less than an hour to write.</p>\n<p>But remember, this fuzzer's blessing of a couple million input combinations <strong>does not</strong> verify the correctness of my program. Not even close. A fuzzer is a tool to identify potential errors. Unless you enumerate all possible inputs (completely impossible in this case where they are infinite), you are not guaranteed your program is error free.</p>","fields":{"slug":"regex-and-automated-test-fuzzing"},"frontmatter":{"title":"Regex And Automated Test Fuzzing","date":"2017-12-06T00:00:00.000Z"}}},{"node":{"html":"<p>I'm currently contracted to create a web service using some data from a third party Angular application. I worked off a proof of concept codebase that used Chrome's new <a href=\"https://github.com/GoogleChrome/puppeteer\">Puppeteer</a> API to scrape this site. I strongly regret not starting from scratch.</p>\n<!-- more -->\n<h2>What is Puppeteer?</h2>\n<p>Puppeteer is a Node API that allows you to control Google's headless Chrome browser. Imagine a version of your browser that can send and receive requests but has no GUI. It works in the background, performing actions as instructed by an API. This makes Puppeteer great for end to end testing a web application. You can truly simulate the user experience, typing where they type and clicking where they click. Another use case for Puppeteer is web scraping a single page web application. Let's explore how this might work.</p>\n<h2>A Simple Example</h2>\n<p>For any Puppeteer project, the first task is to create an instance of the headless browser.</p>\n<pre><code class=\"language-js\">const browser = await puppeteer.launch();\n\n// We will use this page instance and it's API frequently\nconst page = await this.browser.newPage();\n</code></pre>\n<p>After that's done, it's trivial to navigate to and begin interacting with a webpage. Let's suppose I want to fill out a login form and submit an authentication request to a website. In an ideal situation, it looks like this.</p>\n<pre><code class=\"language-js\">// Navigate to the website\nawait page.goto('https://website/login');\n\n// Provide the selector of an input box and the content to type\nawait page.type('input#username', CREDENTIALS.username);\nawait page.type('input#password', CREDENTIALS.password);\nawait page.click('button#login'); // Click the login button\n\n// Wait until the screen changes and a node matching\n// the selector #logged-in-successfully appears,\n// at which point we know the login was successful\nawait page.waitForSelector('#logged-in-successfully');\n</code></pre>\n<p>We just successfully filled out a form, submitted an HTTP request containing our form data, and waited for the page to change upon successful login. This is where Puppeteer shines. Let's look at a more complicated example.</p>\n<h2>A More Complicated Example</h2>\n<p>Today's web uses a mix of simple html driven forms as well as more complicated, javascript-driven forms, rich with functionality like autocomplete and dynamic dropdown menus. I'm sure you've used a calendar date picker. These components each need to be treated differently.</p>\n<p>Here is a modified version of some code I wrote for my client:</p>\n<pre><code class=\"language-js\">// The form inputs I want to fill out\n// and their corresponding selectors\nconst fields = {\n  type: 'input[ng-model=\"type\"]',\n  origin: 'input[ng-model=\"origin\"]',\n  destination: 'input[ng-model=\"destination\"]',\n  date: 'input[ng-model=\"date\"]'\n};\n\nfunction search(searchParams) {\n  const page = await this.browser.newPage();\n  await page.goto(\"https://website/search\");\n\n  // We need to click a button to make the search form\n  // appear, but first make sure that button has rendered\n  await page.waitForSelector(\".new-search\");\n  await page.click(\".new-search\");\n\n  // Fill out the form\n  for (const field of Object.keys(fields)) {\n    if (searchParams[field]) {\n      const selector = fields[field];\n\n      // We want to make sure each DOM node is rendered\n      // before we try to do anything to it.\n      await page.waitForSelector(selector);\n\n      // Some inputs need to be focused first for page.type to work\n      // Might as well focus on all of them\n      await page.focus(selector);\n\n      // Some inputs have defaults that need to be\n      // erased before typing your own input\n      if (field === \"date\" || field === \"type\") {\n        // This is a helper function I wrote\n        await deleteInput(page, selector);\n      }\n\n      await page.type(selector, searchParams[field]);\n\n      // This field won't register the typed data\n      // until Enter is pressed.\n      // This is because the 'type' field is a dropdown\n      // where one of a specific set of inputs must be clicked.\n      if (field === \"type\") {\n        await page.keyboard.press(\"Enter\");\n      }\n    }\n  }\n}\n</code></pre>\n<p>The first thing to notice is that the code is messy and full of weird exceptions. To make matters worse, it doesn't always work.</p>\n<h2>Brace Yourself for Flaky Behavior</h2>\n<p>Working with Puppeteer was an exercise in guesswork. Given the same inputs, Puppeteer did not always produce the same outputs<sup><a href=\"#footnote1\">1</a></sup>. This flaky behavior made the project unnecessarily challenging and required me to do additional engineering to increase reliability, which was frustrating considering the alternative.</p>\n<h2>Puppeteer Was Completely Unnecessary</h2>\n<p>Puppeteer has a API that allows you to execute arbitrary code against the DOM. After scraping form results with this API and getting the same flaky behavior described above, I ditched the approach and started grabbing data from the HTTP response objects themselves. Below is a primitive version of some code I wrote to do this.</p>\n<pre><code class=\"language-js\">waitForUrl(page, urlPrefix) {\n  return new Promise(resolve => {\n    page.on(\"response\", res => {\n      if (!res.url.startsWith(urlPrefix)) {\n        return;\n      }\n      resolve(res.json());\n    };\n  });\n}\n</code></pre>\n<p>The page passed into this function is the same page object created above by the Puppeteer API. Among other things, it is an event emitter that allows me to listen for any HTTP responses. I've essentially created a promise that resolves to the response body of a particular ajax request. This allowed me interact with the server API directly and removed the DOM from the data retrieval process, greatly reducing the chance for flaky behavior. But that begs the question, why use Puppeteer at all? Why not simply send http requests to the server API manually and ditch the complicated form submission code above That's how I should have started all along.</p>\n<h2>When is Puppeteer the Right Solution</h2>\n<p>I can only think of a single scenario where using Puppeteer for scraping is superior to the alternative: if the information you want is generated using a combination of API data and javascript code. After all, you would have no other way to simulate the javascript code without rewriting it.</p>\n<p>If, however, all you need is data from the server, go the simple route and hit the API with an HTTP library like <a href=\"https://github.com/axios/axios\">axios</a> or <a href=\"https://github.com/request/request\">request</a>. If you are scraping a server side rendered application, you can combine one of the aforementioned tools with <a href=\"https://github.com/cheeriojs/cheerio\">Cheerio</a>, giving you a far more user friendly DOM manipulation API than that offered my Puppeteer.</p>\n<p><em>If you need help with webscraping or puppeteer, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please contact me for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: You might be curious why Puppeteer exhibited flaky behavior. One issue that I ran into was animations. I might attempt to click a DOM node, but if the animation had not finished, the click would not register. In essence, it would appear as if the click had worked, but once the animation finished, the DOM would reset itself, undoing my click. I think this is simply how Angular's digest loop reacted to a click at an unexpected time. Unfortunately, Puppeteer provides no functionality to determine when an animation has finished (after all, how would it!). I tried a couple solutions. One entailed a sleep function to wait a couple hundred milliseconds for the animation to finish, but it simply exacerbated the flaky behavior. A second involved executing the click only once the DOM node had a particular class that indicated the animation had finished. At one point, I even tried to disable all animations across the website. All these solutions were half-baked.</p>","fields":{"slug":"scraping-the-web-with-puppeteer-lessons-learned"},"frontmatter":{"title":"Scraping the Web with Puppeteer: Lessons Learned","date":"2017-12-09T15:35:13.000Z"}}},{"node":{"html":"<p>In my article <a href=\"/hexo-vs-gatsbyjs-comparing-nodejs-static-site-generators\">comparing Gatsby to Hexo</a>, I talked about my experience switching writing this blog using <a href=\"https://hexo.io/\">Hexo</a> and then later using <a href=\"https://www.gatsbyjs.org/\">Gatsby</a>. In the process, the size of my initial page ballooned 5x.</p>\n<p>In retrospect, I did not fully understand the abstraction that Gatsby provides. Fortunately, if you follow a simple rule of thumb, you can avoid bloating your network requests and maintain an ultra-performant website.</p>\n<!-- more -->\n<h2>Process as Much Data with GraphQL as Possible</h2>\n<p>If you walk away learning nothing else, this is the most important point.</p>\n<p>When you build your website, Gatsby will effectively run all of the GraphQL queries needed to load each page and save the resulting JSON. When you visit a given page on your site, requests will be made for these JSON payloads, completely unmodified.</p>\n<p>I originally thought that <code>gatsby build</code> would combine my react components and GraphQL requests, transforming them into HTML, resulting in a website that sends strictly HTML over the wire. This is not the case (unless the client has Javascript disabled)! Here a small piece of the JSON payload for the homepage of my website:</p>\n<p><img src=\"./json-payload.png\" alt=\"JSON payload for the homepage website\"></p>\n<p>So what does this mean for you?</p>\n<ol>\n<li>\n<p>Do not request data that you don't need. This rule of thumb is obvious in a typical Single Page Application, but it applies here too. We want to minimize the size of our HTTP responses.</p>\n</li>\n<li>\n<p>If you can do <a href=\"https://www.gatsbyjs.org/docs/graphql-reference/\">filtering, sorting, or limiting in GraphQL</a>, do it there instead of at the application layer.</p>\n</li>\n</ol>\n<p>The second points bears explanation. Here are two functionally equivalent chunks of code to grab the html of the 5 most recent posts.</p>\n<h3>Post-Processing GraphQL results with Javascript</h3>\n<pre><code class=\"language-graphql\">{\n  allMarkdownRemark {\n    edges {\n      node {\n        html\n        frontmatter {\n          date\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">// Assuming data is the result of the above GraphQL query\nconst mostRecentPosts = data.allMarkdownRemark.edges\n  .map(edge => edge.node)\n  // Sort each post by dates in reverse chronological order\n  .sort((node1, node2) => {\n    const a = new Date(node1.frontmatter.date);\n    const b = new Date(node2.frontmatter.date);\n    return a > b ? -1 : a &#x3C; b ? 1 : 0;\n  })\n  // Grab the 5 most recent ones\n  .slice(0, 5);\n</code></pre>\n<h3>Everything in GraphQL</h3>\n<pre><code class=\"language-graphql\">{\n  allMarkdownRemark(limit: 5, sort: { fields: [frontmatter___date], order: DESC }) {\n    edges {\n      node {\n        html\n      }\n    }\n  }\n}\n</code></pre>\n<p>I was initially uncomfortable with GraphQL and coded everything in the former style, making broad GraphQL queries and later performing additional processing using Javascript. This strategy has numerous problems.</p>\n<ol>\n<li>\n<p>As I mentioned above, instead of grabbing the html of just 5 posts, we are grabbing it for every post. This translates directly into what is sent over the wire when someone loads the page, bloating the site. To compound the problem, the performance hit grows with every single post we add to our site.</p>\n</li>\n<li>\n<p>Not only am I grabbing more posts than I need, every post includes additional information. Notice in the second example that we don't need to query the date because sorting is handled by GraphQL.</p>\n</li>\n<li>\n<p>Lastly, the second example is so much more readable</p>\n</li>\n</ol>\n<h2>Conclusion</h2>\n<p>Gatsby is a powerful static site generator, though it's not immediately obvious how your code influences the resulting site's performance. You can make great strides, however, if you always offload as much work onto GraphQL as possible.</p>","fields":{"slug":"a-performance-guide-to-gatsbyjs"},"frontmatter":{"title":"One Simple Performance Tip to Optimize GatsbyJS Static Sites","date":"2018-12-13T00:00:00.000Z"}}},{"node":{"html":"<p>There are two major <a href=\"https://davidwalsh.name/introduction-static-site-generators\">static site generators</a> in the Javascript ecosystem: the incumbent <a href=\"https://hexo.io\">Hexo</a> and the up-and-coming <a href=\"https://www.gatsbyjs.org/\">Gatsby</a>. This site was first built with Hexo, but I've recently switched to Gatsby. Let's talk about why.</p>\n<!-- more -->\n<h2>Different Products</h2>\n<p>First, let's talk high level. Hexo and Gatsby both generate static websites, but at their hearts, they are very different products. Hexo is a blog generator; Gatsby is a generalized static site generator. Let me elaborate.</p>\n<h3>Hexo</h3>\n<p>Hexo specializes in creating markup (be it <a href=\"https://en.wikipedia.org/wiki/Markdown\">markdown</a> or <a href=\"https://en.wikipedia.org/wiki/ReStructuredText\">reStructuredText</a>) driven blogs. This specialization comes with tradeoffs. It's simple to get a blog up and running, but if you want to do anything more complicated, it ranges from challenging to impossible. This limitation might not restrict you, however.</p>\n<h3>Gatsby</h3>\n<p>Gatsby epitomizes customizability and allows for the creation of arbitrarily complex static sites, ranging from simple blogs to fully featured e-commerce websites. It provides <a href=\"https://www.gatsbyjs.org/docs/node-apis/\">an API</a> for you to build and query a <a href=\"https://graphql.org/\">GraphQL</a> API composed of data from a variety of sources. You can then dynamically compose your static website based on the results of your queries. Gatsby trades power for complexity, requiring users to learn some new tools to leverage its capabilities.</p>\n<p>Let's get into the nitty gritty details.</p>\n<h2>Getting Up and Running</h2>\n<p>Both platforms make it easy to get from <code>yarn install</code> to writing blog articles, though Hexo definitely excels in this regard.</p>\n<h3>Hexo</h3>\n<p>With Hexo, I was able to install the application, run a couple <a href=\"https://hexo.io/docs/setup\">configuration commands</a>, pick a <a href=\"https://hexo.io/themes/index.html\">theme from their website</a>, and start writing.</p>\n<h3>Gatsby</h3>\n<p>Gatsby's sheer volume of documentation made the setup process slightly more challenging, though hardly difficult. There are two places you can start: their <a href=\"https://www.gatsbyjs.org/docs/\">getting started page</a> or <a href=\"https://www.gatsbyjs.org/tutorial/\">their tutorial</a>. The former will link you to their <a href=\"https://www.gatsbyjs.org/starters/?v=2\">starter library</a> and will help you get a server up and running. The latter will teach you how to customize your website.</p>\n<h2>Developer Experience</h2>\n<p>Hexo does not provide any tooling out-of-the-box, and your experience is largely determined by your theme. Gatsby, in contrast, optimizes for developer productivity.</p>\n<h3>Hexo</h3>\n<p>When I began with Hexo, I picked a theme called <a href=\"https://github.com/hmybmny/hexo-theme-concise\">Concise</a>, and my experience mostly stems from customizing this theme. Hexo originally only supported a dated templating language called <a href=\"https://ejs.co/\">EJS</a>, and most themes including Concise use it. Here is some sample code from Concise.</p>\n<p><img src=\"concise-code.png\" alt=\"Code sample from Concise\"></p>\n<p>Apart from the obvious readability problems, the syntax is challenging to edit and thus is at odds with application discoverability. It makes trivial exercises like console logging error-prone. Furthermore, the syntax is incompatible with the modern formatting tool, <a href=\"https://prettier.io/\">Prettier</a>.</p>\n<p>Today Hexo supports other templating languages, but it's a shame so many themes are tightly coupled to such an unergonomic tool.</p>\n<h3>Gatsby</h3>\n<p>Gatsby emphasizes the developer experience, using <a href=\"https://reactjs.org/\">React</a> and <a href=\"https://graphql.org/\">GraphQL</a> as the foundation for every Gatsby application. These tools and their ecosystems were immediate productivity boosters for me, though they do have a non-trivial learning curve. Fortunately, the Gatsby docs assume no prior knowledge, and realistically, you only need minimal understanding to be productive.</p>\n<p>The aforementioned <a href=\"https://www.gatsbyjs.org/docs/node-apis/\">Gatsby API</a>, which is used the define the pages of your site (among other things), also requires study to understand. It's powerful but lacks detailed documentation. Use cases for the various methods and hooks are scattered throughout the docs, though I was able to supplement the documentation with blogs/tutorials such that learning the API was manageable.</p>\n<p>Gatsby also automatically configures numerous developer tools to optimize your productivity. For example, <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> (more on this later) allows you to explore your data sources, Prettier ensures that your code remains consistently formatted, hot-reloading updates your UI without refreshing, and <a href=\"https://eslint.org/\">ESlint</a> catches your mistakes.</p>\n<p>Behind the scenes, Gatsby configures <a href=\"https://webpack.js.org/\">webpack</a> for you, abstracting away the most challenging parts of the React ecosystem. It goes to extra mile and things like service workers, inlining critical CSS, and CSS modules are automatic or a plugin away. Here is an exhaustive list of its <a href=\"https://www.gatsbyjs.org/features/\">features</a>.</p>\n<h2>Documentation</h2>\n<p>Documentation can make or break a developer's experience, and Hexo and Gatsby approach documentation very differently.</p>\n<h3>Hexo</h3>\n<p>Hexo does a great job of ensuring you need to read as little text as possible to get a blog up and running. If you want to customize your blog, however, the documentation's previously appreciated brevity shows it's warts. I would often read a page and have no idea what I was looking at, even when it was exactly what I needed.</p>\n<p>For example, if you want to customize your theme, you will need to know what variables Hexo injects into your template engine's rendering system. This <a href=\"https://hexo.io/docs/variables.html\">site</a> provides the details but doesn't provide an overview explaining its purpose.</p>\n<p>I should provide one qualifying statement. Hexo augments its documentation with video tutorials. I never noticed them until I chose to write this article, but perhaps they provide the detail I previously yearned for.</p>\n<h3>Gatsby</h3>\n<p>Gatsby's documentation is thoughtful, well-organized, and detailed. It has everything from <a href=\"https://www.gatsbyjs.org/tutorial/\">tutorials</a> to deep dives <a href=\"https://www.gatsbyjs.org/docs/adding-images-fonts-files/\">1</a>, <a href=\"https://www.gatsbyjs.org/docs/creating-and-modifying-pages/\">2</a>, <a href=\"https://www.gatsbyjs.org/docs/styling/\">3</a>. It even has pages explaining and justifying <a href=\"https://www.gatsbyjs.org/docs/behind-the-scenes/\">architecture and implementation details</a>. And to top all this off, it has a <a href=\"https://www.gatsbyjs.org/docs/gatsby-style-guide/\">style guide</a> to ensure readability.</p>\n<p>With all this said, there are still <a href=\"https://www.gatsbyjs.org/docs/dropping-images-into-static-folders/\">placeholder pages</a>, though I never found myself unable to answer a question about their system.</p>\n<h2>API Discoverability</h2>\n<p>A static site generator needs to make it easy to edit your website. One of the first requirements to editing your site is understanding the data structures the static site generator makes available to you.</p>\n<h3>Hexo</h3>\n<p>Hexo documents its data structures in the <a href=\"https://hexo.io/docs/variables.html\">link mentioned above</a>. The page references many key topics but never elaborates. I remember agonizing over providing support for both pagination and article excerpts.</p>\n<p>The page seems to hint that the next and previous blog posts are available from their API, though the fields were always <code>undefined</code>. I never figured out why.</p>\n<p>It also suggests excerpts are available. It wasn't until I discovered this <a href=\"https://github.com/hexojs/hexo/issues/1143\">GitHub issue</a> that I learned it's required to add the comment <code>&#x3C;!-- more --></code> to each post to ensure that this excerpt is populated. This feature is otherwise undocumented.</p>\n<p>Moreover, EJS prevents rapid code changes and thus data structure exploration, exacerbating these documentation problems.</p>\n<h3>Gatsby</h3>\n<p>Gatsby solves the problem of discoverability with <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a>. It automatically spins up a GraphiQL server which allows you to interactively browse your data. Here is a simple example that queries article excerpts and titles:</p>\n<p><img src=\"graphiql.png\" alt=\"GraphiQL Example\"></p>\n<p>You can see the query on the left, the results in the middle, and interactive schema documentation on the right. To top it all off, the environment provides autocomplete and errors messages.</p>\n<p>The contrast with Hexo's variable page is stark.</p>\n<h2>Community</h2>\n<p>A large and active community makes on-boarding easier. It means more people have run into the same problems, which often translates into more tutorials and more stack overflow questions answered. Community quality can heavily influence a developer's experience.</p>\n<h3>Hexo</h3>\n<p>Hexo is the most popular static site generator in the JS ecosystem, though I did not feel like the this made solving problems easier. I had numerous question I had to answer by consulting the source code.</p>\n<p>I think my experiences stems from the fact that Hexo's user base is largely Chinese. Unless your bilingual, this makes potentially helpful documentation and conversations inaccessible.</p>\n<h3>Gatsby</h3>\n<p>I've been blown away by the quality of Gatsby's community so far.</p>\n<p>The maintainers have written tutorials about how to migrate from other blogging platforms, and dedicated community members write about solving their own problems.</p>\n<p>I've also been impressed as a contributor to Gatsby. I ran into an issue where excerpts only rendered in plain text, not HTML. I opened a <a href=\"https://github.com/gatsbyjs/gatsby/pull/9716\">PR</a> to fix this problem and received prompt and thoughtful replies.</p>\n<h2>Plugin Ecosystem</h2>\n<h3>Hexo</h3>\n<p>Hexo has a <a href=\"https://hexo.io/plugins/index.html\">plugin page</a> detailing links to everything from markdown parsers to image and css optimizers. There are 277 plugins available, and I never ran into a situation where I couldn't find a plugin to do what I needed.</p>\n<h3>Gatsby</h3>\n<p>Gatsby has a <a href=\"https://hexo.io/plugins/index.html\">plugin search system</a> with twice as many plugins - 550 to be exact - available to date, though it's not clear to me how much additional value this offers over Hexo.</p>\n<p>On a side note, I appreciated that Gatsby sorts their plugin search results based on number of downloads. This primitive but effective metric makes it easier to evaluate the quality of a given plugin.</p>\n<h2>Performance</h2>\n<p>There are two types of performance relevant to this discussion: the speed of the static site generator itself, and the speed of the website it produces.</p>\n<p>If a static site generator is slow to render your changes, it slows down your development speed. Fortunately, both Hexo and Gatsby refresh changes without perceptible delay.</p>\n<p>The speed of the sites these tools produce varies quite drastically.</p>\n<h3>Hexo</h3>\n<p>With Hexo, the speed of your static site will be completely coupled to your theme. Your theme might load tons of unnecessary javascript; it also might not use any.</p>\n<p>The most important point here is that Hexo adds absolutely no overhead to your website. It introduces no additional dependencies into your built project. If you want a pure static site without any javascript, you can create that. If you want no page to exceed 40kb, that's entirely doable.</p>\n<h3>Gatsby</h3>\n<p>Gatsby takes a much different approach.</p>\n<p>For starters, it introduces a javascript dependency into your web site, clocking in around 65kb. This dependency is larger than any single page on my original Hexo website! Fortunately, Gatsby websites will continue to work on browsers with javascript disabled.</p>\n<p>Gatsby either automatically or through plugins applies numerous performance tricks to every website. To explain a few:</p>\n<ol>\n<li>\n<p>When you reference a style sheet using a <code>link</code> tag, the page blocks rendering until the entire roundtrip server request is complete. Gatsby circumvents this problem by inlining critical CSS into your HTML.</p>\n</li>\n<li>\n<p>When you visit a page, once it has finished loading, Gatsby will begin loading every page you can reach from the page you're on. This technique is known as prefetching and makes subsequent page loads fast.</p>\n</li>\n<li>\n<p>Gatsby does per route code/data splitting. This means that when you go to a page, Gatsby ensures that only the data and javascript needed to render that page is passed over the network.</p>\n</li>\n<li>\n<p>Gatsby uses <a href=\"https://developers.google.com/web/fundamentals/primers/service-workers/\">service workers</a> via <a href=\"https://www.gatsbyjs.org/packages/gatsby-plugin-offline/\">gatsby-plugin-offline</a> to cache all the pages you download. This allows subsequent requests for those pages to hit the cache instead of the network. It also allow for users to browse your page offline later.</p>\n</li>\n<li>\n<p><a href=\"https://www.gatsbyjs.org/packages/gatsby-image/\">Gatsby Image</a> preprocesses and calibrates images for various screen sizes. This ensures that high resolution screens get high resolution images and vice-versa, resulting in significant bandwidth savings for smaller screens.</p>\n</li>\n</ol>\n<p>All of these performance abstractions don't come without a cost. I think my experience was quite telling. When I finished my Hexo website, the main page was ~40kb, whereas when I finished my Gatsby website, the main page was ~134kb, though it's a little difficult to be precise, which brings me to my next point.</p>\n<p>Optimization is initially challenging and opaque with Gatsby. When I started, not only did I have no idea my final site would contain Javascript, I had no idea what would influence its performance.</p>\n<p>It turns out that everything I returned from my GraphQL queries is loaded at runtime, regardless of whether the site used it. I didn't understand this going in, and it influences <a href=\"/a-performance-guide-to-gatsbyjs\">how I use Gatsby today</a>. This contrasts with Hexo where the performance consequences of my development choices were obvious.</p>\n<h2>Conclusion</h2>\n<p>Hexo are Gatsby are different products. If you're interested in picking a theme, spinning up a blog, and perhaps tweaking it, Hexo might be a simpler choice. If, however, you want flexibility and a productive developer experience, Gatsby overshadows Hexo in nearly every way.</p>","fields":{"slug":"hexo-vs-gatsbyjs-comparing-nodejs-static-site-generators"},"frontmatter":{"title":"A Deep Dive into Javascript Static Site Generators: Gatsby vs. Hexo","date":"2018-11-24T00:00:00.000Z"}}}]}},"pageContext":{"category":"Javascript"}}