{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>I stumbled upon an <a href=\"https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\">article</a> the other day where Rob Pike implements a rudimentary regular expression engine in c. I converted his code to Javascript and added test specs so that someone can self-guide themselves through the creation of the regex engine. The specs and solution can be found in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a>. This blog post walks through my solution.</p>\n<!-- more -->\n<h2>The Problem</h2>\n<p>Our regex engine will support the following syntax:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Meaning</th>\n<th>Example</th>\n<th>matches</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>Matches the specified character literal</td>\n<td>q</td>\n<td>q</td>\n</tr>\n<tr>\n<td>*</td>\n<td>Matches 0 or more of the previous character</td>\n<td>a*</td>\n<td>\"\", a, aa, aaa</td>\n</tr>\n<tr>\n<td>?</td>\n<td>Matches 0 or 1 of the previous character</td>\n<td>a?</td>\n<td>\"\", a</td>\n</tr>\n<tr>\n<td>.</td>\n<td>Matches any character literal</td>\n<td>.</td>\n<td>a, b, c, d, e ...</td>\n</tr>\n<tr>\n<td>^</td>\n<td>Matches the start of a string</td>\n<td>^c</td>\n<td>c, ca, caa, cbb ...</td>\n</tr>\n<tr>\n<td>$</td>\n<td>Matches the end of a string</td>\n<td>a$</td>\n<td>ba, baaa, qwerta ...</td>\n</tr>\n</tbody>\n</table>\n<p>The goal is to provide a syntax robust enough to match a large portion of regex use cases with minimal code.</p>\n<h2>Matching One Character</h2>\n<p>The first step is to write a function that takes in a one character pattern and a one character text string and returns a boolean indicating if they match. A pattern of <code class=\"language-text\">.</code> is considered a wildcard and matches against any character literal.</p>\n<p>Here are some examples</p>\n<p><code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">matchOne(&#39;.&#39;, &#39;z&#39;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">matchOne(&#39;&#39;, &#39;h&#39;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">matchOne(&#39;a&#39;, &#39;b&#39;)</code> -> <code class=\"language-text\">false</code>\n<code class=\"language-text\">matchOne(&#39;p&#39;, &#39;&#39;)</code> -> <code class=\"language-text\">false</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pattern<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Any text matches an empty pattern</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>text<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// If the pattern is defined but the text is empty, there cannot be a match</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Any inputted text matches the wildcard</span>\n  <span class=\"token keyword\">return</span> pattern <span class=\"token operator\">===</span> text<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Matching Same Length Strings</h2>\n<p>Now we want to add support for patterns and text strings of greater length. For now, let's only consider a pattern/text pair of the same length. I happen to know that the solution lends itself very naturally to recursion, so we will use it here. We are going to want to repeatedly invoke <code class=\"language-text\">matchOne</code> on successive pairs of characters from the pattern/text combination.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// Our base case - if the pattern is empty, any inputted text is a match</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The above code advances character by character across the the pattern/text pair. It first compares <code class=\"language-text\">pattern[0]</code> to <code class=\"language-text\">text[0]</code> and then <code class=\"language-text\">pattern[1]</code> to <code class=\"language-text\">text[1]</code> and continues comparing <code class=\"language-text\">pattern[i]</code> to <code class=\"language-text\">text[i]</code> until <code class=\"language-text\">i === pattern.length - 1</code>. If they ever don't match, then we know that the pattern cannot match the text.</p>\n<p>Let's take an example. Suppose we invoke <code class=\"language-text\">match(&#39;a.c&#39;, &#39;abc&#39;)</code>, which returns <code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; match(&#39;.c&#39;, &#39;bc&#39;)</code>.</p>\n<p>If we continue evaluating these functions, we get <code class=\"language-text\">matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; matchOne(&#39;.&#39;, &#39;b&#39;) &amp;&amp; matchOne(&#39;c&#39;, &#39;c&#39;) &amp;&amp; match(&quot;&quot;, &quot;&quot;)</code>, which is just equal to <code class=\"language-text\">true &amp;&amp; true &amp;&amp; true &amp;&amp; true</code>, So we have a match!</p>\n<h2>The $ Character</h2>\n<p>Let's add support for the special pattern character <code class=\"language-text\">$</code> that allows us to match the end of a string. The solution simply requires adding an additional base case to the match function.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'$'</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>The ^ Character</h2>\n<p>Let's add support for the special pattern character <code class=\"language-text\">^</code> that allows us to match the beginning of a string. I'm going to introduce a new function called <code class=\"language-text\">search</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'^'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This function will be the new entry point to our code. Up till this point, we were only matching patterns that began at the beginning of the text. We are simply making that more clear now by forcing the user to preface the pattern with a <code class=\"language-text\">^</code>. But how do we support patterns that appear anywhere within the text?</p>\n<h2>Matches Starting Anywhere</h2>\n<p>Currently, the following return <code class=\"language-text\">true</code></p>\n<p><code class=\"language-text\">search(&quot;^abc&quot;, &quot;abc&quot;)</code>\n<code class=\"language-text\">search(&quot;^abcd&quot;, &quot;abcd&quot;)</code></p>\n<p>But <code class=\"language-text\">search(&quot;bc&quot;, &quot;abcd&quot;)</code> will just return <code class=\"language-text\">undefined</code>. We want it to return <code class=\"language-text\">true</code></p>\n<p>If the user does not specify that the pattern matches the beginning of the text, then we want to search for that pattern at every possible starting point within the text. We will default to this behavior if the pattern does not begin with <code class=\"language-text\">^</code><sup><a href=\"#footnote1\">1</a></sup>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'^'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This code will run match(pattern, text.slice(index)) on every index of the text.</span>\n    <span class=\"token comment\">// This means that we test the pattern against every starting point of the text.</span>\n    <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">some</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>The ? Character</h2>\n<p>We want to be able to match 0 to 1 of the character before <code class=\"language-text\">?</code>.</p>\n<p>Here are some examples</p>\n<p><code class=\"language-text\">search(&quot;ab?c&quot;, &quot;ac&quot;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">search(&quot;ab?c&quot;, &quot;abc&quot;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">search(&quot;a?b?c?&quot;, &quot;abc&quot;)</code> -> <code class=\"language-text\">true</code>\n<code class=\"language-text\">search(&quot;a?b?c?&quot;, &quot;&quot;)</code> -> <code class=\"language-text\">true</code></p>\n<p>The first step is to modify <code class=\"language-text\">match</code> to detect when a <code class=\"language-text\">?</code> character is present and then delegate to the <code class=\"language-text\">matchQuestion</code> function, which we will define shortly.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'$'</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Notice that we are looking at pattern[1] instead of pattern[0].</span>\n    <span class=\"token comment\">// pattern[0] is the character to match 0 or 1 of.</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">matchQuestion</code> needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code class=\"language-text\">?</code> is not matched but the text matches the remainder of the pattern (everything after the <code class=\"language-text\">?</code>).</li>\n<li>Where the character before the <code class=\"language-text\">?</code> is matched and the rest of the text (minus the 1 matched character) matches the remainder of the pattern.</li>\n</ol>\n<p>If either of these cases is truthy, then <code class=\"language-text\">matchQuestion</code> can return <code class=\"language-text\">true</code>.</p>\n<p>Let's consider the first case. How do we check if the text matches everything in the pattern except the <code class=\"language-text\">_?</code> syntax? In order words, how do we check if the character before the <code class=\"language-text\">?</code> appears 0 times? We strip 2 characters off the pattern (the first character is the one before the <code class=\"language-text\">?</code> and the second is the <code class=\"language-text\">?</code> itself) and invoke the match function.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The second case is a little more challenging, but just like before, it reuses functions we've already written</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If the <code class=\"language-text\">text[0]</code> matches <code class=\"language-text\">pattern[0]</code>, and the rest of the text (minus the part that is matched by <code class=\"language-text\">matchOne</code>) matches the remainder of the pattern, then we are golden. Note that we could rewrite the code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n    <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The one thing I like about this latter approach is that the boolean OR makes it explicitly clear that there are two cases, either of which may be true.</p>\n<h2>The * Character</h2>\n<p>We want to be able to match the character before the <code class=\"language-text\">*</code> 0 or more times.</p>\n<p>All of these should return <code class=\"language-text\">true</code>.</p>\n<p><code class=\"language-text\">search(&quot;a*&quot;, &quot;&quot;)</code>\n<code class=\"language-text\">search(&quot;a*&quot;, &quot;aaaaaaa&quot;)</code>\n<code class=\"language-text\">search(&quot;a*b&quot;, &quot;aaaaaaab&quot;)</code></p>\n<p>Similar to what we did when supporting <code class=\"language-text\">?</code>, we wan to delegate to a <code class=\"language-text\">matchStar</code> function within our <code class=\"language-text\">match</code> function</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">'$'</span> <span class=\"token operator\">&amp;&amp;</span> text <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchQuestion</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchStar</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">matchStar</code>, like <code class=\"language-text\">matchQuestion</code>, also needs to handle two cases:</p>\n<ol>\n<li>Where the character before the <code class=\"language-text\">*</code> is not matched but the text matches the remainder of the pattern (everything after the <code class=\"language-text\">*</code>).</li>\n<li>Where the character before the <code class=\"language-text\">*</code> is matched one or more times and the rest of the text matches the remainder of the pattern.</li>\n</ol>\n<p>Since there are two cases that both result in a match (0 matches OR more matches), we know that <code class=\"language-text\">matchStar</code> can be implemented with a boolean OR. Furthermore, case 1 for <code class=\"language-text\">matchStar</code> is exactly the same as it was for <code class=\"language-text\">matchQuestion</code> and can be implemented identically using <code class=\"language-text\">match(pattern.slice(2), text)</code>. That means we only need to formulate an expression that satisfies case 2.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchStar</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">matchOne</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Refactoring</h2>\n<p>We can now go back and cleverly simplify <code class=\"language-text\">search</code> using a trick I learned in Peter Norvig's <a href=\"https://www.udacity.com/course/design-of-computer-programs--cs212\">class</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'^'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.*'</span> <span class=\"token operator\">+</span> pattern<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We use the <code class=\"language-text\">*</code> character itself to allow for the pattern to appear anywhere in the string. The prepended <code class=\"language-text\">.*</code> says that any number of any character can appear before the pattern we wish to match.</p>\n<h2>Conclusion</h2>\n<p>It's remarkable how simple and elegant the code for such a sophisticated and generalized program can be. The full source is available in this <a href=\"https://github.com/nadrane/build-your-own-regex\">GitHub repository</a></p>\n<p>Here is a <a href=\"https://nickdrane.com/regex-and-automated-test-fuzzing/\">follow up article</a> where I fuzz test the regex engine.</p>\n<p><em>If you work at a company using javascript, I do <a href=\"/hire-me\">consulting</a> work and am currently looking for new clients. Please <a href=\"mailto:nick@nickdrane.com\">contact me</a> for more details.</em></p>\n<h4>Footnotes</h4>\n<p><a name=\"footnote1\">1</a>: There is a small bug in this code that I'm choosing to ignore. We don't account for the case that text is an empty string. Currently when <code class=\"language-text\">text === &#39;&#39;</code>, <code class=\"language-text\">text.split(&quot;&quot;)</code> will return <code class=\"language-text\">[]</code> and will not appropriately call <code class=\"language-text\">match</code>.</p>","slug":"build-your-own-regex","frontmatter":{"title":"Build a Regex Engine in Less than 40 Lines of Code","date":"2017-11-28T00:00:00.000Z"}}},{"node":{"html":"<p>I posted my article <a href=\"https://nickdrane.com/build-your-own-regex/\">Build Your Own Regex Engine</a> on Reddit the other day, and one of the commenters claimed that the implementation should be trivial to break. Since I had already tested my program against a customized suite of tests, the remark got me thinking about how I could further increase my confidence in the correctness of my program. One extremely low cost however effective strategy for identifying faults in software is known as fuzzing.</p>\n<!-- more -->\n<h2>What is Fuzzing?</h2>\n<p>Fuzzing is a automated testing technique where a program is provided a series of invalid or randomly generated inputs. If we were testing an HTTP API, we might send randomized combinations of query parameters and ensure that our server always returns a 2xx status code. Since Javascript comes with a regular expression engine, my fuzzer asserts that given the same random input, both engine's return the same output.</p>\n<h2>Specifying the Grammar</h2>\n<p>The first step is to specify the grammar that our regex engine supports.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> lowercase <span class=\"token operator\">=</span> <span class=\"token string\">'abcdefghijklmnopqrstuvwxyz'</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> uppercase <span class=\"token operator\">=</span> lowercase<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>letter <span class=\"token operator\">=></span> letter<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> special <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regexGrammar <span class=\"token operator\">=</span> special<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>lowercase<span class=\"token punctuation\">,</span> uppercase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>You might notice we skipped the <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> characters. More on these in a little bit.</p>\n<h2>Generated Valid Regular Expressions</h2>\n<p>We want to write a function <code class=\"language-text\">generateRegex</code> that will select <code class=\"language-text\">n</code> random characters from the <code class=\"language-text\">regexGrammar</code> and concatenate them together into a string. This string will be used to create a test regex.</p>\n<p>Here are three possible returns values of <code class=\"language-text\">generateRegex</code>:</p>\n<ol>\n<li><code class=\"language-text\">.AnrQ?QNLQX.syBsOcJlbJZd</code></li>\n<li><code class=\"language-text\">.LkuZ?Ynj</code></li>\n<li><code class=\"language-text\">.UN?eiyddhXvyNj</code></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> regexString <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>chooseOne<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> regexString<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Pick one element randomly from the grammar and return it</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">chooseOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> regexGrammar<span class=\"token punctuation\">[</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> regexGrammar<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Removing Invalid Regex Strings</h2>\n<p>My regex engine only deals with a very small subset of available regex syntax, and furthermore, it does not contain any error handling. What happens if <code class=\"language-text\">generateRegex</code> returns the pattern <code class=\"language-text\">**</code> or <code class=\"language-text\">^*</code>? My regex engine was never designed to handle these inputs, though they are possible outputs of <code class=\"language-text\">generateRegex</code>. We need to make a choice about how to handle these expressions. Since the primary goal of my regex engine is accessibility and simplicity of implementation, I'm not about to begin supporting these edge cases. That means my fuzzer should not generate them either.</p>\n<p>One solution to determine if a given regex string is valid is to specify my regex engine's allowable grammar in <a href=\"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form\">BNF</a>. BNF is a formal notation for specifying the syntax of a language. Given this BNF notation, I could ask another program if the randomly generated regex string can be created using my BNF specification. This sounds like a little more work than I want, however, since the invalid cases can simply be manually enumerated and filtered.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">validRegex</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">// None of the following sequences are properly</span>\n    <span class=\"token comment\">// defined by my regex engine</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'**'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'??'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'*?'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?*'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'^?'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    regexString<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'^*'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>regexString<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>regexString<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> regexString <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>chooseOne<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// If the generated string is valid, return it</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">validRegex</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> regexString<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Otherwise generate a new string and return that</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">generateRegexString</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>One more modification to <code class=\"language-text\">generateRegex</code> is necessary to support <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code>, and then we are basically done.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">generateRegex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token comment\">// We need to ensure that '^' and '$' only go at the beginning</span>\n  <span class=\"token comment\">// and the end of the string, respectively.</span>\n  <span class=\"token comment\">// Give each a 10% probability of appearing in a string</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span> regexString <span class=\"token operator\">=</span> <span class=\"token string\">\"^\"</span> <span class=\"token operator\">+</span> regexString<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span> regexString <span class=\"token operator\">=</span> regexString <span class=\"token operator\">+</span> <span class=\"token string\">\"$\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Comparing Regex Implementations</h2>\n<p>All that is required now is to repeatedly invoke <code class=\"language-text\">generateRegex</code> a fixed number of times and then compare the output of the native JS implementation with the output of my implementation.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// The corpus is the string of text we are matching the pattern against.</span>\n<span class=\"token comment\">// I used a segment of Gulliver's Travels from Project Gutenberg.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fuzzer</span><span class=\"token punctuation\">(</span>totalTests<span class=\"token punctuation\">,</span> corpus<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> maxRegexLength <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// max will actually be 50 - 1</span>\n  <span class=\"token keyword\">let</span> testsRun <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>testsRun <span class=\"token operator\">&lt;</span> totalTests<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> regexLength <span class=\"token operator\">=</span> <span class=\"token function\">getRandomInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> maxRegexLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> regexString <span class=\"token operator\">=</span> <span class=\"token function\">generateRegexString</span><span class=\"token punctuation\">(</span>regexLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> testRegex <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>testRegex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>corpus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">myRegexEngine</span><span class=\"token punctuation\">(</span>regexString<span class=\"token punctuation\">,</span> corpus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>testRegex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    testsRun<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Thank you Mozzila :)</span>\n<span class=\"token comment\">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getRandomInt</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  min <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">ceil</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  max <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>max <span class=\"token operator\">-</span> min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> min<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Results</h2>\n<p>I ran my fuzzer for a couple million randomly generated cases and ended up learning two things about my regex engine.</p>\n<ol>\n<li>\n<p>My implementation fails extraordinarily with longer texts. I knew recursion would be a problem for any practical regex implementation (at least without <a href=\"https://en.wikipedia.org/wiki/Tail_call\">tail calls</a>) and would cause stack overflows, but I didn't expect it to fail with texts that were only a couple thousand words. I think this is because I make liberal use of backtracking algorithms in <code class=\"language-text\">matchQuestion</code> and <code class=\"language-text\">matchStar</code>. Since I was forced to test with a relatively short input text, it makes sense to use multiple text inputs to increase the probability of discovering an error.</p>\n</li>\n<li>\n<p>My implementation treats the <code class=\"language-text\">.</code> character differently than the native implementation. In the RegExp implementation, <code class=\"language-text\">.</code> will not match various line terminators (<code class=\"language-text\">\\n</code>, <code class=\"language-text\">\\r</code>, <code class=\"language-text\">\\u2028</code> or <code class=\"language-text\">\\u2029</code>). My implementation does.</p>\n</li>\n</ol>\n<h2>Conclusion</h2>\n<p>The biggest takeaway is that fuzzing is an simple and inexpensive way to enumerate enormous sets of inputs and identify bugs in your software. This fuzzer took less than an hour to write.</p>\n<p>But remember, this fuzzer's blessing of a couple million input combinations <strong>does not</strong> verify the correctness of my program. Not even close. A fuzzer is a tool to identify potential errors. Unless you enumerate all possible inputs (completely impossible in this case where they are infinite), you are not guaranteed your program is error free.</p>","slug":"regex-and-automated-test-fuzzing","frontmatter":{"title":"Regex And Automated Test Fuzzing","date":"2017-12-06T00:00:00.000Z"}}}]}},"pageContext":{"category":"Regular Expressions"}}